import * as $protobuf from "protobufjs";
import Long = require("long");
/** Namespace geyser. */
export namespace geyser {

    /** Represents a Geyser */
    class Geyser extends $protobuf.rpc.Service {

        /**
         * Constructs a new Geyser service.
         * @param rpcImpl RPC implementation
         * @param [requestDelimited=false] Whether requests are length-delimited
         * @param [responseDelimited=false] Whether responses are length-delimited
         */
        constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

        /**
         * Creates new Geyser service using the specified rpc implementation.
         * @param rpcImpl RPC implementation
         * @param [requestDelimited=false] Whether requests are length-delimited
         * @param [responseDelimited=false] Whether responses are length-delimited
         * @returns RPC service. Useful where requests and/or responses are streamed.
         */
        public static create(rpcImpl: $protobuf.RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): Geyser;

        /**
         * Calls Subscribe.
         * @param request SubscribeRequest message or plain object
         * @param callback Node-style callback called with the error, if any, and SubscribeUpdate
         */
        public subscribe(request: geyser.ISubscribeRequest, callback: geyser.Geyser.SubscribeCallback): void;

        /**
         * Calls Subscribe.
         * @param request SubscribeRequest message or plain object
         * @returns Promise
         */
        public subscribe(request: geyser.ISubscribeRequest): Promise<geyser.SubscribeUpdate>;

        /**
         * Calls SubscribePreprocessed.
         * @param request SubscribePreprocessedRequest message or plain object
         * @param callback Node-style callback called with the error, if any, and SubscribePreprocessedUpdate
         */
        public subscribePreprocessed(request: geyser.ISubscribePreprocessedRequest, callback: geyser.Geyser.SubscribePreprocessedCallback): void;

        /**
         * Calls SubscribePreprocessed.
         * @param request SubscribePreprocessedRequest message or plain object
         * @returns Promise
         */
        public subscribePreprocessed(request: geyser.ISubscribePreprocessedRequest): Promise<geyser.SubscribePreprocessedUpdate>;

        /**
         * Calls SubscribeReplayInfo.
         * @param request SubscribeReplayInfoRequest message or plain object
         * @param callback Node-style callback called with the error, if any, and SubscribeReplayInfoResponse
         */
        public subscribeReplayInfo(request: geyser.ISubscribeReplayInfoRequest, callback: geyser.Geyser.SubscribeReplayInfoCallback): void;

        /**
         * Calls SubscribeReplayInfo.
         * @param request SubscribeReplayInfoRequest message or plain object
         * @returns Promise
         */
        public subscribeReplayInfo(request: geyser.ISubscribeReplayInfoRequest): Promise<geyser.SubscribeReplayInfoResponse>;

        /**
         * Calls Ping.
         * @param request PingRequest message or plain object
         * @param callback Node-style callback called with the error, if any, and PongResponse
         */
        public ping(request: geyser.IPingRequest, callback: geyser.Geyser.PingCallback): void;

        /**
         * Calls Ping.
         * @param request PingRequest message or plain object
         * @returns Promise
         */
        public ping(request: geyser.IPingRequest): Promise<geyser.PongResponse>;

        /**
         * Calls GetLatestBlockhash.
         * @param request GetLatestBlockhashRequest message or plain object
         * @param callback Node-style callback called with the error, if any, and GetLatestBlockhashResponse
         */
        public getLatestBlockhash(request: geyser.IGetLatestBlockhashRequest, callback: geyser.Geyser.GetLatestBlockhashCallback): void;

        /**
         * Calls GetLatestBlockhash.
         * @param request GetLatestBlockhashRequest message or plain object
         * @returns Promise
         */
        public getLatestBlockhash(request: geyser.IGetLatestBlockhashRequest): Promise<geyser.GetLatestBlockhashResponse>;

        /**
         * Calls GetBlockHeight.
         * @param request GetBlockHeightRequest message or plain object
         * @param callback Node-style callback called with the error, if any, and GetBlockHeightResponse
         */
        public getBlockHeight(request: geyser.IGetBlockHeightRequest, callback: geyser.Geyser.GetBlockHeightCallback): void;

        /**
         * Calls GetBlockHeight.
         * @param request GetBlockHeightRequest message or plain object
         * @returns Promise
         */
        public getBlockHeight(request: geyser.IGetBlockHeightRequest): Promise<geyser.GetBlockHeightResponse>;

        /**
         * Calls GetSlot.
         * @param request GetSlotRequest message or plain object
         * @param callback Node-style callback called with the error, if any, and GetSlotResponse
         */
        public getSlot(request: geyser.IGetSlotRequest, callback: geyser.Geyser.GetSlotCallback): void;

        /**
         * Calls GetSlot.
         * @param request GetSlotRequest message or plain object
         * @returns Promise
         */
        public getSlot(request: geyser.IGetSlotRequest): Promise<geyser.GetSlotResponse>;

        /**
         * Calls IsBlockhashValid.
         * @param request IsBlockhashValidRequest message or plain object
         * @param callback Node-style callback called with the error, if any, and IsBlockhashValidResponse
         */
        public isBlockhashValid(request: geyser.IIsBlockhashValidRequest, callback: geyser.Geyser.IsBlockhashValidCallback): void;

        /**
         * Calls IsBlockhashValid.
         * @param request IsBlockhashValidRequest message or plain object
         * @returns Promise
         */
        public isBlockhashValid(request: geyser.IIsBlockhashValidRequest): Promise<geyser.IsBlockhashValidResponse>;

        /**
         * Calls GetVersion.
         * @param request GetVersionRequest message or plain object
         * @param callback Node-style callback called with the error, if any, and GetVersionResponse
         */
        public getVersion(request: geyser.IGetVersionRequest, callback: geyser.Geyser.GetVersionCallback): void;

        /**
         * Calls GetVersion.
         * @param request GetVersionRequest message or plain object
         * @returns Promise
         */
        public getVersion(request: geyser.IGetVersionRequest): Promise<geyser.GetVersionResponse>;
    }

    namespace Geyser {

        /**
         * Callback as used by {@link geyser.Geyser#subscribe}.
         * @param error Error, if any
         * @param [response] SubscribeUpdate
         */
        type SubscribeCallback = (error: (Error|null), response?: geyser.SubscribeUpdate) => void;

        /**
         * Callback as used by {@link geyser.Geyser#subscribePreprocessed}.
         * @param error Error, if any
         * @param [response] SubscribePreprocessedUpdate
         */
        type SubscribePreprocessedCallback = (error: (Error|null), response?: geyser.SubscribePreprocessedUpdate) => void;

        /**
         * Callback as used by {@link geyser.Geyser#subscribeReplayInfo}.
         * @param error Error, if any
         * @param [response] SubscribeReplayInfoResponse
         */
        type SubscribeReplayInfoCallback = (error: (Error|null), response?: geyser.SubscribeReplayInfoResponse) => void;

        /**
         * Callback as used by {@link geyser.Geyser#ping}.
         * @param error Error, if any
         * @param [response] PongResponse
         */
        type PingCallback = (error: (Error|null), response?: geyser.PongResponse) => void;

        /**
         * Callback as used by {@link geyser.Geyser#getLatestBlockhash}.
         * @param error Error, if any
         * @param [response] GetLatestBlockhashResponse
         */
        type GetLatestBlockhashCallback = (error: (Error|null), response?: geyser.GetLatestBlockhashResponse) => void;

        /**
         * Callback as used by {@link geyser.Geyser#getBlockHeight}.
         * @param error Error, if any
         * @param [response] GetBlockHeightResponse
         */
        type GetBlockHeightCallback = (error: (Error|null), response?: geyser.GetBlockHeightResponse) => void;

        /**
         * Callback as used by {@link geyser.Geyser#getSlot}.
         * @param error Error, if any
         * @param [response] GetSlotResponse
         */
        type GetSlotCallback = (error: (Error|null), response?: geyser.GetSlotResponse) => void;

        /**
         * Callback as used by {@link geyser.Geyser#isBlockhashValid}.
         * @param error Error, if any
         * @param [response] IsBlockhashValidResponse
         */
        type IsBlockhashValidCallback = (error: (Error|null), response?: geyser.IsBlockhashValidResponse) => void;

        /**
         * Callback as used by {@link geyser.Geyser#getVersion}.
         * @param error Error, if any
         * @param [response] GetVersionResponse
         */
        type GetVersionCallback = (error: (Error|null), response?: geyser.GetVersionResponse) => void;
    }

    /** Properties of a SubscribePreprocessedRequest. */
    interface ISubscribePreprocessedRequest {

        /** SubscribePreprocessedRequest transactions */
        transactions?: ({ [k: string]: geyser.ISubscribePreprocessedRequestFilterTransactions }|null);

        /** SubscribePreprocessedRequest ping */
        ping?: (geyser.ISubscribeRequestPing|null);
    }

    /** Represents a SubscribePreprocessedRequest. */
    class SubscribePreprocessedRequest implements ISubscribePreprocessedRequest {

        /**
         * Constructs a new SubscribePreprocessedRequest.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribePreprocessedRequest);

        /** SubscribePreprocessedRequest transactions. */
        public transactions: { [k: string]: geyser.ISubscribePreprocessedRequestFilterTransactions };

        /** SubscribePreprocessedRequest ping. */
        public ping?: (geyser.ISubscribeRequestPing|null);

        /** SubscribePreprocessedRequest _ping. */
        public _ping?: "ping";

        /**
         * Creates a new SubscribePreprocessedRequest instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribePreprocessedRequest instance
         */
        public static create(properties?: geyser.ISubscribePreprocessedRequest): geyser.SubscribePreprocessedRequest;

        /**
         * Encodes the specified SubscribePreprocessedRequest message. Does not implicitly {@link geyser.SubscribePreprocessedRequest.verify|verify} messages.
         * @param message SubscribePreprocessedRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribePreprocessedRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribePreprocessedRequest message, length delimited. Does not implicitly {@link geyser.SubscribePreprocessedRequest.verify|verify} messages.
         * @param message SubscribePreprocessedRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribePreprocessedRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribePreprocessedRequest message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribePreprocessedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribePreprocessedRequest;

        /**
         * Decodes a SubscribePreprocessedRequest message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribePreprocessedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribePreprocessedRequest;

        /**
         * Verifies a SubscribePreprocessedRequest message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribePreprocessedRequest message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribePreprocessedRequest
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribePreprocessedRequest;

        /**
         * Creates a plain object from a SubscribePreprocessedRequest message. Also converts values to other types if specified.
         * @param message SubscribePreprocessedRequest
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribePreprocessedRequest, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribePreprocessedRequest to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribePreprocessedRequest
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribePreprocessedRequestFilterTransactions. */
    interface ISubscribePreprocessedRequestFilterTransactions {

        /** SubscribePreprocessedRequestFilterTransactions vote */
        vote?: (boolean|null);

        /** SubscribePreprocessedRequestFilterTransactions signature */
        signature?: (string|null);

        /** SubscribePreprocessedRequestFilterTransactions accountInclude */
        accountInclude?: (string[]|null);

        /** SubscribePreprocessedRequestFilterTransactions accountExclude */
        accountExclude?: (string[]|null);

        /** SubscribePreprocessedRequestFilterTransactions accountRequired */
        accountRequired?: (string[]|null);
    }

    /** Represents a SubscribePreprocessedRequestFilterTransactions. */
    class SubscribePreprocessedRequestFilterTransactions implements ISubscribePreprocessedRequestFilterTransactions {

        /**
         * Constructs a new SubscribePreprocessedRequestFilterTransactions.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribePreprocessedRequestFilterTransactions);

        /** SubscribePreprocessedRequestFilterTransactions vote. */
        public vote?: (boolean|null);

        /** SubscribePreprocessedRequestFilterTransactions signature. */
        public signature?: (string|null);

        /** SubscribePreprocessedRequestFilterTransactions accountInclude. */
        public accountInclude: string[];

        /** SubscribePreprocessedRequestFilterTransactions accountExclude. */
        public accountExclude: string[];

        /** SubscribePreprocessedRequestFilterTransactions accountRequired. */
        public accountRequired: string[];

        /** SubscribePreprocessedRequestFilterTransactions _vote. */
        public _vote?: "vote";

        /** SubscribePreprocessedRequestFilterTransactions _signature. */
        public _signature?: "signature";

        /**
         * Creates a new SubscribePreprocessedRequestFilterTransactions instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribePreprocessedRequestFilterTransactions instance
         */
        public static create(properties?: geyser.ISubscribePreprocessedRequestFilterTransactions): geyser.SubscribePreprocessedRequestFilterTransactions;

        /**
         * Encodes the specified SubscribePreprocessedRequestFilterTransactions message. Does not implicitly {@link geyser.SubscribePreprocessedRequestFilterTransactions.verify|verify} messages.
         * @param message SubscribePreprocessedRequestFilterTransactions message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribePreprocessedRequestFilterTransactions, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribePreprocessedRequestFilterTransactions message, length delimited. Does not implicitly {@link geyser.SubscribePreprocessedRequestFilterTransactions.verify|verify} messages.
         * @param message SubscribePreprocessedRequestFilterTransactions message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribePreprocessedRequestFilterTransactions, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribePreprocessedRequestFilterTransactions message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribePreprocessedRequestFilterTransactions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribePreprocessedRequestFilterTransactions;

        /**
         * Decodes a SubscribePreprocessedRequestFilterTransactions message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribePreprocessedRequestFilterTransactions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribePreprocessedRequestFilterTransactions;

        /**
         * Verifies a SubscribePreprocessedRequestFilterTransactions message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribePreprocessedRequestFilterTransactions message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribePreprocessedRequestFilterTransactions
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribePreprocessedRequestFilterTransactions;

        /**
         * Creates a plain object from a SubscribePreprocessedRequestFilterTransactions message. Also converts values to other types if specified.
         * @param message SubscribePreprocessedRequestFilterTransactions
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribePreprocessedRequestFilterTransactions, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribePreprocessedRequestFilterTransactions to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribePreprocessedRequestFilterTransactions
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribePreprocessedUpdate. */
    interface ISubscribePreprocessedUpdate {

        /** SubscribePreprocessedUpdate filters */
        filters?: (string[]|null);

        /** SubscribePreprocessedUpdate transaction */
        transaction?: (geyser.ISubscribePreprocessedTransaction|null);

        /** SubscribePreprocessedUpdate ping */
        ping?: (geyser.ISubscribeUpdatePing|null);

        /** SubscribePreprocessedUpdate pong */
        pong?: (geyser.ISubscribeUpdatePong|null);

        /** SubscribePreprocessedUpdate createdAt */
        createdAt?: (google.protobuf.ITimestamp|null);
    }

    /** Represents a SubscribePreprocessedUpdate. */
    class SubscribePreprocessedUpdate implements ISubscribePreprocessedUpdate {

        /**
         * Constructs a new SubscribePreprocessedUpdate.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribePreprocessedUpdate);

        /** SubscribePreprocessedUpdate filters. */
        public filters: string[];

        /** SubscribePreprocessedUpdate transaction. */
        public transaction?: (geyser.ISubscribePreprocessedTransaction|null);

        /** SubscribePreprocessedUpdate ping. */
        public ping?: (geyser.ISubscribeUpdatePing|null);

        /** SubscribePreprocessedUpdate pong. */
        public pong?: (geyser.ISubscribeUpdatePong|null);

        /** SubscribePreprocessedUpdate createdAt. */
        public createdAt?: (google.protobuf.ITimestamp|null);

        /** SubscribePreprocessedUpdate updateOneof. */
        public updateOneof?: ("transaction"|"ping"|"pong");

        /**
         * Creates a new SubscribePreprocessedUpdate instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribePreprocessedUpdate instance
         */
        public static create(properties?: geyser.ISubscribePreprocessedUpdate): geyser.SubscribePreprocessedUpdate;

        /**
         * Encodes the specified SubscribePreprocessedUpdate message. Does not implicitly {@link geyser.SubscribePreprocessedUpdate.verify|verify} messages.
         * @param message SubscribePreprocessedUpdate message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribePreprocessedUpdate, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribePreprocessedUpdate message, length delimited. Does not implicitly {@link geyser.SubscribePreprocessedUpdate.verify|verify} messages.
         * @param message SubscribePreprocessedUpdate message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribePreprocessedUpdate, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribePreprocessedUpdate message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribePreprocessedUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribePreprocessedUpdate;

        /**
         * Decodes a SubscribePreprocessedUpdate message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribePreprocessedUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribePreprocessedUpdate;

        /**
         * Verifies a SubscribePreprocessedUpdate message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribePreprocessedUpdate message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribePreprocessedUpdate
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribePreprocessedUpdate;

        /**
         * Creates a plain object from a SubscribePreprocessedUpdate message. Also converts values to other types if specified.
         * @param message SubscribePreprocessedUpdate
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribePreprocessedUpdate, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribePreprocessedUpdate to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribePreprocessedUpdate
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribePreprocessedTransaction. */
    interface ISubscribePreprocessedTransaction {

        /** SubscribePreprocessedTransaction transaction */
        transaction?: (geyser.ISubscribePreprocessedTransactionInfo|null);

        /** SubscribePreprocessedTransaction slot */
        slot?: (number|Long|null);
    }

    /** Represents a SubscribePreprocessedTransaction. */
    class SubscribePreprocessedTransaction implements ISubscribePreprocessedTransaction {

        /**
         * Constructs a new SubscribePreprocessedTransaction.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribePreprocessedTransaction);

        /** SubscribePreprocessedTransaction transaction. */
        public transaction?: (geyser.ISubscribePreprocessedTransactionInfo|null);

        /** SubscribePreprocessedTransaction slot. */
        public slot: (number|Long);

        /**
         * Creates a new SubscribePreprocessedTransaction instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribePreprocessedTransaction instance
         */
        public static create(properties?: geyser.ISubscribePreprocessedTransaction): geyser.SubscribePreprocessedTransaction;

        /**
         * Encodes the specified SubscribePreprocessedTransaction message. Does not implicitly {@link geyser.SubscribePreprocessedTransaction.verify|verify} messages.
         * @param message SubscribePreprocessedTransaction message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribePreprocessedTransaction, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribePreprocessedTransaction message, length delimited. Does not implicitly {@link geyser.SubscribePreprocessedTransaction.verify|verify} messages.
         * @param message SubscribePreprocessedTransaction message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribePreprocessedTransaction, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribePreprocessedTransaction message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribePreprocessedTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribePreprocessedTransaction;

        /**
         * Decodes a SubscribePreprocessedTransaction message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribePreprocessedTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribePreprocessedTransaction;

        /**
         * Verifies a SubscribePreprocessedTransaction message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribePreprocessedTransaction message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribePreprocessedTransaction
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribePreprocessedTransaction;

        /**
         * Creates a plain object from a SubscribePreprocessedTransaction message. Also converts values to other types if specified.
         * @param message SubscribePreprocessedTransaction
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribePreprocessedTransaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribePreprocessedTransaction to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribePreprocessedTransaction
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribePreprocessedTransactionInfo. */
    interface ISubscribePreprocessedTransactionInfo {

        /** SubscribePreprocessedTransactionInfo signature */
        signature?: (Uint8Array|null);

        /** SubscribePreprocessedTransactionInfo isVote */
        isVote?: (boolean|null);

        /** SubscribePreprocessedTransactionInfo transaction */
        transaction?: (solana.storage.ConfirmedBlock.ITransaction|null);
    }

    /** Represents a SubscribePreprocessedTransactionInfo. */
    class SubscribePreprocessedTransactionInfo implements ISubscribePreprocessedTransactionInfo {

        /**
         * Constructs a new SubscribePreprocessedTransactionInfo.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribePreprocessedTransactionInfo);

        /** SubscribePreprocessedTransactionInfo signature. */
        public signature: Uint8Array;

        /** SubscribePreprocessedTransactionInfo isVote. */
        public isVote: boolean;

        /** SubscribePreprocessedTransactionInfo transaction. */
        public transaction?: (solana.storage.ConfirmedBlock.ITransaction|null);

        /**
         * Creates a new SubscribePreprocessedTransactionInfo instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribePreprocessedTransactionInfo instance
         */
        public static create(properties?: geyser.ISubscribePreprocessedTransactionInfo): geyser.SubscribePreprocessedTransactionInfo;

        /**
         * Encodes the specified SubscribePreprocessedTransactionInfo message. Does not implicitly {@link geyser.SubscribePreprocessedTransactionInfo.verify|verify} messages.
         * @param message SubscribePreprocessedTransactionInfo message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribePreprocessedTransactionInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribePreprocessedTransactionInfo message, length delimited. Does not implicitly {@link geyser.SubscribePreprocessedTransactionInfo.verify|verify} messages.
         * @param message SubscribePreprocessedTransactionInfo message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribePreprocessedTransactionInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribePreprocessedTransactionInfo message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribePreprocessedTransactionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribePreprocessedTransactionInfo;

        /**
         * Decodes a SubscribePreprocessedTransactionInfo message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribePreprocessedTransactionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribePreprocessedTransactionInfo;

        /**
         * Verifies a SubscribePreprocessedTransactionInfo message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribePreprocessedTransactionInfo message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribePreprocessedTransactionInfo
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribePreprocessedTransactionInfo;

        /**
         * Creates a plain object from a SubscribePreprocessedTransactionInfo message. Also converts values to other types if specified.
         * @param message SubscribePreprocessedTransactionInfo
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribePreprocessedTransactionInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribePreprocessedTransactionInfo to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribePreprocessedTransactionInfo
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** CommitmentLevel enum. */
    enum CommitmentLevel {
        PROCESSED = 0,
        CONFIRMED = 1,
        FINALIZED = 2
    }

    /** SlotStatus enum. */
    enum SlotStatus {
        SLOT_PROCESSED = 0,
        SLOT_CONFIRMED = 1,
        SLOT_FINALIZED = 2,
        SLOT_FIRST_SHRED_RECEIVED = 3,
        SLOT_COMPLETED = 4,
        SLOT_CREATED_BANK = 5,
        SLOT_DEAD = 6
    }

    /** Properties of a SubscribeRequest. */
    interface ISubscribeRequest {

        /** SubscribeRequest accounts */
        accounts?: ({ [k: string]: geyser.ISubscribeRequestFilterAccounts }|null);

        /** SubscribeRequest slots */
        slots?: ({ [k: string]: geyser.ISubscribeRequestFilterSlots }|null);

        /** SubscribeRequest transactions */
        transactions?: ({ [k: string]: geyser.ISubscribeRequestFilterTransactions }|null);

        /** SubscribeRequest transactionsStatus */
        transactionsStatus?: ({ [k: string]: geyser.ISubscribeRequestFilterTransactions }|null);

        /** SubscribeRequest blocks */
        blocks?: ({ [k: string]: geyser.ISubscribeRequestFilterBlocks }|null);

        /** SubscribeRequest blocksMeta */
        blocksMeta?: ({ [k: string]: geyser.ISubscribeRequestFilterBlocksMeta }|null);

        /** SubscribeRequest entry */
        entry?: ({ [k: string]: geyser.ISubscribeRequestFilterEntry }|null);

        /** SubscribeRequest commitment */
        commitment?: (geyser.CommitmentLevel|null);

        /** SubscribeRequest accountsDataSlice */
        accountsDataSlice?: (geyser.ISubscribeRequestAccountsDataSlice[]|null);

        /** SubscribeRequest ping */
        ping?: (geyser.ISubscribeRequestPing|null);

        /** SubscribeRequest fromSlot */
        fromSlot?: (number|Long|null);
    }

    /** Represents a SubscribeRequest. */
    class SubscribeRequest implements ISubscribeRequest {

        /**
         * Constructs a new SubscribeRequest.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeRequest);

        /** SubscribeRequest accounts. */
        public accounts: { [k: string]: geyser.ISubscribeRequestFilterAccounts };

        /** SubscribeRequest slots. */
        public slots: { [k: string]: geyser.ISubscribeRequestFilterSlots };

        /** SubscribeRequest transactions. */
        public transactions: { [k: string]: geyser.ISubscribeRequestFilterTransactions };

        /** SubscribeRequest transactionsStatus. */
        public transactionsStatus: { [k: string]: geyser.ISubscribeRequestFilterTransactions };

        /** SubscribeRequest blocks. */
        public blocks: { [k: string]: geyser.ISubscribeRequestFilterBlocks };

        /** SubscribeRequest blocksMeta. */
        public blocksMeta: { [k: string]: geyser.ISubscribeRequestFilterBlocksMeta };

        /** SubscribeRequest entry. */
        public entry: { [k: string]: geyser.ISubscribeRequestFilterEntry };

        /** SubscribeRequest commitment. */
        public commitment?: (geyser.CommitmentLevel|null);

        /** SubscribeRequest accountsDataSlice. */
        public accountsDataSlice: geyser.ISubscribeRequestAccountsDataSlice[];

        /** SubscribeRequest ping. */
        public ping?: (geyser.ISubscribeRequestPing|null);

        /** SubscribeRequest fromSlot. */
        public fromSlot?: (number|Long|null);

        /** SubscribeRequest _commitment. */
        public _commitment?: "commitment";

        /** SubscribeRequest _ping. */
        public _ping?: "ping";

        /** SubscribeRequest _fromSlot. */
        public _fromSlot?: "fromSlot";

        /**
         * Creates a new SubscribeRequest instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeRequest instance
         */
        public static create(properties?: geyser.ISubscribeRequest): geyser.SubscribeRequest;

        /**
         * Encodes the specified SubscribeRequest message. Does not implicitly {@link geyser.SubscribeRequest.verify|verify} messages.
         * @param message SubscribeRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeRequest message, length delimited. Does not implicitly {@link geyser.SubscribeRequest.verify|verify} messages.
         * @param message SubscribeRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeRequest message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeRequest;

        /**
         * Decodes a SubscribeRequest message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeRequest;

        /**
         * Verifies a SubscribeRequest message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeRequest message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeRequest
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeRequest;

        /**
         * Creates a plain object from a SubscribeRequest message. Also converts values to other types if specified.
         * @param message SubscribeRequest
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeRequest, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeRequest to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeRequest
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeRequestFilterAccounts. */
    interface ISubscribeRequestFilterAccounts {

        /** SubscribeRequestFilterAccounts account */
        account?: (string[]|null);

        /** SubscribeRequestFilterAccounts owner */
        owner?: (string[]|null);

        /** SubscribeRequestFilterAccounts filters */
        filters?: (geyser.ISubscribeRequestFilterAccountsFilter[]|null);

        /** SubscribeRequestFilterAccounts nonemptyTxnSignature */
        nonemptyTxnSignature?: (boolean|null);
    }

    /** Represents a SubscribeRequestFilterAccounts. */
    class SubscribeRequestFilterAccounts implements ISubscribeRequestFilterAccounts {

        /**
         * Constructs a new SubscribeRequestFilterAccounts.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeRequestFilterAccounts);

        /** SubscribeRequestFilterAccounts account. */
        public account: string[];

        /** SubscribeRequestFilterAccounts owner. */
        public owner: string[];

        /** SubscribeRequestFilterAccounts filters. */
        public filters: geyser.ISubscribeRequestFilterAccountsFilter[];

        /** SubscribeRequestFilterAccounts nonemptyTxnSignature. */
        public nonemptyTxnSignature?: (boolean|null);

        /** SubscribeRequestFilterAccounts _nonemptyTxnSignature. */
        public _nonemptyTxnSignature?: "nonemptyTxnSignature";

        /**
         * Creates a new SubscribeRequestFilterAccounts instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeRequestFilterAccounts instance
         */
        public static create(properties?: geyser.ISubscribeRequestFilterAccounts): geyser.SubscribeRequestFilterAccounts;

        /**
         * Encodes the specified SubscribeRequestFilterAccounts message. Does not implicitly {@link geyser.SubscribeRequestFilterAccounts.verify|verify} messages.
         * @param message SubscribeRequestFilterAccounts message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeRequestFilterAccounts, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeRequestFilterAccounts message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterAccounts.verify|verify} messages.
         * @param message SubscribeRequestFilterAccounts message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeRequestFilterAccounts, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeRequestFilterAccounts message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeRequestFilterAccounts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeRequestFilterAccounts;

        /**
         * Decodes a SubscribeRequestFilterAccounts message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeRequestFilterAccounts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeRequestFilterAccounts;

        /**
         * Verifies a SubscribeRequestFilterAccounts message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeRequestFilterAccounts message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeRequestFilterAccounts
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeRequestFilterAccounts;

        /**
         * Creates a plain object from a SubscribeRequestFilterAccounts message. Also converts values to other types if specified.
         * @param message SubscribeRequestFilterAccounts
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeRequestFilterAccounts, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeRequestFilterAccounts to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeRequestFilterAccounts
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeRequestFilterAccountsFilter. */
    interface ISubscribeRequestFilterAccountsFilter {

        /** SubscribeRequestFilterAccountsFilter memcmp */
        memcmp?: (geyser.ISubscribeRequestFilterAccountsFilterMemcmp|null);

        /** SubscribeRequestFilterAccountsFilter datasize */
        datasize?: (number|Long|null);

        /** SubscribeRequestFilterAccountsFilter tokenAccountState */
        tokenAccountState?: (boolean|null);

        /** SubscribeRequestFilterAccountsFilter lamports */
        lamports?: (geyser.ISubscribeRequestFilterAccountsFilterLamports|null);
    }

    /** Represents a SubscribeRequestFilterAccountsFilter. */
    class SubscribeRequestFilterAccountsFilter implements ISubscribeRequestFilterAccountsFilter {

        /**
         * Constructs a new SubscribeRequestFilterAccountsFilter.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeRequestFilterAccountsFilter);

        /** SubscribeRequestFilterAccountsFilter memcmp. */
        public memcmp?: (geyser.ISubscribeRequestFilterAccountsFilterMemcmp|null);

        /** SubscribeRequestFilterAccountsFilter datasize. */
        public datasize?: (number|Long|null);

        /** SubscribeRequestFilterAccountsFilter tokenAccountState. */
        public tokenAccountState?: (boolean|null);

        /** SubscribeRequestFilterAccountsFilter lamports. */
        public lamports?: (geyser.ISubscribeRequestFilterAccountsFilterLamports|null);

        /** SubscribeRequestFilterAccountsFilter filter. */
        public filter?: ("memcmp"|"datasize"|"tokenAccountState"|"lamports");

        /**
         * Creates a new SubscribeRequestFilterAccountsFilter instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeRequestFilterAccountsFilter instance
         */
        public static create(properties?: geyser.ISubscribeRequestFilterAccountsFilter): geyser.SubscribeRequestFilterAccountsFilter;

        /**
         * Encodes the specified SubscribeRequestFilterAccountsFilter message. Does not implicitly {@link geyser.SubscribeRequestFilterAccountsFilter.verify|verify} messages.
         * @param message SubscribeRequestFilterAccountsFilter message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeRequestFilterAccountsFilter, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeRequestFilterAccountsFilter message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterAccountsFilter.verify|verify} messages.
         * @param message SubscribeRequestFilterAccountsFilter message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeRequestFilterAccountsFilter, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeRequestFilterAccountsFilter message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeRequestFilterAccountsFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeRequestFilterAccountsFilter;

        /**
         * Decodes a SubscribeRequestFilterAccountsFilter message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeRequestFilterAccountsFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeRequestFilterAccountsFilter;

        /**
         * Verifies a SubscribeRequestFilterAccountsFilter message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeRequestFilterAccountsFilter message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeRequestFilterAccountsFilter
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeRequestFilterAccountsFilter;

        /**
         * Creates a plain object from a SubscribeRequestFilterAccountsFilter message. Also converts values to other types if specified.
         * @param message SubscribeRequestFilterAccountsFilter
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeRequestFilterAccountsFilter, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeRequestFilterAccountsFilter to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeRequestFilterAccountsFilter
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeRequestFilterAccountsFilterMemcmp. */
    interface ISubscribeRequestFilterAccountsFilterMemcmp {

        /** SubscribeRequestFilterAccountsFilterMemcmp offset */
        offset?: (number|Long|null);

        /** SubscribeRequestFilterAccountsFilterMemcmp bytes */
        bytes?: (Uint8Array|null);

        /** SubscribeRequestFilterAccountsFilterMemcmp base58 */
        base58?: (string|null);

        /** SubscribeRequestFilterAccountsFilterMemcmp base64 */
        base64?: (string|null);
    }

    /** Represents a SubscribeRequestFilterAccountsFilterMemcmp. */
    class SubscribeRequestFilterAccountsFilterMemcmp implements ISubscribeRequestFilterAccountsFilterMemcmp {

        /**
         * Constructs a new SubscribeRequestFilterAccountsFilterMemcmp.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeRequestFilterAccountsFilterMemcmp);

        /** SubscribeRequestFilterAccountsFilterMemcmp offset. */
        public offset: (number|Long);

        /** SubscribeRequestFilterAccountsFilterMemcmp bytes. */
        public bytes?: (Uint8Array|null);

        /** SubscribeRequestFilterAccountsFilterMemcmp base58. */
        public base58?: (string|null);

        /** SubscribeRequestFilterAccountsFilterMemcmp base64. */
        public base64?: (string|null);

        /** SubscribeRequestFilterAccountsFilterMemcmp data. */
        public data?: ("bytes"|"base58"|"base64");

        /**
         * Creates a new SubscribeRequestFilterAccountsFilterMemcmp instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeRequestFilterAccountsFilterMemcmp instance
         */
        public static create(properties?: geyser.ISubscribeRequestFilterAccountsFilterMemcmp): geyser.SubscribeRequestFilterAccountsFilterMemcmp;

        /**
         * Encodes the specified SubscribeRequestFilterAccountsFilterMemcmp message. Does not implicitly {@link geyser.SubscribeRequestFilterAccountsFilterMemcmp.verify|verify} messages.
         * @param message SubscribeRequestFilterAccountsFilterMemcmp message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeRequestFilterAccountsFilterMemcmp, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeRequestFilterAccountsFilterMemcmp message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterAccountsFilterMemcmp.verify|verify} messages.
         * @param message SubscribeRequestFilterAccountsFilterMemcmp message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeRequestFilterAccountsFilterMemcmp, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeRequestFilterAccountsFilterMemcmp message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeRequestFilterAccountsFilterMemcmp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeRequestFilterAccountsFilterMemcmp;

        /**
         * Decodes a SubscribeRequestFilterAccountsFilterMemcmp message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeRequestFilterAccountsFilterMemcmp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeRequestFilterAccountsFilterMemcmp;

        /**
         * Verifies a SubscribeRequestFilterAccountsFilterMemcmp message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeRequestFilterAccountsFilterMemcmp message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeRequestFilterAccountsFilterMemcmp
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeRequestFilterAccountsFilterMemcmp;

        /**
         * Creates a plain object from a SubscribeRequestFilterAccountsFilterMemcmp message. Also converts values to other types if specified.
         * @param message SubscribeRequestFilterAccountsFilterMemcmp
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeRequestFilterAccountsFilterMemcmp, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeRequestFilterAccountsFilterMemcmp to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeRequestFilterAccountsFilterMemcmp
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeRequestFilterAccountsFilterLamports. */
    interface ISubscribeRequestFilterAccountsFilterLamports {

        /** SubscribeRequestFilterAccountsFilterLamports eq */
        eq?: (number|Long|null);

        /** SubscribeRequestFilterAccountsFilterLamports ne */
        ne?: (number|Long|null);

        /** SubscribeRequestFilterAccountsFilterLamports lt */
        lt?: (number|Long|null);

        /** SubscribeRequestFilterAccountsFilterLamports gt */
        gt?: (number|Long|null);
    }

    /** Represents a SubscribeRequestFilterAccountsFilterLamports. */
    class SubscribeRequestFilterAccountsFilterLamports implements ISubscribeRequestFilterAccountsFilterLamports {

        /**
         * Constructs a new SubscribeRequestFilterAccountsFilterLamports.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeRequestFilterAccountsFilterLamports);

        /** SubscribeRequestFilterAccountsFilterLamports eq. */
        public eq?: (number|Long|null);

        /** SubscribeRequestFilterAccountsFilterLamports ne. */
        public ne?: (number|Long|null);

        /** SubscribeRequestFilterAccountsFilterLamports lt. */
        public lt?: (number|Long|null);

        /** SubscribeRequestFilterAccountsFilterLamports gt. */
        public gt?: (number|Long|null);

        /** SubscribeRequestFilterAccountsFilterLamports cmp. */
        public cmp?: ("eq"|"ne"|"lt"|"gt");

        /**
         * Creates a new SubscribeRequestFilterAccountsFilterLamports instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeRequestFilterAccountsFilterLamports instance
         */
        public static create(properties?: geyser.ISubscribeRequestFilterAccountsFilterLamports): geyser.SubscribeRequestFilterAccountsFilterLamports;

        /**
         * Encodes the specified SubscribeRequestFilterAccountsFilterLamports message. Does not implicitly {@link geyser.SubscribeRequestFilterAccountsFilterLamports.verify|verify} messages.
         * @param message SubscribeRequestFilterAccountsFilterLamports message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeRequestFilterAccountsFilterLamports, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeRequestFilterAccountsFilterLamports message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterAccountsFilterLamports.verify|verify} messages.
         * @param message SubscribeRequestFilterAccountsFilterLamports message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeRequestFilterAccountsFilterLamports, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeRequestFilterAccountsFilterLamports message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeRequestFilterAccountsFilterLamports
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeRequestFilterAccountsFilterLamports;

        /**
         * Decodes a SubscribeRequestFilterAccountsFilterLamports message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeRequestFilterAccountsFilterLamports
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeRequestFilterAccountsFilterLamports;

        /**
         * Verifies a SubscribeRequestFilterAccountsFilterLamports message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeRequestFilterAccountsFilterLamports message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeRequestFilterAccountsFilterLamports
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeRequestFilterAccountsFilterLamports;

        /**
         * Creates a plain object from a SubscribeRequestFilterAccountsFilterLamports message. Also converts values to other types if specified.
         * @param message SubscribeRequestFilterAccountsFilterLamports
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeRequestFilterAccountsFilterLamports, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeRequestFilterAccountsFilterLamports to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeRequestFilterAccountsFilterLamports
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeRequestFilterSlots. */
    interface ISubscribeRequestFilterSlots {

        /** SubscribeRequestFilterSlots filterByCommitment */
        filterByCommitment?: (boolean|null);

        /** SubscribeRequestFilterSlots interslotUpdates */
        interslotUpdates?: (boolean|null);
    }

    /** Represents a SubscribeRequestFilterSlots. */
    class SubscribeRequestFilterSlots implements ISubscribeRequestFilterSlots {

        /**
         * Constructs a new SubscribeRequestFilterSlots.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeRequestFilterSlots);

        /** SubscribeRequestFilterSlots filterByCommitment. */
        public filterByCommitment?: (boolean|null);

        /** SubscribeRequestFilterSlots interslotUpdates. */
        public interslotUpdates?: (boolean|null);

        /** SubscribeRequestFilterSlots _filterByCommitment. */
        public _filterByCommitment?: "filterByCommitment";

        /** SubscribeRequestFilterSlots _interslotUpdates. */
        public _interslotUpdates?: "interslotUpdates";

        /**
         * Creates a new SubscribeRequestFilterSlots instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeRequestFilterSlots instance
         */
        public static create(properties?: geyser.ISubscribeRequestFilterSlots): geyser.SubscribeRequestFilterSlots;

        /**
         * Encodes the specified SubscribeRequestFilterSlots message. Does not implicitly {@link geyser.SubscribeRequestFilterSlots.verify|verify} messages.
         * @param message SubscribeRequestFilterSlots message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeRequestFilterSlots, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeRequestFilterSlots message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterSlots.verify|verify} messages.
         * @param message SubscribeRequestFilterSlots message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeRequestFilterSlots, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeRequestFilterSlots message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeRequestFilterSlots
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeRequestFilterSlots;

        /**
         * Decodes a SubscribeRequestFilterSlots message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeRequestFilterSlots
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeRequestFilterSlots;

        /**
         * Verifies a SubscribeRequestFilterSlots message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeRequestFilterSlots message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeRequestFilterSlots
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeRequestFilterSlots;

        /**
         * Creates a plain object from a SubscribeRequestFilterSlots message. Also converts values to other types if specified.
         * @param message SubscribeRequestFilterSlots
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeRequestFilterSlots, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeRequestFilterSlots to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeRequestFilterSlots
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeRequestFilterTransactions. */
    interface ISubscribeRequestFilterTransactions {

        /** SubscribeRequestFilterTransactions vote */
        vote?: (boolean|null);

        /** SubscribeRequestFilterTransactions failed */
        failed?: (boolean|null);

        /** SubscribeRequestFilterTransactions signature */
        signature?: (string|null);

        /** SubscribeRequestFilterTransactions accountInclude */
        accountInclude?: (string[]|null);

        /** SubscribeRequestFilterTransactions accountExclude */
        accountExclude?: (string[]|null);

        /** SubscribeRequestFilterTransactions accountRequired */
        accountRequired?: (string[]|null);
    }

    /** Represents a SubscribeRequestFilterTransactions. */
    class SubscribeRequestFilterTransactions implements ISubscribeRequestFilterTransactions {

        /**
         * Constructs a new SubscribeRequestFilterTransactions.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeRequestFilterTransactions);

        /** SubscribeRequestFilterTransactions vote. */
        public vote?: (boolean|null);

        /** SubscribeRequestFilterTransactions failed. */
        public failed?: (boolean|null);

        /** SubscribeRequestFilterTransactions signature. */
        public signature?: (string|null);

        /** SubscribeRequestFilterTransactions accountInclude. */
        public accountInclude: string[];

        /** SubscribeRequestFilterTransactions accountExclude. */
        public accountExclude: string[];

        /** SubscribeRequestFilterTransactions accountRequired. */
        public accountRequired: string[];

        /** SubscribeRequestFilterTransactions _vote. */
        public _vote?: "vote";

        /** SubscribeRequestFilterTransactions _failed. */
        public _failed?: "failed";

        /** SubscribeRequestFilterTransactions _signature. */
        public _signature?: "signature";

        /**
         * Creates a new SubscribeRequestFilterTransactions instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeRequestFilterTransactions instance
         */
        public static create(properties?: geyser.ISubscribeRequestFilterTransactions): geyser.SubscribeRequestFilterTransactions;

        /**
         * Encodes the specified SubscribeRequestFilterTransactions message. Does not implicitly {@link geyser.SubscribeRequestFilterTransactions.verify|verify} messages.
         * @param message SubscribeRequestFilterTransactions message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeRequestFilterTransactions, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeRequestFilterTransactions message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterTransactions.verify|verify} messages.
         * @param message SubscribeRequestFilterTransactions message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeRequestFilterTransactions, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeRequestFilterTransactions message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeRequestFilterTransactions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeRequestFilterTransactions;

        /**
         * Decodes a SubscribeRequestFilterTransactions message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeRequestFilterTransactions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeRequestFilterTransactions;

        /**
         * Verifies a SubscribeRequestFilterTransactions message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeRequestFilterTransactions message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeRequestFilterTransactions
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeRequestFilterTransactions;

        /**
         * Creates a plain object from a SubscribeRequestFilterTransactions message. Also converts values to other types if specified.
         * @param message SubscribeRequestFilterTransactions
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeRequestFilterTransactions, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeRequestFilterTransactions to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeRequestFilterTransactions
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeRequestFilterBlocks. */
    interface ISubscribeRequestFilterBlocks {

        /** SubscribeRequestFilterBlocks accountInclude */
        accountInclude?: (string[]|null);

        /** SubscribeRequestFilterBlocks includeTransactions */
        includeTransactions?: (boolean|null);

        /** SubscribeRequestFilterBlocks includeAccounts */
        includeAccounts?: (boolean|null);

        /** SubscribeRequestFilterBlocks includeEntries */
        includeEntries?: (boolean|null);
    }

    /** Represents a SubscribeRequestFilterBlocks. */
    class SubscribeRequestFilterBlocks implements ISubscribeRequestFilterBlocks {

        /**
         * Constructs a new SubscribeRequestFilterBlocks.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeRequestFilterBlocks);

        /** SubscribeRequestFilterBlocks accountInclude. */
        public accountInclude: string[];

        /** SubscribeRequestFilterBlocks includeTransactions. */
        public includeTransactions?: (boolean|null);

        /** SubscribeRequestFilterBlocks includeAccounts. */
        public includeAccounts?: (boolean|null);

        /** SubscribeRequestFilterBlocks includeEntries. */
        public includeEntries?: (boolean|null);

        /** SubscribeRequestFilterBlocks _includeTransactions. */
        public _includeTransactions?: "includeTransactions";

        /** SubscribeRequestFilterBlocks _includeAccounts. */
        public _includeAccounts?: "includeAccounts";

        /** SubscribeRequestFilterBlocks _includeEntries. */
        public _includeEntries?: "includeEntries";

        /**
         * Creates a new SubscribeRequestFilterBlocks instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeRequestFilterBlocks instance
         */
        public static create(properties?: geyser.ISubscribeRequestFilterBlocks): geyser.SubscribeRequestFilterBlocks;

        /**
         * Encodes the specified SubscribeRequestFilterBlocks message. Does not implicitly {@link geyser.SubscribeRequestFilterBlocks.verify|verify} messages.
         * @param message SubscribeRequestFilterBlocks message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeRequestFilterBlocks, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeRequestFilterBlocks message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterBlocks.verify|verify} messages.
         * @param message SubscribeRequestFilterBlocks message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeRequestFilterBlocks, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeRequestFilterBlocks message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeRequestFilterBlocks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeRequestFilterBlocks;

        /**
         * Decodes a SubscribeRequestFilterBlocks message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeRequestFilterBlocks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeRequestFilterBlocks;

        /**
         * Verifies a SubscribeRequestFilterBlocks message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeRequestFilterBlocks message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeRequestFilterBlocks
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeRequestFilterBlocks;

        /**
         * Creates a plain object from a SubscribeRequestFilterBlocks message. Also converts values to other types if specified.
         * @param message SubscribeRequestFilterBlocks
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeRequestFilterBlocks, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeRequestFilterBlocks to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeRequestFilterBlocks
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeRequestFilterBlocksMeta. */
    interface ISubscribeRequestFilterBlocksMeta {
    }

    /** Represents a SubscribeRequestFilterBlocksMeta. */
    class SubscribeRequestFilterBlocksMeta implements ISubscribeRequestFilterBlocksMeta {

        /**
         * Constructs a new SubscribeRequestFilterBlocksMeta.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeRequestFilterBlocksMeta);

        /**
         * Creates a new SubscribeRequestFilterBlocksMeta instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeRequestFilterBlocksMeta instance
         */
        public static create(properties?: geyser.ISubscribeRequestFilterBlocksMeta): geyser.SubscribeRequestFilterBlocksMeta;

        /**
         * Encodes the specified SubscribeRequestFilterBlocksMeta message. Does not implicitly {@link geyser.SubscribeRequestFilterBlocksMeta.verify|verify} messages.
         * @param message SubscribeRequestFilterBlocksMeta message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeRequestFilterBlocksMeta, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeRequestFilterBlocksMeta message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterBlocksMeta.verify|verify} messages.
         * @param message SubscribeRequestFilterBlocksMeta message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeRequestFilterBlocksMeta, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeRequestFilterBlocksMeta message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeRequestFilterBlocksMeta
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeRequestFilterBlocksMeta;

        /**
         * Decodes a SubscribeRequestFilterBlocksMeta message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeRequestFilterBlocksMeta
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeRequestFilterBlocksMeta;

        /**
         * Verifies a SubscribeRequestFilterBlocksMeta message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeRequestFilterBlocksMeta message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeRequestFilterBlocksMeta
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeRequestFilterBlocksMeta;

        /**
         * Creates a plain object from a SubscribeRequestFilterBlocksMeta message. Also converts values to other types if specified.
         * @param message SubscribeRequestFilterBlocksMeta
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeRequestFilterBlocksMeta, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeRequestFilterBlocksMeta to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeRequestFilterBlocksMeta
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeRequestFilterEntry. */
    interface ISubscribeRequestFilterEntry {
    }

    /** Represents a SubscribeRequestFilterEntry. */
    class SubscribeRequestFilterEntry implements ISubscribeRequestFilterEntry {

        /**
         * Constructs a new SubscribeRequestFilterEntry.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeRequestFilterEntry);

        /**
         * Creates a new SubscribeRequestFilterEntry instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeRequestFilterEntry instance
         */
        public static create(properties?: geyser.ISubscribeRequestFilterEntry): geyser.SubscribeRequestFilterEntry;

        /**
         * Encodes the specified SubscribeRequestFilterEntry message. Does not implicitly {@link geyser.SubscribeRequestFilterEntry.verify|verify} messages.
         * @param message SubscribeRequestFilterEntry message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeRequestFilterEntry, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeRequestFilterEntry message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterEntry.verify|verify} messages.
         * @param message SubscribeRequestFilterEntry message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeRequestFilterEntry, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeRequestFilterEntry message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeRequestFilterEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeRequestFilterEntry;

        /**
         * Decodes a SubscribeRequestFilterEntry message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeRequestFilterEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeRequestFilterEntry;

        /**
         * Verifies a SubscribeRequestFilterEntry message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeRequestFilterEntry message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeRequestFilterEntry
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeRequestFilterEntry;

        /**
         * Creates a plain object from a SubscribeRequestFilterEntry message. Also converts values to other types if specified.
         * @param message SubscribeRequestFilterEntry
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeRequestFilterEntry, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeRequestFilterEntry to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeRequestFilterEntry
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeRequestAccountsDataSlice. */
    interface ISubscribeRequestAccountsDataSlice {

        /** SubscribeRequestAccountsDataSlice offset */
        offset?: (number|Long|null);

        /** SubscribeRequestAccountsDataSlice length */
        length?: (number|Long|null);
    }

    /** Represents a SubscribeRequestAccountsDataSlice. */
    class SubscribeRequestAccountsDataSlice implements ISubscribeRequestAccountsDataSlice {

        /**
         * Constructs a new SubscribeRequestAccountsDataSlice.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeRequestAccountsDataSlice);

        /** SubscribeRequestAccountsDataSlice offset. */
        public offset: (number|Long);

        /** SubscribeRequestAccountsDataSlice length. */
        public length: (number|Long);

        /**
         * Creates a new SubscribeRequestAccountsDataSlice instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeRequestAccountsDataSlice instance
         */
        public static create(properties?: geyser.ISubscribeRequestAccountsDataSlice): geyser.SubscribeRequestAccountsDataSlice;

        /**
         * Encodes the specified SubscribeRequestAccountsDataSlice message. Does not implicitly {@link geyser.SubscribeRequestAccountsDataSlice.verify|verify} messages.
         * @param message SubscribeRequestAccountsDataSlice message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeRequestAccountsDataSlice, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeRequestAccountsDataSlice message, length delimited. Does not implicitly {@link geyser.SubscribeRequestAccountsDataSlice.verify|verify} messages.
         * @param message SubscribeRequestAccountsDataSlice message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeRequestAccountsDataSlice, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeRequestAccountsDataSlice message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeRequestAccountsDataSlice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeRequestAccountsDataSlice;

        /**
         * Decodes a SubscribeRequestAccountsDataSlice message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeRequestAccountsDataSlice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeRequestAccountsDataSlice;

        /**
         * Verifies a SubscribeRequestAccountsDataSlice message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeRequestAccountsDataSlice message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeRequestAccountsDataSlice
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeRequestAccountsDataSlice;

        /**
         * Creates a plain object from a SubscribeRequestAccountsDataSlice message. Also converts values to other types if specified.
         * @param message SubscribeRequestAccountsDataSlice
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeRequestAccountsDataSlice, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeRequestAccountsDataSlice to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeRequestAccountsDataSlice
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeRequestPing. */
    interface ISubscribeRequestPing {

        /** SubscribeRequestPing id */
        id?: (number|null);
    }

    /** Represents a SubscribeRequestPing. */
    class SubscribeRequestPing implements ISubscribeRequestPing {

        /**
         * Constructs a new SubscribeRequestPing.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeRequestPing);

        /** SubscribeRequestPing id. */
        public id: number;

        /**
         * Creates a new SubscribeRequestPing instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeRequestPing instance
         */
        public static create(properties?: geyser.ISubscribeRequestPing): geyser.SubscribeRequestPing;

        /**
         * Encodes the specified SubscribeRequestPing message. Does not implicitly {@link geyser.SubscribeRequestPing.verify|verify} messages.
         * @param message SubscribeRequestPing message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeRequestPing, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeRequestPing message, length delimited. Does not implicitly {@link geyser.SubscribeRequestPing.verify|verify} messages.
         * @param message SubscribeRequestPing message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeRequestPing, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeRequestPing message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeRequestPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeRequestPing;

        /**
         * Decodes a SubscribeRequestPing message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeRequestPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeRequestPing;

        /**
         * Verifies a SubscribeRequestPing message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeRequestPing message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeRequestPing
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeRequestPing;

        /**
         * Creates a plain object from a SubscribeRequestPing message. Also converts values to other types if specified.
         * @param message SubscribeRequestPing
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeRequestPing, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeRequestPing to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeRequestPing
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeUpdate. */
    interface ISubscribeUpdate {

        /** SubscribeUpdate filters */
        filters?: (string[]|null);

        /** SubscribeUpdate account */
        account?: (geyser.ISubscribeUpdateAccount|null);

        /** SubscribeUpdate slot */
        slot?: (geyser.ISubscribeUpdateSlot|null);

        /** SubscribeUpdate transaction */
        transaction?: (geyser.ISubscribeUpdateTransaction|null);

        /** SubscribeUpdate transactionStatus */
        transactionStatus?: (geyser.ISubscribeUpdateTransactionStatus|null);

        /** SubscribeUpdate block */
        block?: (geyser.ISubscribeUpdateBlock|null);

        /** SubscribeUpdate ping */
        ping?: (geyser.ISubscribeUpdatePing|null);

        /** SubscribeUpdate pong */
        pong?: (geyser.ISubscribeUpdatePong|null);

        /** SubscribeUpdate blockMeta */
        blockMeta?: (geyser.ISubscribeUpdateBlockMeta|null);

        /** SubscribeUpdate entry */
        entry?: (geyser.ISubscribeUpdateEntry|null);

        /** SubscribeUpdate createdAt */
        createdAt?: (google.protobuf.ITimestamp|null);
    }

    /** Represents a SubscribeUpdate. */
    class SubscribeUpdate implements ISubscribeUpdate {

        /**
         * Constructs a new SubscribeUpdate.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeUpdate);

        /** SubscribeUpdate filters. */
        public filters: string[];

        /** SubscribeUpdate account. */
        public account?: (geyser.ISubscribeUpdateAccount|null);

        /** SubscribeUpdate slot. */
        public slot?: (geyser.ISubscribeUpdateSlot|null);

        /** SubscribeUpdate transaction. */
        public transaction?: (geyser.ISubscribeUpdateTransaction|null);

        /** SubscribeUpdate transactionStatus. */
        public transactionStatus?: (geyser.ISubscribeUpdateTransactionStatus|null);

        /** SubscribeUpdate block. */
        public block?: (geyser.ISubscribeUpdateBlock|null);

        /** SubscribeUpdate ping. */
        public ping?: (geyser.ISubscribeUpdatePing|null);

        /** SubscribeUpdate pong. */
        public pong?: (geyser.ISubscribeUpdatePong|null);

        /** SubscribeUpdate blockMeta. */
        public blockMeta?: (geyser.ISubscribeUpdateBlockMeta|null);

        /** SubscribeUpdate entry. */
        public entry?: (geyser.ISubscribeUpdateEntry|null);

        /** SubscribeUpdate createdAt. */
        public createdAt?: (google.protobuf.ITimestamp|null);

        /** SubscribeUpdate updateOneof. */
        public updateOneof?: ("account"|"slot"|"transaction"|"transactionStatus"|"block"|"ping"|"pong"|"blockMeta"|"entry");

        /**
         * Creates a new SubscribeUpdate instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeUpdate instance
         */
        public static create(properties?: geyser.ISubscribeUpdate): geyser.SubscribeUpdate;

        /**
         * Encodes the specified SubscribeUpdate message. Does not implicitly {@link geyser.SubscribeUpdate.verify|verify} messages.
         * @param message SubscribeUpdate message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeUpdate, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeUpdate message, length delimited. Does not implicitly {@link geyser.SubscribeUpdate.verify|verify} messages.
         * @param message SubscribeUpdate message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeUpdate, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeUpdate message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeUpdate;

        /**
         * Decodes a SubscribeUpdate message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeUpdate;

        /**
         * Verifies a SubscribeUpdate message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeUpdate message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeUpdate
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeUpdate;

        /**
         * Creates a plain object from a SubscribeUpdate message. Also converts values to other types if specified.
         * @param message SubscribeUpdate
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeUpdate, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeUpdate to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeUpdate
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeUpdateBatch. */
    interface ISubscribeUpdateBatch {

        /** SubscribeUpdateBatch updates */
        updates?: (geyser.ISubscribeUpdate[]|null);
    }

    /** Represents a SubscribeUpdateBatch. */
    class SubscribeUpdateBatch implements ISubscribeUpdateBatch {

        /**
         * Constructs a new SubscribeUpdateBatch.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeUpdateBatch);

        /** SubscribeUpdateBatch updates. */
        public updates: geyser.ISubscribeUpdate[];

        /**
         * Creates a new SubscribeUpdateBatch instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeUpdateBatch instance
         */
        public static create(properties?: geyser.ISubscribeUpdateBatch): geyser.SubscribeUpdateBatch;

        /**
         * Encodes the specified SubscribeUpdateBatch message. Does not implicitly {@link geyser.SubscribeUpdateBatch.verify|verify} messages.
         * @param message SubscribeUpdateBatch message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeUpdateBatch, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeUpdateBatch message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateBatch.verify|verify} messages.
         * @param message SubscribeUpdateBatch message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeUpdateBatch, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeUpdateBatch message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeUpdateBatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeUpdateBatch;

        /**
         * Decodes a SubscribeUpdateBatch message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeUpdateBatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeUpdateBatch;

        /**
         * Verifies a SubscribeUpdateBatch message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeUpdateBatch message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeUpdateBatch
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeUpdateBatch;

        /**
         * Creates a plain object from a SubscribeUpdateBatch message. Also converts values to other types if specified.
         * @param message SubscribeUpdateBatch
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeUpdateBatch, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeUpdateBatch to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeUpdateBatch
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeUpdateAccount. */
    interface ISubscribeUpdateAccount {

        /** SubscribeUpdateAccount account */
        account?: (geyser.ISubscribeUpdateAccountInfo|null);

        /** SubscribeUpdateAccount slot */
        slot?: (number|Long|null);

        /** SubscribeUpdateAccount isStartup */
        isStartup?: (boolean|null);
    }

    /** Represents a SubscribeUpdateAccount. */
    class SubscribeUpdateAccount implements ISubscribeUpdateAccount {

        /**
         * Constructs a new SubscribeUpdateAccount.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeUpdateAccount);

        /** SubscribeUpdateAccount account. */
        public account?: (geyser.ISubscribeUpdateAccountInfo|null);

        /** SubscribeUpdateAccount slot. */
        public slot: (number|Long);

        /** SubscribeUpdateAccount isStartup. */
        public isStartup: boolean;

        /**
         * Creates a new SubscribeUpdateAccount instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeUpdateAccount instance
         */
        public static create(properties?: geyser.ISubscribeUpdateAccount): geyser.SubscribeUpdateAccount;

        /**
         * Encodes the specified SubscribeUpdateAccount message. Does not implicitly {@link geyser.SubscribeUpdateAccount.verify|verify} messages.
         * @param message SubscribeUpdateAccount message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeUpdateAccount, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeUpdateAccount message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateAccount.verify|verify} messages.
         * @param message SubscribeUpdateAccount message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeUpdateAccount, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeUpdateAccount message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeUpdateAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeUpdateAccount;

        /**
         * Decodes a SubscribeUpdateAccount message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeUpdateAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeUpdateAccount;

        /**
         * Verifies a SubscribeUpdateAccount message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeUpdateAccount message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeUpdateAccount
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeUpdateAccount;

        /**
         * Creates a plain object from a SubscribeUpdateAccount message. Also converts values to other types if specified.
         * @param message SubscribeUpdateAccount
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeUpdateAccount, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeUpdateAccount to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeUpdateAccount
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeUpdateAccountInfo. */
    interface ISubscribeUpdateAccountInfo {

        /** SubscribeUpdateAccountInfo pubkey */
        pubkey?: (Uint8Array|null);

        /** SubscribeUpdateAccountInfo lamports */
        lamports?: (number|Long|null);

        /** SubscribeUpdateAccountInfo owner */
        owner?: (Uint8Array|null);

        /** SubscribeUpdateAccountInfo executable */
        executable?: (boolean|null);

        /** SubscribeUpdateAccountInfo rentEpoch */
        rentEpoch?: (number|Long|null);

        /** SubscribeUpdateAccountInfo data */
        data?: (Uint8Array|null);

        /** SubscribeUpdateAccountInfo writeVersion */
        writeVersion?: (number|Long|null);

        /** SubscribeUpdateAccountInfo txnSignature */
        txnSignature?: (Uint8Array|null);
    }

    /** Represents a SubscribeUpdateAccountInfo. */
    class SubscribeUpdateAccountInfo implements ISubscribeUpdateAccountInfo {

        /**
         * Constructs a new SubscribeUpdateAccountInfo.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeUpdateAccountInfo);

        /** SubscribeUpdateAccountInfo pubkey. */
        public pubkey: Uint8Array;

        /** SubscribeUpdateAccountInfo lamports. */
        public lamports: (number|Long);

        /** SubscribeUpdateAccountInfo owner. */
        public owner: Uint8Array;

        /** SubscribeUpdateAccountInfo executable. */
        public executable: boolean;

        /** SubscribeUpdateAccountInfo rentEpoch. */
        public rentEpoch: (number|Long);

        /** SubscribeUpdateAccountInfo data. */
        public data: Uint8Array;

        /** SubscribeUpdateAccountInfo writeVersion. */
        public writeVersion: (number|Long);

        /** SubscribeUpdateAccountInfo txnSignature. */
        public txnSignature?: (Uint8Array|null);

        /** SubscribeUpdateAccountInfo _txnSignature. */
        public _txnSignature?: "txnSignature";

        /**
         * Creates a new SubscribeUpdateAccountInfo instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeUpdateAccountInfo instance
         */
        public static create(properties?: geyser.ISubscribeUpdateAccountInfo): geyser.SubscribeUpdateAccountInfo;

        /**
         * Encodes the specified SubscribeUpdateAccountInfo message. Does not implicitly {@link geyser.SubscribeUpdateAccountInfo.verify|verify} messages.
         * @param message SubscribeUpdateAccountInfo message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeUpdateAccountInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeUpdateAccountInfo message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateAccountInfo.verify|verify} messages.
         * @param message SubscribeUpdateAccountInfo message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeUpdateAccountInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeUpdateAccountInfo message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeUpdateAccountInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeUpdateAccountInfo;

        /**
         * Decodes a SubscribeUpdateAccountInfo message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeUpdateAccountInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeUpdateAccountInfo;

        /**
         * Verifies a SubscribeUpdateAccountInfo message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeUpdateAccountInfo message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeUpdateAccountInfo
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeUpdateAccountInfo;

        /**
         * Creates a plain object from a SubscribeUpdateAccountInfo message. Also converts values to other types if specified.
         * @param message SubscribeUpdateAccountInfo
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeUpdateAccountInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeUpdateAccountInfo to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeUpdateAccountInfo
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeUpdateSlot. */
    interface ISubscribeUpdateSlot {

        /** SubscribeUpdateSlot slot */
        slot?: (number|Long|null);

        /** SubscribeUpdateSlot parent */
        parent?: (number|Long|null);

        /** SubscribeUpdateSlot status */
        status?: (geyser.SlotStatus|null);

        /** SubscribeUpdateSlot deadError */
        deadError?: (string|null);
    }

    /** Represents a SubscribeUpdateSlot. */
    class SubscribeUpdateSlot implements ISubscribeUpdateSlot {

        /**
         * Constructs a new SubscribeUpdateSlot.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeUpdateSlot);

        /** SubscribeUpdateSlot slot. */
        public slot: (number|Long);

        /** SubscribeUpdateSlot parent. */
        public parent?: (number|Long|null);

        /** SubscribeUpdateSlot status. */
        public status: geyser.SlotStatus;

        /** SubscribeUpdateSlot deadError. */
        public deadError?: (string|null);

        /** SubscribeUpdateSlot _parent. */
        public _parent?: "parent";

        /** SubscribeUpdateSlot _deadError. */
        public _deadError?: "deadError";

        /**
         * Creates a new SubscribeUpdateSlot instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeUpdateSlot instance
         */
        public static create(properties?: geyser.ISubscribeUpdateSlot): geyser.SubscribeUpdateSlot;

        /**
         * Encodes the specified SubscribeUpdateSlot message. Does not implicitly {@link geyser.SubscribeUpdateSlot.verify|verify} messages.
         * @param message SubscribeUpdateSlot message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeUpdateSlot, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeUpdateSlot message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateSlot.verify|verify} messages.
         * @param message SubscribeUpdateSlot message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeUpdateSlot, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeUpdateSlot message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeUpdateSlot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeUpdateSlot;

        /**
         * Decodes a SubscribeUpdateSlot message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeUpdateSlot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeUpdateSlot;

        /**
         * Verifies a SubscribeUpdateSlot message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeUpdateSlot message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeUpdateSlot
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeUpdateSlot;

        /**
         * Creates a plain object from a SubscribeUpdateSlot message. Also converts values to other types if specified.
         * @param message SubscribeUpdateSlot
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeUpdateSlot, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeUpdateSlot to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeUpdateSlot
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeUpdateTransaction. */
    interface ISubscribeUpdateTransaction {

        /** SubscribeUpdateTransaction transaction */
        transaction?: (geyser.ISubscribeUpdateTransactionInfo|null);

        /** SubscribeUpdateTransaction slot */
        slot?: (number|Long|null);
    }

    /** Represents a SubscribeUpdateTransaction. */
    class SubscribeUpdateTransaction implements ISubscribeUpdateTransaction {

        /**
         * Constructs a new SubscribeUpdateTransaction.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeUpdateTransaction);

        /** SubscribeUpdateTransaction transaction. */
        public transaction?: (geyser.ISubscribeUpdateTransactionInfo|null);

        /** SubscribeUpdateTransaction slot. */
        public slot: (number|Long);

        /**
         * Creates a new SubscribeUpdateTransaction instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeUpdateTransaction instance
         */
        public static create(properties?: geyser.ISubscribeUpdateTransaction): geyser.SubscribeUpdateTransaction;

        /**
         * Encodes the specified SubscribeUpdateTransaction message. Does not implicitly {@link geyser.SubscribeUpdateTransaction.verify|verify} messages.
         * @param message SubscribeUpdateTransaction message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeUpdateTransaction, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeUpdateTransaction message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateTransaction.verify|verify} messages.
         * @param message SubscribeUpdateTransaction message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeUpdateTransaction, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeUpdateTransaction message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeUpdateTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeUpdateTransaction;

        /**
         * Decodes a SubscribeUpdateTransaction message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeUpdateTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeUpdateTransaction;

        /**
         * Verifies a SubscribeUpdateTransaction message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeUpdateTransaction message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeUpdateTransaction
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeUpdateTransaction;

        /**
         * Creates a plain object from a SubscribeUpdateTransaction message. Also converts values to other types if specified.
         * @param message SubscribeUpdateTransaction
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeUpdateTransaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeUpdateTransaction to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeUpdateTransaction
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeUpdateTransactionInfo. */
    interface ISubscribeUpdateTransactionInfo {

        /** SubscribeUpdateTransactionInfo signature */
        signature?: (Uint8Array|null);

        /** SubscribeUpdateTransactionInfo isVote */
        isVote?: (boolean|null);

        /** SubscribeUpdateTransactionInfo transaction */
        transaction?: (solana.storage.ConfirmedBlock.ITransaction|null);

        /** SubscribeUpdateTransactionInfo meta */
        meta?: (solana.storage.ConfirmedBlock.ITransactionStatusMeta|null);

        /** SubscribeUpdateTransactionInfo index */
        index?: (number|Long|null);
    }

    /** Represents a SubscribeUpdateTransactionInfo. */
    class SubscribeUpdateTransactionInfo implements ISubscribeUpdateTransactionInfo {

        /**
         * Constructs a new SubscribeUpdateTransactionInfo.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeUpdateTransactionInfo);

        /** SubscribeUpdateTransactionInfo signature. */
        public signature: Uint8Array;

        /** SubscribeUpdateTransactionInfo isVote. */
        public isVote: boolean;

        /** SubscribeUpdateTransactionInfo transaction. */
        public transaction?: (solana.storage.ConfirmedBlock.ITransaction|null);

        /** SubscribeUpdateTransactionInfo meta. */
        public meta?: (solana.storage.ConfirmedBlock.ITransactionStatusMeta|null);

        /** SubscribeUpdateTransactionInfo index. */
        public index: (number|Long);

        /**
         * Creates a new SubscribeUpdateTransactionInfo instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeUpdateTransactionInfo instance
         */
        public static create(properties?: geyser.ISubscribeUpdateTransactionInfo): geyser.SubscribeUpdateTransactionInfo;

        /**
         * Encodes the specified SubscribeUpdateTransactionInfo message. Does not implicitly {@link geyser.SubscribeUpdateTransactionInfo.verify|verify} messages.
         * @param message SubscribeUpdateTransactionInfo message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeUpdateTransactionInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeUpdateTransactionInfo message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateTransactionInfo.verify|verify} messages.
         * @param message SubscribeUpdateTransactionInfo message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeUpdateTransactionInfo, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeUpdateTransactionInfo message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeUpdateTransactionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeUpdateTransactionInfo;

        /**
         * Decodes a SubscribeUpdateTransactionInfo message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeUpdateTransactionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeUpdateTransactionInfo;

        /**
         * Verifies a SubscribeUpdateTransactionInfo message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeUpdateTransactionInfo message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeUpdateTransactionInfo
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeUpdateTransactionInfo;

        /**
         * Creates a plain object from a SubscribeUpdateTransactionInfo message. Also converts values to other types if specified.
         * @param message SubscribeUpdateTransactionInfo
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeUpdateTransactionInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeUpdateTransactionInfo to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeUpdateTransactionInfo
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeUpdateTransactionStatus. */
    interface ISubscribeUpdateTransactionStatus {

        /** SubscribeUpdateTransactionStatus slot */
        slot?: (number|Long|null);

        /** SubscribeUpdateTransactionStatus signature */
        signature?: (Uint8Array|null);

        /** SubscribeUpdateTransactionStatus isVote */
        isVote?: (boolean|null);

        /** SubscribeUpdateTransactionStatus index */
        index?: (number|Long|null);

        /** SubscribeUpdateTransactionStatus err */
        err?: (solana.storage.ConfirmedBlock.ITransactionError|null);
    }

    /** Represents a SubscribeUpdateTransactionStatus. */
    class SubscribeUpdateTransactionStatus implements ISubscribeUpdateTransactionStatus {

        /**
         * Constructs a new SubscribeUpdateTransactionStatus.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeUpdateTransactionStatus);

        /** SubscribeUpdateTransactionStatus slot. */
        public slot: (number|Long);

        /** SubscribeUpdateTransactionStatus signature. */
        public signature: Uint8Array;

        /** SubscribeUpdateTransactionStatus isVote. */
        public isVote: boolean;

        /** SubscribeUpdateTransactionStatus index. */
        public index: (number|Long);

        /** SubscribeUpdateTransactionStatus err. */
        public err?: (solana.storage.ConfirmedBlock.ITransactionError|null);

        /**
         * Creates a new SubscribeUpdateTransactionStatus instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeUpdateTransactionStatus instance
         */
        public static create(properties?: geyser.ISubscribeUpdateTransactionStatus): geyser.SubscribeUpdateTransactionStatus;

        /**
         * Encodes the specified SubscribeUpdateTransactionStatus message. Does not implicitly {@link geyser.SubscribeUpdateTransactionStatus.verify|verify} messages.
         * @param message SubscribeUpdateTransactionStatus message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeUpdateTransactionStatus, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeUpdateTransactionStatus message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateTransactionStatus.verify|verify} messages.
         * @param message SubscribeUpdateTransactionStatus message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeUpdateTransactionStatus, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeUpdateTransactionStatus message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeUpdateTransactionStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeUpdateTransactionStatus;

        /**
         * Decodes a SubscribeUpdateTransactionStatus message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeUpdateTransactionStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeUpdateTransactionStatus;

        /**
         * Verifies a SubscribeUpdateTransactionStatus message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeUpdateTransactionStatus message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeUpdateTransactionStatus
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeUpdateTransactionStatus;

        /**
         * Creates a plain object from a SubscribeUpdateTransactionStatus message. Also converts values to other types if specified.
         * @param message SubscribeUpdateTransactionStatus
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeUpdateTransactionStatus, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeUpdateTransactionStatus to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeUpdateTransactionStatus
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeUpdateBlock. */
    interface ISubscribeUpdateBlock {

        /** SubscribeUpdateBlock slot */
        slot?: (number|Long|null);

        /** SubscribeUpdateBlock blockhash */
        blockhash?: (string|null);

        /** SubscribeUpdateBlock rewards */
        rewards?: (solana.storage.ConfirmedBlock.IRewards|null);

        /** SubscribeUpdateBlock blockTime */
        blockTime?: (solana.storage.ConfirmedBlock.IUnixTimestamp|null);

        /** SubscribeUpdateBlock blockHeight */
        blockHeight?: (solana.storage.ConfirmedBlock.IBlockHeight|null);

        /** SubscribeUpdateBlock parentSlot */
        parentSlot?: (number|Long|null);

        /** SubscribeUpdateBlock parentBlockhash */
        parentBlockhash?: (string|null);

        /** SubscribeUpdateBlock executedTransactionCount */
        executedTransactionCount?: (number|Long|null);

        /** SubscribeUpdateBlock transactions */
        transactions?: (geyser.ISubscribeUpdateTransactionInfo[]|null);

        /** SubscribeUpdateBlock updatedAccountCount */
        updatedAccountCount?: (number|Long|null);

        /** SubscribeUpdateBlock accounts */
        accounts?: (geyser.ISubscribeUpdateAccountInfo[]|null);

        /** SubscribeUpdateBlock entriesCount */
        entriesCount?: (number|Long|null);

        /** SubscribeUpdateBlock entries */
        entries?: (geyser.ISubscribeUpdateEntry[]|null);
    }

    /** Represents a SubscribeUpdateBlock. */
    class SubscribeUpdateBlock implements ISubscribeUpdateBlock {

        /**
         * Constructs a new SubscribeUpdateBlock.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeUpdateBlock);

        /** SubscribeUpdateBlock slot. */
        public slot: (number|Long);

        /** SubscribeUpdateBlock blockhash. */
        public blockhash: string;

        /** SubscribeUpdateBlock rewards. */
        public rewards?: (solana.storage.ConfirmedBlock.IRewards|null);

        /** SubscribeUpdateBlock blockTime. */
        public blockTime?: (solana.storage.ConfirmedBlock.IUnixTimestamp|null);

        /** SubscribeUpdateBlock blockHeight. */
        public blockHeight?: (solana.storage.ConfirmedBlock.IBlockHeight|null);

        /** SubscribeUpdateBlock parentSlot. */
        public parentSlot: (number|Long);

        /** SubscribeUpdateBlock parentBlockhash. */
        public parentBlockhash: string;

        /** SubscribeUpdateBlock executedTransactionCount. */
        public executedTransactionCount: (number|Long);

        /** SubscribeUpdateBlock transactions. */
        public transactions: geyser.ISubscribeUpdateTransactionInfo[];

        /** SubscribeUpdateBlock updatedAccountCount. */
        public updatedAccountCount: (number|Long);

        /** SubscribeUpdateBlock accounts. */
        public accounts: geyser.ISubscribeUpdateAccountInfo[];

        /** SubscribeUpdateBlock entriesCount. */
        public entriesCount: (number|Long);

        /** SubscribeUpdateBlock entries. */
        public entries: geyser.ISubscribeUpdateEntry[];

        /**
         * Creates a new SubscribeUpdateBlock instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeUpdateBlock instance
         */
        public static create(properties?: geyser.ISubscribeUpdateBlock): geyser.SubscribeUpdateBlock;

        /**
         * Encodes the specified SubscribeUpdateBlock message. Does not implicitly {@link geyser.SubscribeUpdateBlock.verify|verify} messages.
         * @param message SubscribeUpdateBlock message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeUpdateBlock, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeUpdateBlock message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateBlock.verify|verify} messages.
         * @param message SubscribeUpdateBlock message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeUpdateBlock, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeUpdateBlock message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeUpdateBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeUpdateBlock;

        /**
         * Decodes a SubscribeUpdateBlock message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeUpdateBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeUpdateBlock;

        /**
         * Verifies a SubscribeUpdateBlock message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeUpdateBlock message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeUpdateBlock
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeUpdateBlock;

        /**
         * Creates a plain object from a SubscribeUpdateBlock message. Also converts values to other types if specified.
         * @param message SubscribeUpdateBlock
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeUpdateBlock, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeUpdateBlock to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeUpdateBlock
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeUpdateBlockMeta. */
    interface ISubscribeUpdateBlockMeta {

        /** SubscribeUpdateBlockMeta slot */
        slot?: (number|Long|null);

        /** SubscribeUpdateBlockMeta blockhash */
        blockhash?: (string|null);

        /** SubscribeUpdateBlockMeta rewards */
        rewards?: (solana.storage.ConfirmedBlock.IRewards|null);

        /** SubscribeUpdateBlockMeta blockTime */
        blockTime?: (solana.storage.ConfirmedBlock.IUnixTimestamp|null);

        /** SubscribeUpdateBlockMeta blockHeight */
        blockHeight?: (solana.storage.ConfirmedBlock.IBlockHeight|null);

        /** SubscribeUpdateBlockMeta parentSlot */
        parentSlot?: (number|Long|null);

        /** SubscribeUpdateBlockMeta parentBlockhash */
        parentBlockhash?: (string|null);

        /** SubscribeUpdateBlockMeta executedTransactionCount */
        executedTransactionCount?: (number|Long|null);

        /** SubscribeUpdateBlockMeta entriesCount */
        entriesCount?: (number|Long|null);
    }

    /** Represents a SubscribeUpdateBlockMeta. */
    class SubscribeUpdateBlockMeta implements ISubscribeUpdateBlockMeta {

        /**
         * Constructs a new SubscribeUpdateBlockMeta.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeUpdateBlockMeta);

        /** SubscribeUpdateBlockMeta slot. */
        public slot: (number|Long);

        /** SubscribeUpdateBlockMeta blockhash. */
        public blockhash: string;

        /** SubscribeUpdateBlockMeta rewards. */
        public rewards?: (solana.storage.ConfirmedBlock.IRewards|null);

        /** SubscribeUpdateBlockMeta blockTime. */
        public blockTime?: (solana.storage.ConfirmedBlock.IUnixTimestamp|null);

        /** SubscribeUpdateBlockMeta blockHeight. */
        public blockHeight?: (solana.storage.ConfirmedBlock.IBlockHeight|null);

        /** SubscribeUpdateBlockMeta parentSlot. */
        public parentSlot: (number|Long);

        /** SubscribeUpdateBlockMeta parentBlockhash. */
        public parentBlockhash: string;

        /** SubscribeUpdateBlockMeta executedTransactionCount. */
        public executedTransactionCount: (number|Long);

        /** SubscribeUpdateBlockMeta entriesCount. */
        public entriesCount: (number|Long);

        /**
         * Creates a new SubscribeUpdateBlockMeta instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeUpdateBlockMeta instance
         */
        public static create(properties?: geyser.ISubscribeUpdateBlockMeta): geyser.SubscribeUpdateBlockMeta;

        /**
         * Encodes the specified SubscribeUpdateBlockMeta message. Does not implicitly {@link geyser.SubscribeUpdateBlockMeta.verify|verify} messages.
         * @param message SubscribeUpdateBlockMeta message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeUpdateBlockMeta, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeUpdateBlockMeta message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateBlockMeta.verify|verify} messages.
         * @param message SubscribeUpdateBlockMeta message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeUpdateBlockMeta, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeUpdateBlockMeta message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeUpdateBlockMeta
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeUpdateBlockMeta;

        /**
         * Decodes a SubscribeUpdateBlockMeta message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeUpdateBlockMeta
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeUpdateBlockMeta;

        /**
         * Verifies a SubscribeUpdateBlockMeta message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeUpdateBlockMeta message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeUpdateBlockMeta
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeUpdateBlockMeta;

        /**
         * Creates a plain object from a SubscribeUpdateBlockMeta message. Also converts values to other types if specified.
         * @param message SubscribeUpdateBlockMeta
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeUpdateBlockMeta, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeUpdateBlockMeta to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeUpdateBlockMeta
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeUpdateEntry. */
    interface ISubscribeUpdateEntry {

        /** SubscribeUpdateEntry slot */
        slot?: (number|Long|null);

        /** SubscribeUpdateEntry index */
        index?: (number|Long|null);

        /** SubscribeUpdateEntry numHashes */
        numHashes?: (number|Long|null);

        /** SubscribeUpdateEntry hash */
        hash?: (Uint8Array|null);

        /** SubscribeUpdateEntry executedTransactionCount */
        executedTransactionCount?: (number|Long|null);

        /** SubscribeUpdateEntry startingTransactionIndex */
        startingTransactionIndex?: (number|Long|null);
    }

    /** Represents a SubscribeUpdateEntry. */
    class SubscribeUpdateEntry implements ISubscribeUpdateEntry {

        /**
         * Constructs a new SubscribeUpdateEntry.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeUpdateEntry);

        /** SubscribeUpdateEntry slot. */
        public slot: (number|Long);

        /** SubscribeUpdateEntry index. */
        public index: (number|Long);

        /** SubscribeUpdateEntry numHashes. */
        public numHashes: (number|Long);

        /** SubscribeUpdateEntry hash. */
        public hash: Uint8Array;

        /** SubscribeUpdateEntry executedTransactionCount. */
        public executedTransactionCount: (number|Long);

        /** SubscribeUpdateEntry startingTransactionIndex. */
        public startingTransactionIndex: (number|Long);

        /**
         * Creates a new SubscribeUpdateEntry instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeUpdateEntry instance
         */
        public static create(properties?: geyser.ISubscribeUpdateEntry): geyser.SubscribeUpdateEntry;

        /**
         * Encodes the specified SubscribeUpdateEntry message. Does not implicitly {@link geyser.SubscribeUpdateEntry.verify|verify} messages.
         * @param message SubscribeUpdateEntry message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeUpdateEntry, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeUpdateEntry message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateEntry.verify|verify} messages.
         * @param message SubscribeUpdateEntry message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeUpdateEntry, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeUpdateEntry message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeUpdateEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeUpdateEntry;

        /**
         * Decodes a SubscribeUpdateEntry message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeUpdateEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeUpdateEntry;

        /**
         * Verifies a SubscribeUpdateEntry message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeUpdateEntry message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeUpdateEntry
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeUpdateEntry;

        /**
         * Creates a plain object from a SubscribeUpdateEntry message. Also converts values to other types if specified.
         * @param message SubscribeUpdateEntry
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeUpdateEntry, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeUpdateEntry to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeUpdateEntry
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeUpdatePing. */
    interface ISubscribeUpdatePing {
    }

    /** Represents a SubscribeUpdatePing. */
    class SubscribeUpdatePing implements ISubscribeUpdatePing {

        /**
         * Constructs a new SubscribeUpdatePing.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeUpdatePing);

        /**
         * Creates a new SubscribeUpdatePing instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeUpdatePing instance
         */
        public static create(properties?: geyser.ISubscribeUpdatePing): geyser.SubscribeUpdatePing;

        /**
         * Encodes the specified SubscribeUpdatePing message. Does not implicitly {@link geyser.SubscribeUpdatePing.verify|verify} messages.
         * @param message SubscribeUpdatePing message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeUpdatePing, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeUpdatePing message, length delimited. Does not implicitly {@link geyser.SubscribeUpdatePing.verify|verify} messages.
         * @param message SubscribeUpdatePing message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeUpdatePing, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeUpdatePing message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeUpdatePing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeUpdatePing;

        /**
         * Decodes a SubscribeUpdatePing message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeUpdatePing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeUpdatePing;

        /**
         * Verifies a SubscribeUpdatePing message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeUpdatePing message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeUpdatePing
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeUpdatePing;

        /**
         * Creates a plain object from a SubscribeUpdatePing message. Also converts values to other types if specified.
         * @param message SubscribeUpdatePing
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeUpdatePing, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeUpdatePing to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeUpdatePing
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeUpdatePong. */
    interface ISubscribeUpdatePong {

        /** SubscribeUpdatePong id */
        id?: (number|null);
    }

    /** Represents a SubscribeUpdatePong. */
    class SubscribeUpdatePong implements ISubscribeUpdatePong {

        /**
         * Constructs a new SubscribeUpdatePong.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeUpdatePong);

        /** SubscribeUpdatePong id. */
        public id: number;

        /**
         * Creates a new SubscribeUpdatePong instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeUpdatePong instance
         */
        public static create(properties?: geyser.ISubscribeUpdatePong): geyser.SubscribeUpdatePong;

        /**
         * Encodes the specified SubscribeUpdatePong message. Does not implicitly {@link geyser.SubscribeUpdatePong.verify|verify} messages.
         * @param message SubscribeUpdatePong message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeUpdatePong, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeUpdatePong message, length delimited. Does not implicitly {@link geyser.SubscribeUpdatePong.verify|verify} messages.
         * @param message SubscribeUpdatePong message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeUpdatePong, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeUpdatePong message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeUpdatePong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeUpdatePong;

        /**
         * Decodes a SubscribeUpdatePong message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeUpdatePong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeUpdatePong;

        /**
         * Verifies a SubscribeUpdatePong message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeUpdatePong message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeUpdatePong
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeUpdatePong;

        /**
         * Creates a plain object from a SubscribeUpdatePong message. Also converts values to other types if specified.
         * @param message SubscribeUpdatePong
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeUpdatePong, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeUpdatePong to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeUpdatePong
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeReplayInfoRequest. */
    interface ISubscribeReplayInfoRequest {
    }

    /** Represents a SubscribeReplayInfoRequest. */
    class SubscribeReplayInfoRequest implements ISubscribeReplayInfoRequest {

        /**
         * Constructs a new SubscribeReplayInfoRequest.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeReplayInfoRequest);

        /**
         * Creates a new SubscribeReplayInfoRequest instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeReplayInfoRequest instance
         */
        public static create(properties?: geyser.ISubscribeReplayInfoRequest): geyser.SubscribeReplayInfoRequest;

        /**
         * Encodes the specified SubscribeReplayInfoRequest message. Does not implicitly {@link geyser.SubscribeReplayInfoRequest.verify|verify} messages.
         * @param message SubscribeReplayInfoRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeReplayInfoRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeReplayInfoRequest message, length delimited. Does not implicitly {@link geyser.SubscribeReplayInfoRequest.verify|verify} messages.
         * @param message SubscribeReplayInfoRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeReplayInfoRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeReplayInfoRequest message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeReplayInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeReplayInfoRequest;

        /**
         * Decodes a SubscribeReplayInfoRequest message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeReplayInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeReplayInfoRequest;

        /**
         * Verifies a SubscribeReplayInfoRequest message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeReplayInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeReplayInfoRequest
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeReplayInfoRequest;

        /**
         * Creates a plain object from a SubscribeReplayInfoRequest message. Also converts values to other types if specified.
         * @param message SubscribeReplayInfoRequest
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeReplayInfoRequest, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeReplayInfoRequest to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeReplayInfoRequest
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a SubscribeReplayInfoResponse. */
    interface ISubscribeReplayInfoResponse {

        /** SubscribeReplayInfoResponse firstAvailable */
        firstAvailable?: (number|Long|null);
    }

    /** Represents a SubscribeReplayInfoResponse. */
    class SubscribeReplayInfoResponse implements ISubscribeReplayInfoResponse {

        /**
         * Constructs a new SubscribeReplayInfoResponse.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.ISubscribeReplayInfoResponse);

        /** SubscribeReplayInfoResponse firstAvailable. */
        public firstAvailable?: (number|Long|null);

        /** SubscribeReplayInfoResponse _firstAvailable. */
        public _firstAvailable?: "firstAvailable";

        /**
         * Creates a new SubscribeReplayInfoResponse instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SubscribeReplayInfoResponse instance
         */
        public static create(properties?: geyser.ISubscribeReplayInfoResponse): geyser.SubscribeReplayInfoResponse;

        /**
         * Encodes the specified SubscribeReplayInfoResponse message. Does not implicitly {@link geyser.SubscribeReplayInfoResponse.verify|verify} messages.
         * @param message SubscribeReplayInfoResponse message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.ISubscribeReplayInfoResponse, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SubscribeReplayInfoResponse message, length delimited. Does not implicitly {@link geyser.SubscribeReplayInfoResponse.verify|verify} messages.
         * @param message SubscribeReplayInfoResponse message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.ISubscribeReplayInfoResponse, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SubscribeReplayInfoResponse message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SubscribeReplayInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.SubscribeReplayInfoResponse;

        /**
         * Decodes a SubscribeReplayInfoResponse message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SubscribeReplayInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.SubscribeReplayInfoResponse;

        /**
         * Verifies a SubscribeReplayInfoResponse message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SubscribeReplayInfoResponse message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SubscribeReplayInfoResponse
         */
        public static fromObject(object: { [k: string]: any }): geyser.SubscribeReplayInfoResponse;

        /**
         * Creates a plain object from a SubscribeReplayInfoResponse message. Also converts values to other types if specified.
         * @param message SubscribeReplayInfoResponse
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.SubscribeReplayInfoResponse, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SubscribeReplayInfoResponse to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for SubscribeReplayInfoResponse
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a PingRequest. */
    interface IPingRequest {

        /** PingRequest count */
        count?: (number|null);
    }

    /** Represents a PingRequest. */
    class PingRequest implements IPingRequest {

        /**
         * Constructs a new PingRequest.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.IPingRequest);

        /** PingRequest count. */
        public count: number;

        /**
         * Creates a new PingRequest instance using the specified properties.
         * @param [properties] Properties to set
         * @returns PingRequest instance
         */
        public static create(properties?: geyser.IPingRequest): geyser.PingRequest;

        /**
         * Encodes the specified PingRequest message. Does not implicitly {@link geyser.PingRequest.verify|verify} messages.
         * @param message PingRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.IPingRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified PingRequest message, length delimited. Does not implicitly {@link geyser.PingRequest.verify|verify} messages.
         * @param message PingRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.IPingRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a PingRequest message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns PingRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.PingRequest;

        /**
         * Decodes a PingRequest message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns PingRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.PingRequest;

        /**
         * Verifies a PingRequest message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a PingRequest message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns PingRequest
         */
        public static fromObject(object: { [k: string]: any }): geyser.PingRequest;

        /**
         * Creates a plain object from a PingRequest message. Also converts values to other types if specified.
         * @param message PingRequest
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.PingRequest, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this PingRequest to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for PingRequest
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a PongResponse. */
    interface IPongResponse {

        /** PongResponse count */
        count?: (number|null);
    }

    /** Represents a PongResponse. */
    class PongResponse implements IPongResponse {

        /**
         * Constructs a new PongResponse.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.IPongResponse);

        /** PongResponse count. */
        public count: number;

        /**
         * Creates a new PongResponse instance using the specified properties.
         * @param [properties] Properties to set
         * @returns PongResponse instance
         */
        public static create(properties?: geyser.IPongResponse): geyser.PongResponse;

        /**
         * Encodes the specified PongResponse message. Does not implicitly {@link geyser.PongResponse.verify|verify} messages.
         * @param message PongResponse message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.IPongResponse, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified PongResponse message, length delimited. Does not implicitly {@link geyser.PongResponse.verify|verify} messages.
         * @param message PongResponse message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.IPongResponse, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a PongResponse message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns PongResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.PongResponse;

        /**
         * Decodes a PongResponse message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns PongResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.PongResponse;

        /**
         * Verifies a PongResponse message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a PongResponse message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns PongResponse
         */
        public static fromObject(object: { [k: string]: any }): geyser.PongResponse;

        /**
         * Creates a plain object from a PongResponse message. Also converts values to other types if specified.
         * @param message PongResponse
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.PongResponse, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this PongResponse to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for PongResponse
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a GetLatestBlockhashRequest. */
    interface IGetLatestBlockhashRequest {

        /** GetLatestBlockhashRequest commitment */
        commitment?: (geyser.CommitmentLevel|null);
    }

    /** Represents a GetLatestBlockhashRequest. */
    class GetLatestBlockhashRequest implements IGetLatestBlockhashRequest {

        /**
         * Constructs a new GetLatestBlockhashRequest.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.IGetLatestBlockhashRequest);

        /** GetLatestBlockhashRequest commitment. */
        public commitment?: (geyser.CommitmentLevel|null);

        /** GetLatestBlockhashRequest _commitment. */
        public _commitment?: "commitment";

        /**
         * Creates a new GetLatestBlockhashRequest instance using the specified properties.
         * @param [properties] Properties to set
         * @returns GetLatestBlockhashRequest instance
         */
        public static create(properties?: geyser.IGetLatestBlockhashRequest): geyser.GetLatestBlockhashRequest;

        /**
         * Encodes the specified GetLatestBlockhashRequest message. Does not implicitly {@link geyser.GetLatestBlockhashRequest.verify|verify} messages.
         * @param message GetLatestBlockhashRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.IGetLatestBlockhashRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified GetLatestBlockhashRequest message, length delimited. Does not implicitly {@link geyser.GetLatestBlockhashRequest.verify|verify} messages.
         * @param message GetLatestBlockhashRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.IGetLatestBlockhashRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a GetLatestBlockhashRequest message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns GetLatestBlockhashRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.GetLatestBlockhashRequest;

        /**
         * Decodes a GetLatestBlockhashRequest message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns GetLatestBlockhashRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.GetLatestBlockhashRequest;

        /**
         * Verifies a GetLatestBlockhashRequest message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a GetLatestBlockhashRequest message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns GetLatestBlockhashRequest
         */
        public static fromObject(object: { [k: string]: any }): geyser.GetLatestBlockhashRequest;

        /**
         * Creates a plain object from a GetLatestBlockhashRequest message. Also converts values to other types if specified.
         * @param message GetLatestBlockhashRequest
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.GetLatestBlockhashRequest, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this GetLatestBlockhashRequest to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for GetLatestBlockhashRequest
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a GetLatestBlockhashResponse. */
    interface IGetLatestBlockhashResponse {

        /** GetLatestBlockhashResponse slot */
        slot?: (number|Long|null);

        /** GetLatestBlockhashResponse blockhash */
        blockhash?: (string|null);

        /** GetLatestBlockhashResponse lastValidBlockHeight */
        lastValidBlockHeight?: (number|Long|null);
    }

    /** Represents a GetLatestBlockhashResponse. */
    class GetLatestBlockhashResponse implements IGetLatestBlockhashResponse {

        /**
         * Constructs a new GetLatestBlockhashResponse.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.IGetLatestBlockhashResponse);

        /** GetLatestBlockhashResponse slot. */
        public slot: (number|Long);

        /** GetLatestBlockhashResponse blockhash. */
        public blockhash: string;

        /** GetLatestBlockhashResponse lastValidBlockHeight. */
        public lastValidBlockHeight: (number|Long);

        /**
         * Creates a new GetLatestBlockhashResponse instance using the specified properties.
         * @param [properties] Properties to set
         * @returns GetLatestBlockhashResponse instance
         */
        public static create(properties?: geyser.IGetLatestBlockhashResponse): geyser.GetLatestBlockhashResponse;

        /**
         * Encodes the specified GetLatestBlockhashResponse message. Does not implicitly {@link geyser.GetLatestBlockhashResponse.verify|verify} messages.
         * @param message GetLatestBlockhashResponse message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.IGetLatestBlockhashResponse, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified GetLatestBlockhashResponse message, length delimited. Does not implicitly {@link geyser.GetLatestBlockhashResponse.verify|verify} messages.
         * @param message GetLatestBlockhashResponse message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.IGetLatestBlockhashResponse, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a GetLatestBlockhashResponse message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns GetLatestBlockhashResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.GetLatestBlockhashResponse;

        /**
         * Decodes a GetLatestBlockhashResponse message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns GetLatestBlockhashResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.GetLatestBlockhashResponse;

        /**
         * Verifies a GetLatestBlockhashResponse message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a GetLatestBlockhashResponse message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns GetLatestBlockhashResponse
         */
        public static fromObject(object: { [k: string]: any }): geyser.GetLatestBlockhashResponse;

        /**
         * Creates a plain object from a GetLatestBlockhashResponse message. Also converts values to other types if specified.
         * @param message GetLatestBlockhashResponse
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.GetLatestBlockhashResponse, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this GetLatestBlockhashResponse to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for GetLatestBlockhashResponse
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a GetBlockHeightRequest. */
    interface IGetBlockHeightRequest {

        /** GetBlockHeightRequest commitment */
        commitment?: (geyser.CommitmentLevel|null);
    }

    /** Represents a GetBlockHeightRequest. */
    class GetBlockHeightRequest implements IGetBlockHeightRequest {

        /**
         * Constructs a new GetBlockHeightRequest.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.IGetBlockHeightRequest);

        /** GetBlockHeightRequest commitment. */
        public commitment?: (geyser.CommitmentLevel|null);

        /** GetBlockHeightRequest _commitment. */
        public _commitment?: "commitment";

        /**
         * Creates a new GetBlockHeightRequest instance using the specified properties.
         * @param [properties] Properties to set
         * @returns GetBlockHeightRequest instance
         */
        public static create(properties?: geyser.IGetBlockHeightRequest): geyser.GetBlockHeightRequest;

        /**
         * Encodes the specified GetBlockHeightRequest message. Does not implicitly {@link geyser.GetBlockHeightRequest.verify|verify} messages.
         * @param message GetBlockHeightRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.IGetBlockHeightRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified GetBlockHeightRequest message, length delimited. Does not implicitly {@link geyser.GetBlockHeightRequest.verify|verify} messages.
         * @param message GetBlockHeightRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.IGetBlockHeightRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a GetBlockHeightRequest message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns GetBlockHeightRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.GetBlockHeightRequest;

        /**
         * Decodes a GetBlockHeightRequest message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns GetBlockHeightRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.GetBlockHeightRequest;

        /**
         * Verifies a GetBlockHeightRequest message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a GetBlockHeightRequest message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns GetBlockHeightRequest
         */
        public static fromObject(object: { [k: string]: any }): geyser.GetBlockHeightRequest;

        /**
         * Creates a plain object from a GetBlockHeightRequest message. Also converts values to other types if specified.
         * @param message GetBlockHeightRequest
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.GetBlockHeightRequest, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this GetBlockHeightRequest to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for GetBlockHeightRequest
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a GetBlockHeightResponse. */
    interface IGetBlockHeightResponse {

        /** GetBlockHeightResponse blockHeight */
        blockHeight?: (number|Long|null);
    }

    /** Represents a GetBlockHeightResponse. */
    class GetBlockHeightResponse implements IGetBlockHeightResponse {

        /**
         * Constructs a new GetBlockHeightResponse.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.IGetBlockHeightResponse);

        /** GetBlockHeightResponse blockHeight. */
        public blockHeight: (number|Long);

        /**
         * Creates a new GetBlockHeightResponse instance using the specified properties.
         * @param [properties] Properties to set
         * @returns GetBlockHeightResponse instance
         */
        public static create(properties?: geyser.IGetBlockHeightResponse): geyser.GetBlockHeightResponse;

        /**
         * Encodes the specified GetBlockHeightResponse message. Does not implicitly {@link geyser.GetBlockHeightResponse.verify|verify} messages.
         * @param message GetBlockHeightResponse message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.IGetBlockHeightResponse, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified GetBlockHeightResponse message, length delimited. Does not implicitly {@link geyser.GetBlockHeightResponse.verify|verify} messages.
         * @param message GetBlockHeightResponse message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.IGetBlockHeightResponse, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a GetBlockHeightResponse message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns GetBlockHeightResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.GetBlockHeightResponse;

        /**
         * Decodes a GetBlockHeightResponse message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns GetBlockHeightResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.GetBlockHeightResponse;

        /**
         * Verifies a GetBlockHeightResponse message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a GetBlockHeightResponse message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns GetBlockHeightResponse
         */
        public static fromObject(object: { [k: string]: any }): geyser.GetBlockHeightResponse;

        /**
         * Creates a plain object from a GetBlockHeightResponse message. Also converts values to other types if specified.
         * @param message GetBlockHeightResponse
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.GetBlockHeightResponse, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this GetBlockHeightResponse to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for GetBlockHeightResponse
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a GetSlotRequest. */
    interface IGetSlotRequest {

        /** GetSlotRequest commitment */
        commitment?: (geyser.CommitmentLevel|null);
    }

    /** Represents a GetSlotRequest. */
    class GetSlotRequest implements IGetSlotRequest {

        /**
         * Constructs a new GetSlotRequest.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.IGetSlotRequest);

        /** GetSlotRequest commitment. */
        public commitment?: (geyser.CommitmentLevel|null);

        /** GetSlotRequest _commitment. */
        public _commitment?: "commitment";

        /**
         * Creates a new GetSlotRequest instance using the specified properties.
         * @param [properties] Properties to set
         * @returns GetSlotRequest instance
         */
        public static create(properties?: geyser.IGetSlotRequest): geyser.GetSlotRequest;

        /**
         * Encodes the specified GetSlotRequest message. Does not implicitly {@link geyser.GetSlotRequest.verify|verify} messages.
         * @param message GetSlotRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.IGetSlotRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified GetSlotRequest message, length delimited. Does not implicitly {@link geyser.GetSlotRequest.verify|verify} messages.
         * @param message GetSlotRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.IGetSlotRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a GetSlotRequest message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns GetSlotRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.GetSlotRequest;

        /**
         * Decodes a GetSlotRequest message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns GetSlotRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.GetSlotRequest;

        /**
         * Verifies a GetSlotRequest message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a GetSlotRequest message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns GetSlotRequest
         */
        public static fromObject(object: { [k: string]: any }): geyser.GetSlotRequest;

        /**
         * Creates a plain object from a GetSlotRequest message. Also converts values to other types if specified.
         * @param message GetSlotRequest
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.GetSlotRequest, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this GetSlotRequest to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for GetSlotRequest
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a GetSlotResponse. */
    interface IGetSlotResponse {

        /** GetSlotResponse slot */
        slot?: (number|Long|null);
    }

    /** Represents a GetSlotResponse. */
    class GetSlotResponse implements IGetSlotResponse {

        /**
         * Constructs a new GetSlotResponse.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.IGetSlotResponse);

        /** GetSlotResponse slot. */
        public slot: (number|Long);

        /**
         * Creates a new GetSlotResponse instance using the specified properties.
         * @param [properties] Properties to set
         * @returns GetSlotResponse instance
         */
        public static create(properties?: geyser.IGetSlotResponse): geyser.GetSlotResponse;

        /**
         * Encodes the specified GetSlotResponse message. Does not implicitly {@link geyser.GetSlotResponse.verify|verify} messages.
         * @param message GetSlotResponse message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.IGetSlotResponse, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified GetSlotResponse message, length delimited. Does not implicitly {@link geyser.GetSlotResponse.verify|verify} messages.
         * @param message GetSlotResponse message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.IGetSlotResponse, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a GetSlotResponse message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns GetSlotResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.GetSlotResponse;

        /**
         * Decodes a GetSlotResponse message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns GetSlotResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.GetSlotResponse;

        /**
         * Verifies a GetSlotResponse message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a GetSlotResponse message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns GetSlotResponse
         */
        public static fromObject(object: { [k: string]: any }): geyser.GetSlotResponse;

        /**
         * Creates a plain object from a GetSlotResponse message. Also converts values to other types if specified.
         * @param message GetSlotResponse
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.GetSlotResponse, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this GetSlotResponse to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for GetSlotResponse
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a GetVersionRequest. */
    interface IGetVersionRequest {
    }

    /** Represents a GetVersionRequest. */
    class GetVersionRequest implements IGetVersionRequest {

        /**
         * Constructs a new GetVersionRequest.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.IGetVersionRequest);

        /**
         * Creates a new GetVersionRequest instance using the specified properties.
         * @param [properties] Properties to set
         * @returns GetVersionRequest instance
         */
        public static create(properties?: geyser.IGetVersionRequest): geyser.GetVersionRequest;

        /**
         * Encodes the specified GetVersionRequest message. Does not implicitly {@link geyser.GetVersionRequest.verify|verify} messages.
         * @param message GetVersionRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.IGetVersionRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified GetVersionRequest message, length delimited. Does not implicitly {@link geyser.GetVersionRequest.verify|verify} messages.
         * @param message GetVersionRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.IGetVersionRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a GetVersionRequest message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns GetVersionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.GetVersionRequest;

        /**
         * Decodes a GetVersionRequest message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns GetVersionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.GetVersionRequest;

        /**
         * Verifies a GetVersionRequest message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a GetVersionRequest message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns GetVersionRequest
         */
        public static fromObject(object: { [k: string]: any }): geyser.GetVersionRequest;

        /**
         * Creates a plain object from a GetVersionRequest message. Also converts values to other types if specified.
         * @param message GetVersionRequest
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.GetVersionRequest, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this GetVersionRequest to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for GetVersionRequest
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of a GetVersionResponse. */
    interface IGetVersionResponse {

        /** GetVersionResponse version */
        version?: (string|null);
    }

    /** Represents a GetVersionResponse. */
    class GetVersionResponse implements IGetVersionResponse {

        /**
         * Constructs a new GetVersionResponse.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.IGetVersionResponse);

        /** GetVersionResponse version. */
        public version: string;

        /**
         * Creates a new GetVersionResponse instance using the specified properties.
         * @param [properties] Properties to set
         * @returns GetVersionResponse instance
         */
        public static create(properties?: geyser.IGetVersionResponse): geyser.GetVersionResponse;

        /**
         * Encodes the specified GetVersionResponse message. Does not implicitly {@link geyser.GetVersionResponse.verify|verify} messages.
         * @param message GetVersionResponse message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.IGetVersionResponse, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified GetVersionResponse message, length delimited. Does not implicitly {@link geyser.GetVersionResponse.verify|verify} messages.
         * @param message GetVersionResponse message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.IGetVersionResponse, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a GetVersionResponse message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns GetVersionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.GetVersionResponse;

        /**
         * Decodes a GetVersionResponse message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns GetVersionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.GetVersionResponse;

        /**
         * Verifies a GetVersionResponse message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a GetVersionResponse message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns GetVersionResponse
         */
        public static fromObject(object: { [k: string]: any }): geyser.GetVersionResponse;

        /**
         * Creates a plain object from a GetVersionResponse message. Also converts values to other types if specified.
         * @param message GetVersionResponse
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.GetVersionResponse, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this GetVersionResponse to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for GetVersionResponse
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of an IsBlockhashValidRequest. */
    interface IIsBlockhashValidRequest {

        /** IsBlockhashValidRequest blockhash */
        blockhash?: (string|null);

        /** IsBlockhashValidRequest commitment */
        commitment?: (geyser.CommitmentLevel|null);
    }

    /** Represents an IsBlockhashValidRequest. */
    class IsBlockhashValidRequest implements IIsBlockhashValidRequest {

        /**
         * Constructs a new IsBlockhashValidRequest.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.IIsBlockhashValidRequest);

        /** IsBlockhashValidRequest blockhash. */
        public blockhash: string;

        /** IsBlockhashValidRequest commitment. */
        public commitment?: (geyser.CommitmentLevel|null);

        /** IsBlockhashValidRequest _commitment. */
        public _commitment?: "commitment";

        /**
         * Creates a new IsBlockhashValidRequest instance using the specified properties.
         * @param [properties] Properties to set
         * @returns IsBlockhashValidRequest instance
         */
        public static create(properties?: geyser.IIsBlockhashValidRequest): geyser.IsBlockhashValidRequest;

        /**
         * Encodes the specified IsBlockhashValidRequest message. Does not implicitly {@link geyser.IsBlockhashValidRequest.verify|verify} messages.
         * @param message IsBlockhashValidRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.IIsBlockhashValidRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified IsBlockhashValidRequest message, length delimited. Does not implicitly {@link geyser.IsBlockhashValidRequest.verify|verify} messages.
         * @param message IsBlockhashValidRequest message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.IIsBlockhashValidRequest, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an IsBlockhashValidRequest message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns IsBlockhashValidRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.IsBlockhashValidRequest;

        /**
         * Decodes an IsBlockhashValidRequest message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns IsBlockhashValidRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.IsBlockhashValidRequest;

        /**
         * Verifies an IsBlockhashValidRequest message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates an IsBlockhashValidRequest message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns IsBlockhashValidRequest
         */
        public static fromObject(object: { [k: string]: any }): geyser.IsBlockhashValidRequest;

        /**
         * Creates a plain object from an IsBlockhashValidRequest message. Also converts values to other types if specified.
         * @param message IsBlockhashValidRequest
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.IsBlockhashValidRequest, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this IsBlockhashValidRequest to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for IsBlockhashValidRequest
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }

    /** Properties of an IsBlockhashValidResponse. */
    interface IIsBlockhashValidResponse {

        /** IsBlockhashValidResponse slot */
        slot?: (number|Long|null);

        /** IsBlockhashValidResponse valid */
        valid?: (boolean|null);
    }

    /** Represents an IsBlockhashValidResponse. */
    class IsBlockhashValidResponse implements IIsBlockhashValidResponse {

        /**
         * Constructs a new IsBlockhashValidResponse.
         * @param [properties] Properties to set
         */
        constructor(properties?: geyser.IIsBlockhashValidResponse);

        /** IsBlockhashValidResponse slot. */
        public slot: (number|Long);

        /** IsBlockhashValidResponse valid. */
        public valid: boolean;

        /**
         * Creates a new IsBlockhashValidResponse instance using the specified properties.
         * @param [properties] Properties to set
         * @returns IsBlockhashValidResponse instance
         */
        public static create(properties?: geyser.IIsBlockhashValidResponse): geyser.IsBlockhashValidResponse;

        /**
         * Encodes the specified IsBlockhashValidResponse message. Does not implicitly {@link geyser.IsBlockhashValidResponse.verify|verify} messages.
         * @param message IsBlockhashValidResponse message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: geyser.IIsBlockhashValidResponse, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified IsBlockhashValidResponse message, length delimited. Does not implicitly {@link geyser.IsBlockhashValidResponse.verify|verify} messages.
         * @param message IsBlockhashValidResponse message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: geyser.IIsBlockhashValidResponse, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an IsBlockhashValidResponse message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns IsBlockhashValidResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): geyser.IsBlockhashValidResponse;

        /**
         * Decodes an IsBlockhashValidResponse message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns IsBlockhashValidResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): geyser.IsBlockhashValidResponse;

        /**
         * Verifies an IsBlockhashValidResponse message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates an IsBlockhashValidResponse message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns IsBlockhashValidResponse
         */
        public static fromObject(object: { [k: string]: any }): geyser.IsBlockhashValidResponse;

        /**
         * Creates a plain object from an IsBlockhashValidResponse message. Also converts values to other types if specified.
         * @param message IsBlockhashValidResponse
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: geyser.IsBlockhashValidResponse, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this IsBlockhashValidResponse to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };

        /**
         * Gets the default type url for IsBlockhashValidResponse
         * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns The default type url
         */
        public static getTypeUrl(typeUrlPrefix?: string): string;
    }
}

/** Namespace google. */
export namespace google {

    /** Namespace protobuf. */
    namespace protobuf {

        /** Properties of a Timestamp. */
        interface ITimestamp {

            /** Timestamp seconds */
            seconds?: (number|Long|null);

            /** Timestamp nanos */
            nanos?: (number|null);
        }

        /** Represents a Timestamp. */
        class Timestamp implements ITimestamp {

            /**
             * Constructs a new Timestamp.
             * @param [properties] Properties to set
             */
            constructor(properties?: google.protobuf.ITimestamp);

            /** Timestamp seconds. */
            public seconds: (number|Long);

            /** Timestamp nanos. */
            public nanos: number;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Timestamp instance
             */
            public static create(properties?: google.protobuf.ITimestamp): google.protobuf.Timestamp;

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @param message Timestamp message or plain object to encode
             * @param [writer] Writer to encode to
             * @returns Writer
             */
            public static encode(message: google.protobuf.ITimestamp, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @param message Timestamp message or plain object to encode
             * @param [writer] Writer to encode to
             * @returns Writer
             */
            public static encodeDelimited(message: google.protobuf.ITimestamp, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @param reader Reader or buffer to decode from
             * @param [length] Message length if known beforehand
             * @returns Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.Timestamp;

            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @param reader Reader or buffer to decode from
             * @returns Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.Timestamp;

            /**
             * Verifies a Timestamp message.
             * @param message Plain object to verify
             * @returns `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @param object Plain object
             * @returns Timestamp
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.Timestamp;

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @param message Timestamp
             * @param [options] Conversion options
             * @returns Plain object
             */
            public static toObject(message: google.protobuf.Timestamp, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Converts this Timestamp to JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };

            /**
             * Gets the default type url for Timestamp
             * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns The default type url
             */
            public static getTypeUrl(typeUrlPrefix?: string): string;
        }
    }
}

/** Namespace solana. */
export namespace solana {

    /** Namespace storage. */
    namespace storage {

        /** Namespace ConfirmedBlock. */
        namespace ConfirmedBlock {

            /** Properties of a ConfirmedBlock. */
            interface IConfirmedBlock {

                /** ConfirmedBlock previousBlockhash */
                previousBlockhash?: (string|null);

                /** ConfirmedBlock blockhash */
                blockhash?: (string|null);

                /** ConfirmedBlock parentSlot */
                parentSlot?: (number|Long|null);

                /** ConfirmedBlock transactions */
                transactions?: (solana.storage.ConfirmedBlock.IConfirmedTransaction[]|null);

                /** ConfirmedBlock rewards */
                rewards?: (solana.storage.ConfirmedBlock.IReward[]|null);

                /** ConfirmedBlock blockTime */
                blockTime?: (solana.storage.ConfirmedBlock.IUnixTimestamp|null);

                /** ConfirmedBlock blockHeight */
                blockHeight?: (solana.storage.ConfirmedBlock.IBlockHeight|null);

                /** ConfirmedBlock numPartitions */
                numPartitions?: (solana.storage.ConfirmedBlock.INumPartitions|null);
            }

            /** Represents a ConfirmedBlock. */
            class ConfirmedBlock implements IConfirmedBlock {

                /**
                 * Constructs a new ConfirmedBlock.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.IConfirmedBlock);

                /** ConfirmedBlock previousBlockhash. */
                public previousBlockhash: string;

                /** ConfirmedBlock blockhash. */
                public blockhash: string;

                /** ConfirmedBlock parentSlot. */
                public parentSlot: (number|Long);

                /** ConfirmedBlock transactions. */
                public transactions: solana.storage.ConfirmedBlock.IConfirmedTransaction[];

                /** ConfirmedBlock rewards. */
                public rewards: solana.storage.ConfirmedBlock.IReward[];

                /** ConfirmedBlock blockTime. */
                public blockTime?: (solana.storage.ConfirmedBlock.IUnixTimestamp|null);

                /** ConfirmedBlock blockHeight. */
                public blockHeight?: (solana.storage.ConfirmedBlock.IBlockHeight|null);

                /** ConfirmedBlock numPartitions. */
                public numPartitions?: (solana.storage.ConfirmedBlock.INumPartitions|null);

                /**
                 * Creates a new ConfirmedBlock instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ConfirmedBlock instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.IConfirmedBlock): solana.storage.ConfirmedBlock.ConfirmedBlock;

                /**
                 * Encodes the specified ConfirmedBlock message. Does not implicitly {@link solana.storage.ConfirmedBlock.ConfirmedBlock.verify|verify} messages.
                 * @param message ConfirmedBlock message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.IConfirmedBlock, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ConfirmedBlock message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.ConfirmedBlock.verify|verify} messages.
                 * @param message ConfirmedBlock message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.IConfirmedBlock, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ConfirmedBlock message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ConfirmedBlock
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.ConfirmedBlock;

                /**
                 * Decodes a ConfirmedBlock message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns ConfirmedBlock
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.ConfirmedBlock;

                /**
                 * Verifies a ConfirmedBlock message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ConfirmedBlock message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ConfirmedBlock
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.ConfirmedBlock;

                /**
                 * Creates a plain object from a ConfirmedBlock message. Also converts values to other types if specified.
                 * @param message ConfirmedBlock
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.ConfirmedBlock, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ConfirmedBlock to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for ConfirmedBlock
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a ConfirmedTransaction. */
            interface IConfirmedTransaction {

                /** ConfirmedTransaction transaction */
                transaction?: (solana.storage.ConfirmedBlock.ITransaction|null);

                /** ConfirmedTransaction meta */
                meta?: (solana.storage.ConfirmedBlock.ITransactionStatusMeta|null);
            }

            /** Represents a ConfirmedTransaction. */
            class ConfirmedTransaction implements IConfirmedTransaction {

                /**
                 * Constructs a new ConfirmedTransaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.IConfirmedTransaction);

                /** ConfirmedTransaction transaction. */
                public transaction?: (solana.storage.ConfirmedBlock.ITransaction|null);

                /** ConfirmedTransaction meta. */
                public meta?: (solana.storage.ConfirmedBlock.ITransactionStatusMeta|null);

                /**
                 * Creates a new ConfirmedTransaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ConfirmedTransaction instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.IConfirmedTransaction): solana.storage.ConfirmedBlock.ConfirmedTransaction;

                /**
                 * Encodes the specified ConfirmedTransaction message. Does not implicitly {@link solana.storage.ConfirmedBlock.ConfirmedTransaction.verify|verify} messages.
                 * @param message ConfirmedTransaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.IConfirmedTransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ConfirmedTransaction message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.ConfirmedTransaction.verify|verify} messages.
                 * @param message ConfirmedTransaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.IConfirmedTransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ConfirmedTransaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ConfirmedTransaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.ConfirmedTransaction;

                /**
                 * Decodes a ConfirmedTransaction message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns ConfirmedTransaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.ConfirmedTransaction;

                /**
                 * Verifies a ConfirmedTransaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ConfirmedTransaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ConfirmedTransaction
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.ConfirmedTransaction;

                /**
                 * Creates a plain object from a ConfirmedTransaction message. Also converts values to other types if specified.
                 * @param message ConfirmedTransaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.ConfirmedTransaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ConfirmedTransaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for ConfirmedTransaction
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a Transaction. */
            interface ITransaction {

                /** Transaction signatures */
                signatures?: (Uint8Array[]|null);

                /** Transaction message */
                message?: (solana.storage.ConfirmedBlock.IMessage|null);
            }

            /** Represents a Transaction. */
            class Transaction implements ITransaction {

                /**
                 * Constructs a new Transaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.ITransaction);

                /** Transaction signatures. */
                public signatures: Uint8Array[];

                /** Transaction message. */
                public message?: (solana.storage.ConfirmedBlock.IMessage|null);

                /**
                 * Creates a new Transaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transaction instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.ITransaction): solana.storage.ConfirmedBlock.Transaction;

                /**
                 * Encodes the specified Transaction message. Does not implicitly {@link solana.storage.ConfirmedBlock.Transaction.verify|verify} messages.
                 * @param message Transaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Transaction message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.Transaction.verify|verify} messages.
                 * @param message Transaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.Transaction;

                /**
                 * Decodes a Transaction message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.Transaction;

                /**
                 * Verifies a Transaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transaction
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.Transaction;

                /**
                 * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                 * @param message Transaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.Transaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for Transaction
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a Message. */
            interface IMessage {

                /** Message header */
                header?: (solana.storage.ConfirmedBlock.IMessageHeader|null);

                /** Message accountKeys */
                accountKeys?: (Uint8Array[]|null);

                /** Message recentBlockhash */
                recentBlockhash?: (Uint8Array|null);

                /** Message instructions */
                instructions?: (solana.storage.ConfirmedBlock.ICompiledInstruction[]|null);

                /** Message versioned */
                versioned?: (boolean|null);

                /** Message addressTableLookups */
                addressTableLookups?: (solana.storage.ConfirmedBlock.IMessageAddressTableLookup[]|null);
            }

            /** Represents a Message. */
            class Message implements IMessage {

                /**
                 * Constructs a new Message.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.IMessage);

                /** Message header. */
                public header?: (solana.storage.ConfirmedBlock.IMessageHeader|null);

                /** Message accountKeys. */
                public accountKeys: Uint8Array[];

                /** Message recentBlockhash. */
                public recentBlockhash: Uint8Array;

                /** Message instructions. */
                public instructions: solana.storage.ConfirmedBlock.ICompiledInstruction[];

                /** Message versioned. */
                public versioned: boolean;

                /** Message addressTableLookups. */
                public addressTableLookups: solana.storage.ConfirmedBlock.IMessageAddressTableLookup[];

                /**
                 * Creates a new Message instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Message instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.IMessage): solana.storage.ConfirmedBlock.Message;

                /**
                 * Encodes the specified Message message. Does not implicitly {@link solana.storage.ConfirmedBlock.Message.verify|verify} messages.
                 * @param message Message message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.IMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Message message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.Message.verify|verify} messages.
                 * @param message Message message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.IMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Message message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.Message;

                /**
                 * Decodes a Message message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.Message;

                /**
                 * Verifies a Message message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Message message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Message
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.Message;

                /**
                 * Creates a plain object from a Message message. Also converts values to other types if specified.
                 * @param message Message
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.Message, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Message to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for Message
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a MessageHeader. */
            interface IMessageHeader {

                /** MessageHeader numRequiredSignatures */
                numRequiredSignatures?: (number|null);

                /** MessageHeader numReadonlySignedAccounts */
                numReadonlySignedAccounts?: (number|null);

                /** MessageHeader numReadonlyUnsignedAccounts */
                numReadonlyUnsignedAccounts?: (number|null);
            }

            /** Represents a MessageHeader. */
            class MessageHeader implements IMessageHeader {

                /**
                 * Constructs a new MessageHeader.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.IMessageHeader);

                /** MessageHeader numRequiredSignatures. */
                public numRequiredSignatures: number;

                /** MessageHeader numReadonlySignedAccounts. */
                public numReadonlySignedAccounts: number;

                /** MessageHeader numReadonlyUnsignedAccounts. */
                public numReadonlyUnsignedAccounts: number;

                /**
                 * Creates a new MessageHeader instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns MessageHeader instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.IMessageHeader): solana.storage.ConfirmedBlock.MessageHeader;

                /**
                 * Encodes the specified MessageHeader message. Does not implicitly {@link solana.storage.ConfirmedBlock.MessageHeader.verify|verify} messages.
                 * @param message MessageHeader message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.IMessageHeader, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified MessageHeader message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.MessageHeader.verify|verify} messages.
                 * @param message MessageHeader message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.IMessageHeader, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a MessageHeader message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns MessageHeader
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.MessageHeader;

                /**
                 * Decodes a MessageHeader message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns MessageHeader
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.MessageHeader;

                /**
                 * Verifies a MessageHeader message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a MessageHeader message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns MessageHeader
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.MessageHeader;

                /**
                 * Creates a plain object from a MessageHeader message. Also converts values to other types if specified.
                 * @param message MessageHeader
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.MessageHeader, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this MessageHeader to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for MessageHeader
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a MessageAddressTableLookup. */
            interface IMessageAddressTableLookup {

                /** MessageAddressTableLookup accountKey */
                accountKey?: (Uint8Array|null);

                /** MessageAddressTableLookup writableIndexes */
                writableIndexes?: (Uint8Array|null);

                /** MessageAddressTableLookup readonlyIndexes */
                readonlyIndexes?: (Uint8Array|null);
            }

            /** Represents a MessageAddressTableLookup. */
            class MessageAddressTableLookup implements IMessageAddressTableLookup {

                /**
                 * Constructs a new MessageAddressTableLookup.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.IMessageAddressTableLookup);

                /** MessageAddressTableLookup accountKey. */
                public accountKey: Uint8Array;

                /** MessageAddressTableLookup writableIndexes. */
                public writableIndexes: Uint8Array;

                /** MessageAddressTableLookup readonlyIndexes. */
                public readonlyIndexes: Uint8Array;

                /**
                 * Creates a new MessageAddressTableLookup instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns MessageAddressTableLookup instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.IMessageAddressTableLookup): solana.storage.ConfirmedBlock.MessageAddressTableLookup;

                /**
                 * Encodes the specified MessageAddressTableLookup message. Does not implicitly {@link solana.storage.ConfirmedBlock.MessageAddressTableLookup.verify|verify} messages.
                 * @param message MessageAddressTableLookup message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.IMessageAddressTableLookup, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified MessageAddressTableLookup message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.MessageAddressTableLookup.verify|verify} messages.
                 * @param message MessageAddressTableLookup message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.IMessageAddressTableLookup, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a MessageAddressTableLookup message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns MessageAddressTableLookup
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.MessageAddressTableLookup;

                /**
                 * Decodes a MessageAddressTableLookup message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns MessageAddressTableLookup
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.MessageAddressTableLookup;

                /**
                 * Verifies a MessageAddressTableLookup message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a MessageAddressTableLookup message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns MessageAddressTableLookup
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.MessageAddressTableLookup;

                /**
                 * Creates a plain object from a MessageAddressTableLookup message. Also converts values to other types if specified.
                 * @param message MessageAddressTableLookup
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.MessageAddressTableLookup, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this MessageAddressTableLookup to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for MessageAddressTableLookup
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a TransactionStatusMeta. */
            interface ITransactionStatusMeta {

                /** TransactionStatusMeta err */
                err?: (solana.storage.ConfirmedBlock.ITransactionError|null);

                /** TransactionStatusMeta fee */
                fee?: (number|Long|null);

                /** TransactionStatusMeta preBalances */
                preBalances?: ((number|Long)[]|null);

                /** TransactionStatusMeta postBalances */
                postBalances?: ((number|Long)[]|null);

                /** TransactionStatusMeta innerInstructions */
                innerInstructions?: (solana.storage.ConfirmedBlock.IInnerInstructions[]|null);

                /** TransactionStatusMeta innerInstructionsNone */
                innerInstructionsNone?: (boolean|null);

                /** TransactionStatusMeta logMessages */
                logMessages?: (string[]|null);

                /** TransactionStatusMeta logMessagesNone */
                logMessagesNone?: (boolean|null);

                /** TransactionStatusMeta preTokenBalances */
                preTokenBalances?: (solana.storage.ConfirmedBlock.ITokenBalance[]|null);

                /** TransactionStatusMeta postTokenBalances */
                postTokenBalances?: (solana.storage.ConfirmedBlock.ITokenBalance[]|null);

                /** TransactionStatusMeta rewards */
                rewards?: (solana.storage.ConfirmedBlock.IReward[]|null);

                /** TransactionStatusMeta loadedWritableAddresses */
                loadedWritableAddresses?: (Uint8Array[]|null);

                /** TransactionStatusMeta loadedReadonlyAddresses */
                loadedReadonlyAddresses?: (Uint8Array[]|null);

                /** TransactionStatusMeta returnData */
                returnData?: (solana.storage.ConfirmedBlock.IReturnData|null);

                /** TransactionStatusMeta returnDataNone */
                returnDataNone?: (boolean|null);

                /** TransactionStatusMeta computeUnitsConsumed */
                computeUnitsConsumed?: (number|Long|null);

                /** TransactionStatusMeta costUnits */
                costUnits?: (number|Long|null);
            }

            /** Represents a TransactionStatusMeta. */
            class TransactionStatusMeta implements ITransactionStatusMeta {

                /**
                 * Constructs a new TransactionStatusMeta.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.ITransactionStatusMeta);

                /** TransactionStatusMeta err. */
                public err?: (solana.storage.ConfirmedBlock.ITransactionError|null);

                /** TransactionStatusMeta fee. */
                public fee: (number|Long);

                /** TransactionStatusMeta preBalances. */
                public preBalances: (number|Long)[];

                /** TransactionStatusMeta postBalances. */
                public postBalances: (number|Long)[];

                /** TransactionStatusMeta innerInstructions. */
                public innerInstructions: solana.storage.ConfirmedBlock.IInnerInstructions[];

                /** TransactionStatusMeta innerInstructionsNone. */
                public innerInstructionsNone: boolean;

                /** TransactionStatusMeta logMessages. */
                public logMessages: string[];

                /** TransactionStatusMeta logMessagesNone. */
                public logMessagesNone: boolean;

                /** TransactionStatusMeta preTokenBalances. */
                public preTokenBalances: solana.storage.ConfirmedBlock.ITokenBalance[];

                /** TransactionStatusMeta postTokenBalances. */
                public postTokenBalances: solana.storage.ConfirmedBlock.ITokenBalance[];

                /** TransactionStatusMeta rewards. */
                public rewards: solana.storage.ConfirmedBlock.IReward[];

                /** TransactionStatusMeta loadedWritableAddresses. */
                public loadedWritableAddresses: Uint8Array[];

                /** TransactionStatusMeta loadedReadonlyAddresses. */
                public loadedReadonlyAddresses: Uint8Array[];

                /** TransactionStatusMeta returnData. */
                public returnData?: (solana.storage.ConfirmedBlock.IReturnData|null);

                /** TransactionStatusMeta returnDataNone. */
                public returnDataNone: boolean;

                /** TransactionStatusMeta computeUnitsConsumed. */
                public computeUnitsConsumed?: (number|Long|null);

                /** TransactionStatusMeta costUnits. */
                public costUnits?: (number|Long|null);

                /** TransactionStatusMeta _computeUnitsConsumed. */
                public _computeUnitsConsumed?: "computeUnitsConsumed";

                /** TransactionStatusMeta _costUnits. */
                public _costUnits?: "costUnits";

                /**
                 * Creates a new TransactionStatusMeta instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionStatusMeta instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.ITransactionStatusMeta): solana.storage.ConfirmedBlock.TransactionStatusMeta;

                /**
                 * Encodes the specified TransactionStatusMeta message. Does not implicitly {@link solana.storage.ConfirmedBlock.TransactionStatusMeta.verify|verify} messages.
                 * @param message TransactionStatusMeta message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.ITransactionStatusMeta, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified TransactionStatusMeta message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.TransactionStatusMeta.verify|verify} messages.
                 * @param message TransactionStatusMeta message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.ITransactionStatusMeta, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionStatusMeta message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionStatusMeta
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.TransactionStatusMeta;

                /**
                 * Decodes a TransactionStatusMeta message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns TransactionStatusMeta
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.TransactionStatusMeta;

                /**
                 * Verifies a TransactionStatusMeta message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionStatusMeta message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionStatusMeta
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.TransactionStatusMeta;

                /**
                 * Creates a plain object from a TransactionStatusMeta message. Also converts values to other types if specified.
                 * @param message TransactionStatusMeta
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.TransactionStatusMeta, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionStatusMeta to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for TransactionStatusMeta
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a TransactionError. */
            interface ITransactionError {

                /** TransactionError err */
                err?: (Uint8Array|null);
            }

            /** Represents a TransactionError. */
            class TransactionError implements ITransactionError {

                /**
                 * Constructs a new TransactionError.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.ITransactionError);

                /** TransactionError err. */
                public err: Uint8Array;

                /**
                 * Creates a new TransactionError instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionError instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.ITransactionError): solana.storage.ConfirmedBlock.TransactionError;

                /**
                 * Encodes the specified TransactionError message. Does not implicitly {@link solana.storage.ConfirmedBlock.TransactionError.verify|verify} messages.
                 * @param message TransactionError message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.ITransactionError, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified TransactionError message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.TransactionError.verify|verify} messages.
                 * @param message TransactionError message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.ITransactionError, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionError message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionError
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.TransactionError;

                /**
                 * Decodes a TransactionError message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns TransactionError
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.TransactionError;

                /**
                 * Verifies a TransactionError message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionError message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionError
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.TransactionError;

                /**
                 * Creates a plain object from a TransactionError message. Also converts values to other types if specified.
                 * @param message TransactionError
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.TransactionError, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionError to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for TransactionError
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of an InnerInstructions. */
            interface IInnerInstructions {

                /** InnerInstructions index */
                index?: (number|null);

                /** InnerInstructions instructions */
                instructions?: (solana.storage.ConfirmedBlock.IInnerInstruction[]|null);
            }

            /** Represents an InnerInstructions. */
            class InnerInstructions implements IInnerInstructions {

                /**
                 * Constructs a new InnerInstructions.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.IInnerInstructions);

                /** InnerInstructions index. */
                public index: number;

                /** InnerInstructions instructions. */
                public instructions: solana.storage.ConfirmedBlock.IInnerInstruction[];

                /**
                 * Creates a new InnerInstructions instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns InnerInstructions instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.IInnerInstructions): solana.storage.ConfirmedBlock.InnerInstructions;

                /**
                 * Encodes the specified InnerInstructions message. Does not implicitly {@link solana.storage.ConfirmedBlock.InnerInstructions.verify|verify} messages.
                 * @param message InnerInstructions message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.IInnerInstructions, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified InnerInstructions message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.InnerInstructions.verify|verify} messages.
                 * @param message InnerInstructions message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.IInnerInstructions, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an InnerInstructions message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns InnerInstructions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.InnerInstructions;

                /**
                 * Decodes an InnerInstructions message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns InnerInstructions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.InnerInstructions;

                /**
                 * Verifies an InnerInstructions message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an InnerInstructions message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns InnerInstructions
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.InnerInstructions;

                /**
                 * Creates a plain object from an InnerInstructions message. Also converts values to other types if specified.
                 * @param message InnerInstructions
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.InnerInstructions, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this InnerInstructions to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for InnerInstructions
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of an InnerInstruction. */
            interface IInnerInstruction {

                /** InnerInstruction programIdIndex */
                programIdIndex?: (number|null);

                /** InnerInstruction accounts */
                accounts?: (Uint8Array|null);

                /** InnerInstruction data */
                data?: (Uint8Array|null);

                /** InnerInstruction stackHeight */
                stackHeight?: (number|null);
            }

            /** Represents an InnerInstruction. */
            class InnerInstruction implements IInnerInstruction {

                /**
                 * Constructs a new InnerInstruction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.IInnerInstruction);

                /** InnerInstruction programIdIndex. */
                public programIdIndex: number;

                /** InnerInstruction accounts. */
                public accounts: Uint8Array;

                /** InnerInstruction data. */
                public data: Uint8Array;

                /** InnerInstruction stackHeight. */
                public stackHeight?: (number|null);

                /** InnerInstruction _stackHeight. */
                public _stackHeight?: "stackHeight";

                /**
                 * Creates a new InnerInstruction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns InnerInstruction instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.IInnerInstruction): solana.storage.ConfirmedBlock.InnerInstruction;

                /**
                 * Encodes the specified InnerInstruction message. Does not implicitly {@link solana.storage.ConfirmedBlock.InnerInstruction.verify|verify} messages.
                 * @param message InnerInstruction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.IInnerInstruction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified InnerInstruction message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.InnerInstruction.verify|verify} messages.
                 * @param message InnerInstruction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.IInnerInstruction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an InnerInstruction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns InnerInstruction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.InnerInstruction;

                /**
                 * Decodes an InnerInstruction message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns InnerInstruction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.InnerInstruction;

                /**
                 * Verifies an InnerInstruction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an InnerInstruction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns InnerInstruction
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.InnerInstruction;

                /**
                 * Creates a plain object from an InnerInstruction message. Also converts values to other types if specified.
                 * @param message InnerInstruction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.InnerInstruction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this InnerInstruction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for InnerInstruction
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a CompiledInstruction. */
            interface ICompiledInstruction {

                /** CompiledInstruction programIdIndex */
                programIdIndex?: (number|null);

                /** CompiledInstruction accounts */
                accounts?: (Uint8Array|null);

                /** CompiledInstruction data */
                data?: (Uint8Array|null);
            }

            /** Represents a CompiledInstruction. */
            class CompiledInstruction implements ICompiledInstruction {

                /**
                 * Constructs a new CompiledInstruction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.ICompiledInstruction);

                /** CompiledInstruction programIdIndex. */
                public programIdIndex: number;

                /** CompiledInstruction accounts. */
                public accounts: Uint8Array;

                /** CompiledInstruction data. */
                public data: Uint8Array;

                /**
                 * Creates a new CompiledInstruction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CompiledInstruction instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.ICompiledInstruction): solana.storage.ConfirmedBlock.CompiledInstruction;

                /**
                 * Encodes the specified CompiledInstruction message. Does not implicitly {@link solana.storage.ConfirmedBlock.CompiledInstruction.verify|verify} messages.
                 * @param message CompiledInstruction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.ICompiledInstruction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified CompiledInstruction message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.CompiledInstruction.verify|verify} messages.
                 * @param message CompiledInstruction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.ICompiledInstruction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CompiledInstruction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CompiledInstruction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.CompiledInstruction;

                /**
                 * Decodes a CompiledInstruction message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns CompiledInstruction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.CompiledInstruction;

                /**
                 * Verifies a CompiledInstruction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CompiledInstruction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CompiledInstruction
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.CompiledInstruction;

                /**
                 * Creates a plain object from a CompiledInstruction message. Also converts values to other types if specified.
                 * @param message CompiledInstruction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.CompiledInstruction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CompiledInstruction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for CompiledInstruction
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a TokenBalance. */
            interface ITokenBalance {

                /** TokenBalance accountIndex */
                accountIndex?: (number|null);

                /** TokenBalance mint */
                mint?: (string|null);

                /** TokenBalance uiTokenAmount */
                uiTokenAmount?: (solana.storage.ConfirmedBlock.IUiTokenAmount|null);

                /** TokenBalance owner */
                owner?: (string|null);

                /** TokenBalance programId */
                programId?: (string|null);
            }

            /** Represents a TokenBalance. */
            class TokenBalance implements ITokenBalance {

                /**
                 * Constructs a new TokenBalance.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.ITokenBalance);

                /** TokenBalance accountIndex. */
                public accountIndex: number;

                /** TokenBalance mint. */
                public mint: string;

                /** TokenBalance uiTokenAmount. */
                public uiTokenAmount?: (solana.storage.ConfirmedBlock.IUiTokenAmount|null);

                /** TokenBalance owner. */
                public owner: string;

                /** TokenBalance programId. */
                public programId: string;

                /**
                 * Creates a new TokenBalance instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TokenBalance instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.ITokenBalance): solana.storage.ConfirmedBlock.TokenBalance;

                /**
                 * Encodes the specified TokenBalance message. Does not implicitly {@link solana.storage.ConfirmedBlock.TokenBalance.verify|verify} messages.
                 * @param message TokenBalance message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.ITokenBalance, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified TokenBalance message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.TokenBalance.verify|verify} messages.
                 * @param message TokenBalance message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.ITokenBalance, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TokenBalance message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TokenBalance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.TokenBalance;

                /**
                 * Decodes a TokenBalance message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns TokenBalance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.TokenBalance;

                /**
                 * Verifies a TokenBalance message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TokenBalance message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TokenBalance
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.TokenBalance;

                /**
                 * Creates a plain object from a TokenBalance message. Also converts values to other types if specified.
                 * @param message TokenBalance
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.TokenBalance, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TokenBalance to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for TokenBalance
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of an UiTokenAmount. */
            interface IUiTokenAmount {

                /** UiTokenAmount uiAmount */
                uiAmount?: (number|null);

                /** UiTokenAmount decimals */
                decimals?: (number|null);

                /** UiTokenAmount amount */
                amount?: (string|null);

                /** UiTokenAmount uiAmountString */
                uiAmountString?: (string|null);
            }

            /** Represents an UiTokenAmount. */
            class UiTokenAmount implements IUiTokenAmount {

                /**
                 * Constructs a new UiTokenAmount.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.IUiTokenAmount);

                /** UiTokenAmount uiAmount. */
                public uiAmount: number;

                /** UiTokenAmount decimals. */
                public decimals: number;

                /** UiTokenAmount amount. */
                public amount: string;

                /** UiTokenAmount uiAmountString. */
                public uiAmountString: string;

                /**
                 * Creates a new UiTokenAmount instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns UiTokenAmount instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.IUiTokenAmount): solana.storage.ConfirmedBlock.UiTokenAmount;

                /**
                 * Encodes the specified UiTokenAmount message. Does not implicitly {@link solana.storage.ConfirmedBlock.UiTokenAmount.verify|verify} messages.
                 * @param message UiTokenAmount message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.IUiTokenAmount, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified UiTokenAmount message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.UiTokenAmount.verify|verify} messages.
                 * @param message UiTokenAmount message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.IUiTokenAmount, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an UiTokenAmount message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns UiTokenAmount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.UiTokenAmount;

                /**
                 * Decodes an UiTokenAmount message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns UiTokenAmount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.UiTokenAmount;

                /**
                 * Verifies an UiTokenAmount message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an UiTokenAmount message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns UiTokenAmount
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.UiTokenAmount;

                /**
                 * Creates a plain object from an UiTokenAmount message. Also converts values to other types if specified.
                 * @param message UiTokenAmount
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.UiTokenAmount, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this UiTokenAmount to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for UiTokenAmount
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a ReturnData. */
            interface IReturnData {

                /** ReturnData programId */
                programId?: (Uint8Array|null);

                /** ReturnData data */
                data?: (Uint8Array|null);
            }

            /** Represents a ReturnData. */
            class ReturnData implements IReturnData {

                /**
                 * Constructs a new ReturnData.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.IReturnData);

                /** ReturnData programId. */
                public programId: Uint8Array;

                /** ReturnData data. */
                public data: Uint8Array;

                /**
                 * Creates a new ReturnData instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ReturnData instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.IReturnData): solana.storage.ConfirmedBlock.ReturnData;

                /**
                 * Encodes the specified ReturnData message. Does not implicitly {@link solana.storage.ConfirmedBlock.ReturnData.verify|verify} messages.
                 * @param message ReturnData message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.IReturnData, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ReturnData message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.ReturnData.verify|verify} messages.
                 * @param message ReturnData message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.IReturnData, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ReturnData message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ReturnData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.ReturnData;

                /**
                 * Decodes a ReturnData message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns ReturnData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.ReturnData;

                /**
                 * Verifies a ReturnData message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ReturnData message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ReturnData
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.ReturnData;

                /**
                 * Creates a plain object from a ReturnData message. Also converts values to other types if specified.
                 * @param message ReturnData
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.ReturnData, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ReturnData to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for ReturnData
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** RewardType enum. */
            enum RewardType {
                Unspecified = 0,
                Fee = 1,
                Rent = 2,
                Staking = 3,
                Voting = 4
            }

            /** Properties of a Reward. */
            interface IReward {

                /** Reward pubkey */
                pubkey?: (string|null);

                /** Reward lamports */
                lamports?: (number|Long|null);

                /** Reward postBalance */
                postBalance?: (number|Long|null);

                /** Reward rewardType */
                rewardType?: (solana.storage.ConfirmedBlock.RewardType|null);

                /** Reward commission */
                commission?: (string|null);
            }

            /** Represents a Reward. */
            class Reward implements IReward {

                /**
                 * Constructs a new Reward.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.IReward);

                /** Reward pubkey. */
                public pubkey: string;

                /** Reward lamports. */
                public lamports: (number|Long);

                /** Reward postBalance. */
                public postBalance: (number|Long);

                /** Reward rewardType. */
                public rewardType: solana.storage.ConfirmedBlock.RewardType;

                /** Reward commission. */
                public commission: string;

                /**
                 * Creates a new Reward instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Reward instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.IReward): solana.storage.ConfirmedBlock.Reward;

                /**
                 * Encodes the specified Reward message. Does not implicitly {@link solana.storage.ConfirmedBlock.Reward.verify|verify} messages.
                 * @param message Reward message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.IReward, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Reward message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.Reward.verify|verify} messages.
                 * @param message Reward message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.IReward, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Reward message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Reward
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.Reward;

                /**
                 * Decodes a Reward message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns Reward
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.Reward;

                /**
                 * Verifies a Reward message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Reward message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Reward
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.Reward;

                /**
                 * Creates a plain object from a Reward message. Also converts values to other types if specified.
                 * @param message Reward
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.Reward, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Reward to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for Reward
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a Rewards. */
            interface IRewards {

                /** Rewards rewards */
                rewards?: (solana.storage.ConfirmedBlock.IReward[]|null);

                /** Rewards numPartitions */
                numPartitions?: (solana.storage.ConfirmedBlock.INumPartitions|null);
            }

            /** Represents a Rewards. */
            class Rewards implements IRewards {

                /**
                 * Constructs a new Rewards.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.IRewards);

                /** Rewards rewards. */
                public rewards: solana.storage.ConfirmedBlock.IReward[];

                /** Rewards numPartitions. */
                public numPartitions?: (solana.storage.ConfirmedBlock.INumPartitions|null);

                /**
                 * Creates a new Rewards instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Rewards instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.IRewards): solana.storage.ConfirmedBlock.Rewards;

                /**
                 * Encodes the specified Rewards message. Does not implicitly {@link solana.storage.ConfirmedBlock.Rewards.verify|verify} messages.
                 * @param message Rewards message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.IRewards, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Rewards message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.Rewards.verify|verify} messages.
                 * @param message Rewards message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.IRewards, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Rewards message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Rewards
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.Rewards;

                /**
                 * Decodes a Rewards message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns Rewards
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.Rewards;

                /**
                 * Verifies a Rewards message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Rewards message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Rewards
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.Rewards;

                /**
                 * Creates a plain object from a Rewards message. Also converts values to other types if specified.
                 * @param message Rewards
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.Rewards, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Rewards to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for Rewards
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of an UnixTimestamp. */
            interface IUnixTimestamp {

                /** UnixTimestamp timestamp */
                timestamp?: (number|Long|null);
            }

            /** Represents an UnixTimestamp. */
            class UnixTimestamp implements IUnixTimestamp {

                /**
                 * Constructs a new UnixTimestamp.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.IUnixTimestamp);

                /** UnixTimestamp timestamp. */
                public timestamp: (number|Long);

                /**
                 * Creates a new UnixTimestamp instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns UnixTimestamp instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.IUnixTimestamp): solana.storage.ConfirmedBlock.UnixTimestamp;

                /**
                 * Encodes the specified UnixTimestamp message. Does not implicitly {@link solana.storage.ConfirmedBlock.UnixTimestamp.verify|verify} messages.
                 * @param message UnixTimestamp message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.IUnixTimestamp, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified UnixTimestamp message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.UnixTimestamp.verify|verify} messages.
                 * @param message UnixTimestamp message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.IUnixTimestamp, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an UnixTimestamp message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns UnixTimestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.UnixTimestamp;

                /**
                 * Decodes an UnixTimestamp message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns UnixTimestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.UnixTimestamp;

                /**
                 * Verifies an UnixTimestamp message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an UnixTimestamp message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns UnixTimestamp
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.UnixTimestamp;

                /**
                 * Creates a plain object from an UnixTimestamp message. Also converts values to other types if specified.
                 * @param message UnixTimestamp
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.UnixTimestamp, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this UnixTimestamp to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for UnixTimestamp
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a BlockHeight. */
            interface IBlockHeight {

                /** BlockHeight blockHeight */
                blockHeight?: (number|Long|null);
            }

            /** Represents a BlockHeight. */
            class BlockHeight implements IBlockHeight {

                /**
                 * Constructs a new BlockHeight.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.IBlockHeight);

                /** BlockHeight blockHeight. */
                public blockHeight: (number|Long);

                /**
                 * Creates a new BlockHeight instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns BlockHeight instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.IBlockHeight): solana.storage.ConfirmedBlock.BlockHeight;

                /**
                 * Encodes the specified BlockHeight message. Does not implicitly {@link solana.storage.ConfirmedBlock.BlockHeight.verify|verify} messages.
                 * @param message BlockHeight message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.IBlockHeight, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified BlockHeight message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.BlockHeight.verify|verify} messages.
                 * @param message BlockHeight message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.IBlockHeight, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a BlockHeight message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns BlockHeight
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.BlockHeight;

                /**
                 * Decodes a BlockHeight message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns BlockHeight
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.BlockHeight;

                /**
                 * Verifies a BlockHeight message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a BlockHeight message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns BlockHeight
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.BlockHeight;

                /**
                 * Creates a plain object from a BlockHeight message. Also converts values to other types if specified.
                 * @param message BlockHeight
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.BlockHeight, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this BlockHeight to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for BlockHeight
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }

            /** Properties of a NumPartitions. */
            interface INumPartitions {

                /** NumPartitions numPartitions */
                numPartitions?: (number|Long|null);
            }

            /** Represents a NumPartitions. */
            class NumPartitions implements INumPartitions {

                /**
                 * Constructs a new NumPartitions.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: solana.storage.ConfirmedBlock.INumPartitions);

                /** NumPartitions numPartitions. */
                public numPartitions: (number|Long);

                /**
                 * Creates a new NumPartitions instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns NumPartitions instance
                 */
                public static create(properties?: solana.storage.ConfirmedBlock.INumPartitions): solana.storage.ConfirmedBlock.NumPartitions;

                /**
                 * Encodes the specified NumPartitions message. Does not implicitly {@link solana.storage.ConfirmedBlock.NumPartitions.verify|verify} messages.
                 * @param message NumPartitions message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: solana.storage.ConfirmedBlock.INumPartitions, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified NumPartitions message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.NumPartitions.verify|verify} messages.
                 * @param message NumPartitions message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encodeDelimited(message: solana.storage.ConfirmedBlock.INumPartitions, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a NumPartitions message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns NumPartitions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): solana.storage.ConfirmedBlock.NumPartitions;

                /**
                 * Decodes a NumPartitions message from the specified reader or buffer, length delimited.
                 * @param reader Reader or buffer to decode from
                 * @returns NumPartitions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): solana.storage.ConfirmedBlock.NumPartitions;

                /**
                 * Verifies a NumPartitions message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a NumPartitions message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns NumPartitions
                 */
                public static fromObject(object: { [k: string]: any }): solana.storage.ConfirmedBlock.NumPartitions;

                /**
                 * Creates a plain object from a NumPartitions message. Also converts values to other types if specified.
                 * @param message NumPartitions
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: solana.storage.ConfirmedBlock.NumPartitions, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this NumPartitions to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };

                /**
                 * Gets the default type url for NumPartitions
                 * @param [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns The default type url
                 */
                public static getTypeUrl(typeUrlPrefix?: string): string;
            }
        }
    }
}
