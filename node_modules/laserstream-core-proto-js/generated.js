/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.geyser = (function() {

    /**
     * Namespace geyser.
     * @exports geyser
     * @namespace
     */
    var geyser = {};

    geyser.Geyser = (function() {

        /**
         * Constructs a new Geyser service.
         * @memberof geyser
         * @classdesc Represents a Geyser
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Geyser(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Geyser.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Geyser;

        /**
         * Creates new Geyser service using the specified rpc implementation.
         * @function create
         * @memberof geyser.Geyser
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {Geyser} RPC service. Useful where requests and/or responses are streamed.
         */
        Geyser.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link geyser.Geyser#subscribe}.
         * @memberof geyser.Geyser
         * @typedef SubscribeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {geyser.SubscribeUpdate} [response] SubscribeUpdate
         */

        /**
         * Calls Subscribe.
         * @function subscribe
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.ISubscribeRequest} request SubscribeRequest message or plain object
         * @param {geyser.Geyser.SubscribeCallback} callback Node-style callback called with the error, if any, and SubscribeUpdate
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Geyser.prototype.subscribe = function subscribe(request, callback) {
            return this.rpcCall(subscribe, $root.geyser.SubscribeRequest, $root.geyser.SubscribeUpdate, request, callback);
        }, "name", { value: "Subscribe" });

        /**
         * Calls Subscribe.
         * @function subscribe
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.ISubscribeRequest} request SubscribeRequest message or plain object
         * @returns {Promise<geyser.SubscribeUpdate>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link geyser.Geyser#subscribePreprocessed}.
         * @memberof geyser.Geyser
         * @typedef SubscribePreprocessedCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {geyser.SubscribePreprocessedUpdate} [response] SubscribePreprocessedUpdate
         */

        /**
         * Calls SubscribePreprocessed.
         * @function subscribePreprocessed
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.ISubscribePreprocessedRequest} request SubscribePreprocessedRequest message or plain object
         * @param {geyser.Geyser.SubscribePreprocessedCallback} callback Node-style callback called with the error, if any, and SubscribePreprocessedUpdate
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Geyser.prototype.subscribePreprocessed = function subscribePreprocessed(request, callback) {
            return this.rpcCall(subscribePreprocessed, $root.geyser.SubscribePreprocessedRequest, $root.geyser.SubscribePreprocessedUpdate, request, callback);
        }, "name", { value: "SubscribePreprocessed" });

        /**
         * Calls SubscribePreprocessed.
         * @function subscribePreprocessed
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.ISubscribePreprocessedRequest} request SubscribePreprocessedRequest message or plain object
         * @returns {Promise<geyser.SubscribePreprocessedUpdate>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link geyser.Geyser#subscribeReplayInfo}.
         * @memberof geyser.Geyser
         * @typedef SubscribeReplayInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {geyser.SubscribeReplayInfoResponse} [response] SubscribeReplayInfoResponse
         */

        /**
         * Calls SubscribeReplayInfo.
         * @function subscribeReplayInfo
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.ISubscribeReplayInfoRequest} request SubscribeReplayInfoRequest message or plain object
         * @param {geyser.Geyser.SubscribeReplayInfoCallback} callback Node-style callback called with the error, if any, and SubscribeReplayInfoResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Geyser.prototype.subscribeReplayInfo = function subscribeReplayInfo(request, callback) {
            return this.rpcCall(subscribeReplayInfo, $root.geyser.SubscribeReplayInfoRequest, $root.geyser.SubscribeReplayInfoResponse, request, callback);
        }, "name", { value: "SubscribeReplayInfo" });

        /**
         * Calls SubscribeReplayInfo.
         * @function subscribeReplayInfo
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.ISubscribeReplayInfoRequest} request SubscribeReplayInfoRequest message or plain object
         * @returns {Promise<geyser.SubscribeReplayInfoResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link geyser.Geyser#ping}.
         * @memberof geyser.Geyser
         * @typedef PingCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {geyser.PongResponse} [response] PongResponse
         */

        /**
         * Calls Ping.
         * @function ping
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.IPingRequest} request PingRequest message or plain object
         * @param {geyser.Geyser.PingCallback} callback Node-style callback called with the error, if any, and PongResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Geyser.prototype.ping = function ping(request, callback) {
            return this.rpcCall(ping, $root.geyser.PingRequest, $root.geyser.PongResponse, request, callback);
        }, "name", { value: "Ping" });

        /**
         * Calls Ping.
         * @function ping
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.IPingRequest} request PingRequest message or plain object
         * @returns {Promise<geyser.PongResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link geyser.Geyser#getLatestBlockhash}.
         * @memberof geyser.Geyser
         * @typedef GetLatestBlockhashCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {geyser.GetLatestBlockhashResponse} [response] GetLatestBlockhashResponse
         */

        /**
         * Calls GetLatestBlockhash.
         * @function getLatestBlockhash
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.IGetLatestBlockhashRequest} request GetLatestBlockhashRequest message or plain object
         * @param {geyser.Geyser.GetLatestBlockhashCallback} callback Node-style callback called with the error, if any, and GetLatestBlockhashResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Geyser.prototype.getLatestBlockhash = function getLatestBlockhash(request, callback) {
            return this.rpcCall(getLatestBlockhash, $root.geyser.GetLatestBlockhashRequest, $root.geyser.GetLatestBlockhashResponse, request, callback);
        }, "name", { value: "GetLatestBlockhash" });

        /**
         * Calls GetLatestBlockhash.
         * @function getLatestBlockhash
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.IGetLatestBlockhashRequest} request GetLatestBlockhashRequest message or plain object
         * @returns {Promise<geyser.GetLatestBlockhashResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link geyser.Geyser#getBlockHeight}.
         * @memberof geyser.Geyser
         * @typedef GetBlockHeightCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {geyser.GetBlockHeightResponse} [response] GetBlockHeightResponse
         */

        /**
         * Calls GetBlockHeight.
         * @function getBlockHeight
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.IGetBlockHeightRequest} request GetBlockHeightRequest message or plain object
         * @param {geyser.Geyser.GetBlockHeightCallback} callback Node-style callback called with the error, if any, and GetBlockHeightResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Geyser.prototype.getBlockHeight = function getBlockHeight(request, callback) {
            return this.rpcCall(getBlockHeight, $root.geyser.GetBlockHeightRequest, $root.geyser.GetBlockHeightResponse, request, callback);
        }, "name", { value: "GetBlockHeight" });

        /**
         * Calls GetBlockHeight.
         * @function getBlockHeight
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.IGetBlockHeightRequest} request GetBlockHeightRequest message or plain object
         * @returns {Promise<geyser.GetBlockHeightResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link geyser.Geyser#getSlot}.
         * @memberof geyser.Geyser
         * @typedef GetSlotCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {geyser.GetSlotResponse} [response] GetSlotResponse
         */

        /**
         * Calls GetSlot.
         * @function getSlot
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.IGetSlotRequest} request GetSlotRequest message or plain object
         * @param {geyser.Geyser.GetSlotCallback} callback Node-style callback called with the error, if any, and GetSlotResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Geyser.prototype.getSlot = function getSlot(request, callback) {
            return this.rpcCall(getSlot, $root.geyser.GetSlotRequest, $root.geyser.GetSlotResponse, request, callback);
        }, "name", { value: "GetSlot" });

        /**
         * Calls GetSlot.
         * @function getSlot
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.IGetSlotRequest} request GetSlotRequest message or plain object
         * @returns {Promise<geyser.GetSlotResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link geyser.Geyser#isBlockhashValid}.
         * @memberof geyser.Geyser
         * @typedef IsBlockhashValidCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {geyser.IsBlockhashValidResponse} [response] IsBlockhashValidResponse
         */

        /**
         * Calls IsBlockhashValid.
         * @function isBlockhashValid
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.IIsBlockhashValidRequest} request IsBlockhashValidRequest message or plain object
         * @param {geyser.Geyser.IsBlockhashValidCallback} callback Node-style callback called with the error, if any, and IsBlockhashValidResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Geyser.prototype.isBlockhashValid = function isBlockhashValid(request, callback) {
            return this.rpcCall(isBlockhashValid, $root.geyser.IsBlockhashValidRequest, $root.geyser.IsBlockhashValidResponse, request, callback);
        }, "name", { value: "IsBlockhashValid" });

        /**
         * Calls IsBlockhashValid.
         * @function isBlockhashValid
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.IIsBlockhashValidRequest} request IsBlockhashValidRequest message or plain object
         * @returns {Promise<geyser.IsBlockhashValidResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link geyser.Geyser#getVersion}.
         * @memberof geyser.Geyser
         * @typedef GetVersionCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {geyser.GetVersionResponse} [response] GetVersionResponse
         */

        /**
         * Calls GetVersion.
         * @function getVersion
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.IGetVersionRequest} request GetVersionRequest message or plain object
         * @param {geyser.Geyser.GetVersionCallback} callback Node-style callback called with the error, if any, and GetVersionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Geyser.prototype.getVersion = function getVersion(request, callback) {
            return this.rpcCall(getVersion, $root.geyser.GetVersionRequest, $root.geyser.GetVersionResponse, request, callback);
        }, "name", { value: "GetVersion" });

        /**
         * Calls GetVersion.
         * @function getVersion
         * @memberof geyser.Geyser
         * @instance
         * @param {geyser.IGetVersionRequest} request GetVersionRequest message or plain object
         * @returns {Promise<geyser.GetVersionResponse>} Promise
         * @variation 2
         */

        return Geyser;
    })();

    geyser.SubscribePreprocessedRequest = (function() {

        /**
         * Properties of a SubscribePreprocessedRequest.
         * @memberof geyser
         * @interface ISubscribePreprocessedRequest
         * @property {Object.<string,geyser.ISubscribePreprocessedRequestFilterTransactions>|null} [transactions] SubscribePreprocessedRequest transactions
         * @property {geyser.ISubscribeRequestPing|null} [ping] SubscribePreprocessedRequest ping
         */

        /**
         * Constructs a new SubscribePreprocessedRequest.
         * @memberof geyser
         * @classdesc Represents a SubscribePreprocessedRequest.
         * @implements ISubscribePreprocessedRequest
         * @constructor
         * @param {geyser.ISubscribePreprocessedRequest=} [properties] Properties to set
         */
        function SubscribePreprocessedRequest(properties) {
            this.transactions = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribePreprocessedRequest transactions.
         * @member {Object.<string,geyser.ISubscribePreprocessedRequestFilterTransactions>} transactions
         * @memberof geyser.SubscribePreprocessedRequest
         * @instance
         */
        SubscribePreprocessedRequest.prototype.transactions = $util.emptyObject;

        /**
         * SubscribePreprocessedRequest ping.
         * @member {geyser.ISubscribeRequestPing|null|undefined} ping
         * @memberof geyser.SubscribePreprocessedRequest
         * @instance
         */
        SubscribePreprocessedRequest.prototype.ping = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribePreprocessedRequest _ping.
         * @member {"ping"|undefined} _ping
         * @memberof geyser.SubscribePreprocessedRequest
         * @instance
         */
        Object.defineProperty(SubscribePreprocessedRequest.prototype, "_ping", {
            get: $util.oneOfGetter($oneOfFields = ["ping"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribePreprocessedRequest instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribePreprocessedRequest
         * @static
         * @param {geyser.ISubscribePreprocessedRequest=} [properties] Properties to set
         * @returns {geyser.SubscribePreprocessedRequest} SubscribePreprocessedRequest instance
         */
        SubscribePreprocessedRequest.create = function create(properties) {
            return new SubscribePreprocessedRequest(properties);
        };

        /**
         * Encodes the specified SubscribePreprocessedRequest message. Does not implicitly {@link geyser.SubscribePreprocessedRequest.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribePreprocessedRequest
         * @static
         * @param {geyser.ISubscribePreprocessedRequest} message SubscribePreprocessedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribePreprocessedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transactions != null && Object.hasOwnProperty.call(message, "transactions"))
                for (var keys = Object.keys(message.transactions), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.geyser.SubscribePreprocessedRequestFilterTransactions.encode(message.transactions[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.ping != null && Object.hasOwnProperty.call(message, "ping"))
                $root.geyser.SubscribeRequestPing.encode(message.ping, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubscribePreprocessedRequest message, length delimited. Does not implicitly {@link geyser.SubscribePreprocessedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribePreprocessedRequest
         * @static
         * @param {geyser.ISubscribePreprocessedRequest} message SubscribePreprocessedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribePreprocessedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribePreprocessedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribePreprocessedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribePreprocessedRequest} SubscribePreprocessedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribePreprocessedRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribePreprocessedRequest(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (message.transactions === $util.emptyObject)
                            message.transactions = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.geyser.SubscribePreprocessedRequestFilterTransactions.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.transactions[key] = value;
                        break;
                    }
                case 2: {
                        message.ping = $root.geyser.SubscribeRequestPing.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribePreprocessedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribePreprocessedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribePreprocessedRequest} SubscribePreprocessedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribePreprocessedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribePreprocessedRequest message.
         * @function verify
         * @memberof geyser.SubscribePreprocessedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribePreprocessedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!$util.isObject(message.transactions))
                    return "transactions: object expected";
                var key = Object.keys(message.transactions);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.geyser.SubscribePreprocessedRequestFilterTransactions.verify(message.transactions[key[i]]);
                    if (error)
                        return "transactions." + error;
                }
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                properties._ping = 1;
                {
                    var error = $root.geyser.SubscribeRequestPing.verify(message.ping);
                    if (error)
                        return "ping." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SubscribePreprocessedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribePreprocessedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribePreprocessedRequest} SubscribePreprocessedRequest
         */
        SubscribePreprocessedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribePreprocessedRequest)
                return object;
            var message = new $root.geyser.SubscribePreprocessedRequest();
            if (object.transactions) {
                if (typeof object.transactions !== "object")
                    throw TypeError(".geyser.SubscribePreprocessedRequest.transactions: object expected");
                message.transactions = {};
                for (var keys = Object.keys(object.transactions), i = 0; i < keys.length; ++i) {
                    if (typeof object.transactions[keys[i]] !== "object")
                        throw TypeError(".geyser.SubscribePreprocessedRequest.transactions: object expected");
                    message.transactions[keys[i]] = $root.geyser.SubscribePreprocessedRequestFilterTransactions.fromObject(object.transactions[keys[i]]);
                }
            }
            if (object.ping != null) {
                if (typeof object.ping !== "object")
                    throw TypeError(".geyser.SubscribePreprocessedRequest.ping: object expected");
                message.ping = $root.geyser.SubscribeRequestPing.fromObject(object.ping);
            }
            return message;
        };

        /**
         * Creates a plain object from a SubscribePreprocessedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribePreprocessedRequest
         * @static
         * @param {geyser.SubscribePreprocessedRequest} message SubscribePreprocessedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribePreprocessedRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.transactions = {};
            var keys2;
            if (message.transactions && (keys2 = Object.keys(message.transactions)).length) {
                object.transactions = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.transactions[keys2[j]] = $root.geyser.SubscribePreprocessedRequestFilterTransactions.toObject(message.transactions[keys2[j]], options);
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                object.ping = $root.geyser.SubscribeRequestPing.toObject(message.ping, options);
                if (options.oneofs)
                    object._ping = "ping";
            }
            return object;
        };

        /**
         * Converts this SubscribePreprocessedRequest to JSON.
         * @function toJSON
         * @memberof geyser.SubscribePreprocessedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribePreprocessedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribePreprocessedRequest
         * @function getTypeUrl
         * @memberof geyser.SubscribePreprocessedRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribePreprocessedRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribePreprocessedRequest";
        };

        return SubscribePreprocessedRequest;
    })();

    geyser.SubscribePreprocessedRequestFilterTransactions = (function() {

        /**
         * Properties of a SubscribePreprocessedRequestFilterTransactions.
         * @memberof geyser
         * @interface ISubscribePreprocessedRequestFilterTransactions
         * @property {boolean|null} [vote] SubscribePreprocessedRequestFilterTransactions vote
         * @property {string|null} [signature] SubscribePreprocessedRequestFilterTransactions signature
         * @property {Array.<string>|null} [accountInclude] SubscribePreprocessedRequestFilterTransactions accountInclude
         * @property {Array.<string>|null} [accountExclude] SubscribePreprocessedRequestFilterTransactions accountExclude
         * @property {Array.<string>|null} [accountRequired] SubscribePreprocessedRequestFilterTransactions accountRequired
         */

        /**
         * Constructs a new SubscribePreprocessedRequestFilterTransactions.
         * @memberof geyser
         * @classdesc Represents a SubscribePreprocessedRequestFilterTransactions.
         * @implements ISubscribePreprocessedRequestFilterTransactions
         * @constructor
         * @param {geyser.ISubscribePreprocessedRequestFilterTransactions=} [properties] Properties to set
         */
        function SubscribePreprocessedRequestFilterTransactions(properties) {
            this.accountInclude = [];
            this.accountExclude = [];
            this.accountRequired = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribePreprocessedRequestFilterTransactions vote.
         * @member {boolean|null|undefined} vote
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @instance
         */
        SubscribePreprocessedRequestFilterTransactions.prototype.vote = null;

        /**
         * SubscribePreprocessedRequestFilterTransactions signature.
         * @member {string|null|undefined} signature
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @instance
         */
        SubscribePreprocessedRequestFilterTransactions.prototype.signature = null;

        /**
         * SubscribePreprocessedRequestFilterTransactions accountInclude.
         * @member {Array.<string>} accountInclude
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @instance
         */
        SubscribePreprocessedRequestFilterTransactions.prototype.accountInclude = $util.emptyArray;

        /**
         * SubscribePreprocessedRequestFilterTransactions accountExclude.
         * @member {Array.<string>} accountExclude
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @instance
         */
        SubscribePreprocessedRequestFilterTransactions.prototype.accountExclude = $util.emptyArray;

        /**
         * SubscribePreprocessedRequestFilterTransactions accountRequired.
         * @member {Array.<string>} accountRequired
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @instance
         */
        SubscribePreprocessedRequestFilterTransactions.prototype.accountRequired = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribePreprocessedRequestFilterTransactions _vote.
         * @member {"vote"|undefined} _vote
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @instance
         */
        Object.defineProperty(SubscribePreprocessedRequestFilterTransactions.prototype, "_vote", {
            get: $util.oneOfGetter($oneOfFields = ["vote"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * SubscribePreprocessedRequestFilterTransactions _signature.
         * @member {"signature"|undefined} _signature
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @instance
         */
        Object.defineProperty(SubscribePreprocessedRequestFilterTransactions.prototype, "_signature", {
            get: $util.oneOfGetter($oneOfFields = ["signature"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribePreprocessedRequestFilterTransactions instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @static
         * @param {geyser.ISubscribePreprocessedRequestFilterTransactions=} [properties] Properties to set
         * @returns {geyser.SubscribePreprocessedRequestFilterTransactions} SubscribePreprocessedRequestFilterTransactions instance
         */
        SubscribePreprocessedRequestFilterTransactions.create = function create(properties) {
            return new SubscribePreprocessedRequestFilterTransactions(properties);
        };

        /**
         * Encodes the specified SubscribePreprocessedRequestFilterTransactions message. Does not implicitly {@link geyser.SubscribePreprocessedRequestFilterTransactions.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @static
         * @param {geyser.ISubscribePreprocessedRequestFilterTransactions} message SubscribePreprocessedRequestFilterTransactions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribePreprocessedRequestFilterTransactions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vote != null && Object.hasOwnProperty.call(message, "vote"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.vote);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.signature);
            if (message.accountInclude != null && message.accountInclude.length)
                for (var i = 0; i < message.accountInclude.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.accountInclude[i]);
            if (message.accountExclude != null && message.accountExclude.length)
                for (var i = 0; i < message.accountExclude.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.accountExclude[i]);
            if (message.accountRequired != null && message.accountRequired.length)
                for (var i = 0; i < message.accountRequired.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.accountRequired[i]);
            return writer;
        };

        /**
         * Encodes the specified SubscribePreprocessedRequestFilterTransactions message, length delimited. Does not implicitly {@link geyser.SubscribePreprocessedRequestFilterTransactions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @static
         * @param {geyser.ISubscribePreprocessedRequestFilterTransactions} message SubscribePreprocessedRequestFilterTransactions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribePreprocessedRequestFilterTransactions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribePreprocessedRequestFilterTransactions message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribePreprocessedRequestFilterTransactions} SubscribePreprocessedRequestFilterTransactions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribePreprocessedRequestFilterTransactions.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribePreprocessedRequestFilterTransactions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.vote = reader.bool();
                        break;
                    }
                case 2: {
                        message.signature = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.accountInclude && message.accountInclude.length))
                            message.accountInclude = [];
                        message.accountInclude.push(reader.string());
                        break;
                    }
                case 4: {
                        if (!(message.accountExclude && message.accountExclude.length))
                            message.accountExclude = [];
                        message.accountExclude.push(reader.string());
                        break;
                    }
                case 5: {
                        if (!(message.accountRequired && message.accountRequired.length))
                            message.accountRequired = [];
                        message.accountRequired.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribePreprocessedRequestFilterTransactions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribePreprocessedRequestFilterTransactions} SubscribePreprocessedRequestFilterTransactions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribePreprocessedRequestFilterTransactions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribePreprocessedRequestFilterTransactions message.
         * @function verify
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribePreprocessedRequestFilterTransactions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.vote != null && message.hasOwnProperty("vote")) {
                properties._vote = 1;
                if (typeof message.vote !== "boolean")
                    return "vote: boolean expected";
            }
            if (message.signature != null && message.hasOwnProperty("signature")) {
                properties._signature = 1;
                if (!$util.isString(message.signature))
                    return "signature: string expected";
            }
            if (message.accountInclude != null && message.hasOwnProperty("accountInclude")) {
                if (!Array.isArray(message.accountInclude))
                    return "accountInclude: array expected";
                for (var i = 0; i < message.accountInclude.length; ++i)
                    if (!$util.isString(message.accountInclude[i]))
                        return "accountInclude: string[] expected";
            }
            if (message.accountExclude != null && message.hasOwnProperty("accountExclude")) {
                if (!Array.isArray(message.accountExclude))
                    return "accountExclude: array expected";
                for (var i = 0; i < message.accountExclude.length; ++i)
                    if (!$util.isString(message.accountExclude[i]))
                        return "accountExclude: string[] expected";
            }
            if (message.accountRequired != null && message.hasOwnProperty("accountRequired")) {
                if (!Array.isArray(message.accountRequired))
                    return "accountRequired: array expected";
                for (var i = 0; i < message.accountRequired.length; ++i)
                    if (!$util.isString(message.accountRequired[i]))
                        return "accountRequired: string[] expected";
            }
            return null;
        };

        /**
         * Creates a SubscribePreprocessedRequestFilterTransactions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribePreprocessedRequestFilterTransactions} SubscribePreprocessedRequestFilterTransactions
         */
        SubscribePreprocessedRequestFilterTransactions.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribePreprocessedRequestFilterTransactions)
                return object;
            var message = new $root.geyser.SubscribePreprocessedRequestFilterTransactions();
            if (object.vote != null)
                message.vote = Boolean(object.vote);
            if (object.signature != null)
                message.signature = String(object.signature);
            if (object.accountInclude) {
                if (!Array.isArray(object.accountInclude))
                    throw TypeError(".geyser.SubscribePreprocessedRequestFilterTransactions.accountInclude: array expected");
                message.accountInclude = [];
                for (var i = 0; i < object.accountInclude.length; ++i)
                    message.accountInclude[i] = String(object.accountInclude[i]);
            }
            if (object.accountExclude) {
                if (!Array.isArray(object.accountExclude))
                    throw TypeError(".geyser.SubscribePreprocessedRequestFilterTransactions.accountExclude: array expected");
                message.accountExclude = [];
                for (var i = 0; i < object.accountExclude.length; ++i)
                    message.accountExclude[i] = String(object.accountExclude[i]);
            }
            if (object.accountRequired) {
                if (!Array.isArray(object.accountRequired))
                    throw TypeError(".geyser.SubscribePreprocessedRequestFilterTransactions.accountRequired: array expected");
                message.accountRequired = [];
                for (var i = 0; i < object.accountRequired.length; ++i)
                    message.accountRequired[i] = String(object.accountRequired[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a SubscribePreprocessedRequestFilterTransactions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @static
         * @param {geyser.SubscribePreprocessedRequestFilterTransactions} message SubscribePreprocessedRequestFilterTransactions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribePreprocessedRequestFilterTransactions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.accountInclude = [];
                object.accountExclude = [];
                object.accountRequired = [];
            }
            if (message.vote != null && message.hasOwnProperty("vote")) {
                object.vote = message.vote;
                if (options.oneofs)
                    object._vote = "vote";
            }
            if (message.signature != null && message.hasOwnProperty("signature")) {
                object.signature = message.signature;
                if (options.oneofs)
                    object._signature = "signature";
            }
            if (message.accountInclude && message.accountInclude.length) {
                object.accountInclude = [];
                for (var j = 0; j < message.accountInclude.length; ++j)
                    object.accountInclude[j] = message.accountInclude[j];
            }
            if (message.accountExclude && message.accountExclude.length) {
                object.accountExclude = [];
                for (var j = 0; j < message.accountExclude.length; ++j)
                    object.accountExclude[j] = message.accountExclude[j];
            }
            if (message.accountRequired && message.accountRequired.length) {
                object.accountRequired = [];
                for (var j = 0; j < message.accountRequired.length; ++j)
                    object.accountRequired[j] = message.accountRequired[j];
            }
            return object;
        };

        /**
         * Converts this SubscribePreprocessedRequestFilterTransactions to JSON.
         * @function toJSON
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribePreprocessedRequestFilterTransactions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribePreprocessedRequestFilterTransactions
         * @function getTypeUrl
         * @memberof geyser.SubscribePreprocessedRequestFilterTransactions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribePreprocessedRequestFilterTransactions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribePreprocessedRequestFilterTransactions";
        };

        return SubscribePreprocessedRequestFilterTransactions;
    })();

    geyser.SubscribePreprocessedUpdate = (function() {

        /**
         * Properties of a SubscribePreprocessedUpdate.
         * @memberof geyser
         * @interface ISubscribePreprocessedUpdate
         * @property {Array.<string>|null} [filters] SubscribePreprocessedUpdate filters
         * @property {geyser.ISubscribePreprocessedTransaction|null} [transaction] SubscribePreprocessedUpdate transaction
         * @property {geyser.ISubscribeUpdatePing|null} [ping] SubscribePreprocessedUpdate ping
         * @property {geyser.ISubscribeUpdatePong|null} [pong] SubscribePreprocessedUpdate pong
         * @property {google.protobuf.ITimestamp|null} [createdAt] SubscribePreprocessedUpdate createdAt
         */

        /**
         * Constructs a new SubscribePreprocessedUpdate.
         * @memberof geyser
         * @classdesc Represents a SubscribePreprocessedUpdate.
         * @implements ISubscribePreprocessedUpdate
         * @constructor
         * @param {geyser.ISubscribePreprocessedUpdate=} [properties] Properties to set
         */
        function SubscribePreprocessedUpdate(properties) {
            this.filters = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribePreprocessedUpdate filters.
         * @member {Array.<string>} filters
         * @memberof geyser.SubscribePreprocessedUpdate
         * @instance
         */
        SubscribePreprocessedUpdate.prototype.filters = $util.emptyArray;

        /**
         * SubscribePreprocessedUpdate transaction.
         * @member {geyser.ISubscribePreprocessedTransaction|null|undefined} transaction
         * @memberof geyser.SubscribePreprocessedUpdate
         * @instance
         */
        SubscribePreprocessedUpdate.prototype.transaction = null;

        /**
         * SubscribePreprocessedUpdate ping.
         * @member {geyser.ISubscribeUpdatePing|null|undefined} ping
         * @memberof geyser.SubscribePreprocessedUpdate
         * @instance
         */
        SubscribePreprocessedUpdate.prototype.ping = null;

        /**
         * SubscribePreprocessedUpdate pong.
         * @member {geyser.ISubscribeUpdatePong|null|undefined} pong
         * @memberof geyser.SubscribePreprocessedUpdate
         * @instance
         */
        SubscribePreprocessedUpdate.prototype.pong = null;

        /**
         * SubscribePreprocessedUpdate createdAt.
         * @member {google.protobuf.ITimestamp|null|undefined} createdAt
         * @memberof geyser.SubscribePreprocessedUpdate
         * @instance
         */
        SubscribePreprocessedUpdate.prototype.createdAt = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribePreprocessedUpdate updateOneof.
         * @member {"transaction"|"ping"|"pong"|undefined} updateOneof
         * @memberof geyser.SubscribePreprocessedUpdate
         * @instance
         */
        Object.defineProperty(SubscribePreprocessedUpdate.prototype, "updateOneof", {
            get: $util.oneOfGetter($oneOfFields = ["transaction", "ping", "pong"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribePreprocessedUpdate instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribePreprocessedUpdate
         * @static
         * @param {geyser.ISubscribePreprocessedUpdate=} [properties] Properties to set
         * @returns {geyser.SubscribePreprocessedUpdate} SubscribePreprocessedUpdate instance
         */
        SubscribePreprocessedUpdate.create = function create(properties) {
            return new SubscribePreprocessedUpdate(properties);
        };

        /**
         * Encodes the specified SubscribePreprocessedUpdate message. Does not implicitly {@link geyser.SubscribePreprocessedUpdate.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribePreprocessedUpdate
         * @static
         * @param {geyser.ISubscribePreprocessedUpdate} message SubscribePreprocessedUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribePreprocessedUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filters != null && message.filters.length)
                for (var i = 0; i < message.filters.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.filters[i]);
            if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                $root.geyser.SubscribePreprocessedTransaction.encode(message.transaction, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.ping != null && Object.hasOwnProperty.call(message, "ping"))
                $root.geyser.SubscribeUpdatePing.encode(message.ping, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.pong != null && Object.hasOwnProperty.call(message, "pong"))
                $root.geyser.SubscribeUpdatePong.encode(message.pong, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.createdAt != null && Object.hasOwnProperty.call(message, "createdAt"))
                $root.google.protobuf.Timestamp.encode(message.createdAt, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubscribePreprocessedUpdate message, length delimited. Does not implicitly {@link geyser.SubscribePreprocessedUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribePreprocessedUpdate
         * @static
         * @param {geyser.ISubscribePreprocessedUpdate} message SubscribePreprocessedUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribePreprocessedUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribePreprocessedUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribePreprocessedUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribePreprocessedUpdate} SubscribePreprocessedUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribePreprocessedUpdate.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribePreprocessedUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.filters && message.filters.length))
                            message.filters = [];
                        message.filters.push(reader.string());
                        break;
                    }
                case 2: {
                        message.transaction = $root.geyser.SubscribePreprocessedTransaction.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.ping = $root.geyser.SubscribeUpdatePing.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.pong = $root.geyser.SubscribeUpdatePong.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.createdAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribePreprocessedUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribePreprocessedUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribePreprocessedUpdate} SubscribePreprocessedUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribePreprocessedUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribePreprocessedUpdate message.
         * @function verify
         * @memberof geyser.SubscribePreprocessedUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribePreprocessedUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.filters != null && message.hasOwnProperty("filters")) {
                if (!Array.isArray(message.filters))
                    return "filters: array expected";
                for (var i = 0; i < message.filters.length; ++i)
                    if (!$util.isString(message.filters[i]))
                        return "filters: string[] expected";
            }
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                properties.updateOneof = 1;
                {
                    var error = $root.geyser.SubscribePreprocessedTransaction.verify(message.transaction);
                    if (error)
                        return "transaction." + error;
                }
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                if (properties.updateOneof === 1)
                    return "updateOneof: multiple values";
                properties.updateOneof = 1;
                {
                    var error = $root.geyser.SubscribeUpdatePing.verify(message.ping);
                    if (error)
                        return "ping." + error;
                }
            }
            if (message.pong != null && message.hasOwnProperty("pong")) {
                if (properties.updateOneof === 1)
                    return "updateOneof: multiple values";
                properties.updateOneof = 1;
                {
                    var error = $root.geyser.SubscribeUpdatePong.verify(message.pong);
                    if (error)
                        return "pong." + error;
                }
            }
            if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                var error = $root.google.protobuf.Timestamp.verify(message.createdAt);
                if (error)
                    return "createdAt." + error;
            }
            return null;
        };

        /**
         * Creates a SubscribePreprocessedUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribePreprocessedUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribePreprocessedUpdate} SubscribePreprocessedUpdate
         */
        SubscribePreprocessedUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribePreprocessedUpdate)
                return object;
            var message = new $root.geyser.SubscribePreprocessedUpdate();
            if (object.filters) {
                if (!Array.isArray(object.filters))
                    throw TypeError(".geyser.SubscribePreprocessedUpdate.filters: array expected");
                message.filters = [];
                for (var i = 0; i < object.filters.length; ++i)
                    message.filters[i] = String(object.filters[i]);
            }
            if (object.transaction != null) {
                if (typeof object.transaction !== "object")
                    throw TypeError(".geyser.SubscribePreprocessedUpdate.transaction: object expected");
                message.transaction = $root.geyser.SubscribePreprocessedTransaction.fromObject(object.transaction);
            }
            if (object.ping != null) {
                if (typeof object.ping !== "object")
                    throw TypeError(".geyser.SubscribePreprocessedUpdate.ping: object expected");
                message.ping = $root.geyser.SubscribeUpdatePing.fromObject(object.ping);
            }
            if (object.pong != null) {
                if (typeof object.pong !== "object")
                    throw TypeError(".geyser.SubscribePreprocessedUpdate.pong: object expected");
                message.pong = $root.geyser.SubscribeUpdatePong.fromObject(object.pong);
            }
            if (object.createdAt != null) {
                if (typeof object.createdAt !== "object")
                    throw TypeError(".geyser.SubscribePreprocessedUpdate.createdAt: object expected");
                message.createdAt = $root.google.protobuf.Timestamp.fromObject(object.createdAt);
            }
            return message;
        };

        /**
         * Creates a plain object from a SubscribePreprocessedUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribePreprocessedUpdate
         * @static
         * @param {geyser.SubscribePreprocessedUpdate} message SubscribePreprocessedUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribePreprocessedUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.filters = [];
            if (options.defaults)
                object.createdAt = null;
            if (message.filters && message.filters.length) {
                object.filters = [];
                for (var j = 0; j < message.filters.length; ++j)
                    object.filters[j] = message.filters[j];
            }
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                object.transaction = $root.geyser.SubscribePreprocessedTransaction.toObject(message.transaction, options);
                if (options.oneofs)
                    object.updateOneof = "transaction";
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                object.ping = $root.geyser.SubscribeUpdatePing.toObject(message.ping, options);
                if (options.oneofs)
                    object.updateOneof = "ping";
            }
            if (message.pong != null && message.hasOwnProperty("pong")) {
                object.pong = $root.geyser.SubscribeUpdatePong.toObject(message.pong, options);
                if (options.oneofs)
                    object.updateOneof = "pong";
            }
            if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                object.createdAt = $root.google.protobuf.Timestamp.toObject(message.createdAt, options);
            return object;
        };

        /**
         * Converts this SubscribePreprocessedUpdate to JSON.
         * @function toJSON
         * @memberof geyser.SubscribePreprocessedUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribePreprocessedUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribePreprocessedUpdate
         * @function getTypeUrl
         * @memberof geyser.SubscribePreprocessedUpdate
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribePreprocessedUpdate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribePreprocessedUpdate";
        };

        return SubscribePreprocessedUpdate;
    })();

    geyser.SubscribePreprocessedTransaction = (function() {

        /**
         * Properties of a SubscribePreprocessedTransaction.
         * @memberof geyser
         * @interface ISubscribePreprocessedTransaction
         * @property {geyser.ISubscribePreprocessedTransactionInfo|null} [transaction] SubscribePreprocessedTransaction transaction
         * @property {number|Long|null} [slot] SubscribePreprocessedTransaction slot
         */

        /**
         * Constructs a new SubscribePreprocessedTransaction.
         * @memberof geyser
         * @classdesc Represents a SubscribePreprocessedTransaction.
         * @implements ISubscribePreprocessedTransaction
         * @constructor
         * @param {geyser.ISubscribePreprocessedTransaction=} [properties] Properties to set
         */
        function SubscribePreprocessedTransaction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribePreprocessedTransaction transaction.
         * @member {geyser.ISubscribePreprocessedTransactionInfo|null|undefined} transaction
         * @memberof geyser.SubscribePreprocessedTransaction
         * @instance
         */
        SubscribePreprocessedTransaction.prototype.transaction = null;

        /**
         * SubscribePreprocessedTransaction slot.
         * @member {number|Long} slot
         * @memberof geyser.SubscribePreprocessedTransaction
         * @instance
         */
        SubscribePreprocessedTransaction.prototype.slot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SubscribePreprocessedTransaction instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribePreprocessedTransaction
         * @static
         * @param {geyser.ISubscribePreprocessedTransaction=} [properties] Properties to set
         * @returns {geyser.SubscribePreprocessedTransaction} SubscribePreprocessedTransaction instance
         */
        SubscribePreprocessedTransaction.create = function create(properties) {
            return new SubscribePreprocessedTransaction(properties);
        };

        /**
         * Encodes the specified SubscribePreprocessedTransaction message. Does not implicitly {@link geyser.SubscribePreprocessedTransaction.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribePreprocessedTransaction
         * @static
         * @param {geyser.ISubscribePreprocessedTransaction} message SubscribePreprocessedTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribePreprocessedTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                $root.geyser.SubscribePreprocessedTransactionInfo.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.slot);
            return writer;
        };

        /**
         * Encodes the specified SubscribePreprocessedTransaction message, length delimited. Does not implicitly {@link geyser.SubscribePreprocessedTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribePreprocessedTransaction
         * @static
         * @param {geyser.ISubscribePreprocessedTransaction} message SubscribePreprocessedTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribePreprocessedTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribePreprocessedTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribePreprocessedTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribePreprocessedTransaction} SubscribePreprocessedTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribePreprocessedTransaction.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribePreprocessedTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.transaction = $root.geyser.SubscribePreprocessedTransactionInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.slot = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribePreprocessedTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribePreprocessedTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribePreprocessedTransaction} SubscribePreprocessedTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribePreprocessedTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribePreprocessedTransaction message.
         * @function verify
         * @memberof geyser.SubscribePreprocessedTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribePreprocessedTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                var error = $root.geyser.SubscribePreprocessedTransactionInfo.verify(message.transaction);
                if (error)
                    return "transaction." + error;
            }
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot) && !(message.slot && $util.isInteger(message.slot.low) && $util.isInteger(message.slot.high)))
                    return "slot: integer|Long expected";
            return null;
        };

        /**
         * Creates a SubscribePreprocessedTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribePreprocessedTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribePreprocessedTransaction} SubscribePreprocessedTransaction
         */
        SubscribePreprocessedTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribePreprocessedTransaction)
                return object;
            var message = new $root.geyser.SubscribePreprocessedTransaction();
            if (object.transaction != null) {
                if (typeof object.transaction !== "object")
                    throw TypeError(".geyser.SubscribePreprocessedTransaction.transaction: object expected");
                message.transaction = $root.geyser.SubscribePreprocessedTransactionInfo.fromObject(object.transaction);
            }
            if (object.slot != null)
                if ($util.Long)
                    (message.slot = $util.Long.fromValue(object.slot)).unsigned = true;
                else if (typeof object.slot === "string")
                    message.slot = parseInt(object.slot, 10);
                else if (typeof object.slot === "number")
                    message.slot = object.slot;
                else if (typeof object.slot === "object")
                    message.slot = new $util.LongBits(object.slot.low >>> 0, object.slot.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SubscribePreprocessedTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribePreprocessedTransaction
         * @static
         * @param {geyser.SubscribePreprocessedTransaction} message SubscribePreprocessedTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribePreprocessedTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.transaction = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.slot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.slot = options.longs === String ? "0" : 0;
            }
            if (message.transaction != null && message.hasOwnProperty("transaction"))
                object.transaction = $root.geyser.SubscribePreprocessedTransactionInfo.toObject(message.transaction, options);
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (typeof message.slot === "number")
                    object.slot = options.longs === String ? String(message.slot) : message.slot;
                else
                    object.slot = options.longs === String ? $util.Long.prototype.toString.call(message.slot) : options.longs === Number ? new $util.LongBits(message.slot.low >>> 0, message.slot.high >>> 0).toNumber(true) : message.slot;
            return object;
        };

        /**
         * Converts this SubscribePreprocessedTransaction to JSON.
         * @function toJSON
         * @memberof geyser.SubscribePreprocessedTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribePreprocessedTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribePreprocessedTransaction
         * @function getTypeUrl
         * @memberof geyser.SubscribePreprocessedTransaction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribePreprocessedTransaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribePreprocessedTransaction";
        };

        return SubscribePreprocessedTransaction;
    })();

    geyser.SubscribePreprocessedTransactionInfo = (function() {

        /**
         * Properties of a SubscribePreprocessedTransactionInfo.
         * @memberof geyser
         * @interface ISubscribePreprocessedTransactionInfo
         * @property {Uint8Array|null} [signature] SubscribePreprocessedTransactionInfo signature
         * @property {boolean|null} [isVote] SubscribePreprocessedTransactionInfo isVote
         * @property {solana.storage.ConfirmedBlock.ITransaction|null} [transaction] SubscribePreprocessedTransactionInfo transaction
         */

        /**
         * Constructs a new SubscribePreprocessedTransactionInfo.
         * @memberof geyser
         * @classdesc Represents a SubscribePreprocessedTransactionInfo.
         * @implements ISubscribePreprocessedTransactionInfo
         * @constructor
         * @param {geyser.ISubscribePreprocessedTransactionInfo=} [properties] Properties to set
         */
        function SubscribePreprocessedTransactionInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribePreprocessedTransactionInfo signature.
         * @member {Uint8Array} signature
         * @memberof geyser.SubscribePreprocessedTransactionInfo
         * @instance
         */
        SubscribePreprocessedTransactionInfo.prototype.signature = $util.newBuffer([]);

        /**
         * SubscribePreprocessedTransactionInfo isVote.
         * @member {boolean} isVote
         * @memberof geyser.SubscribePreprocessedTransactionInfo
         * @instance
         */
        SubscribePreprocessedTransactionInfo.prototype.isVote = false;

        /**
         * SubscribePreprocessedTransactionInfo transaction.
         * @member {solana.storage.ConfirmedBlock.ITransaction|null|undefined} transaction
         * @memberof geyser.SubscribePreprocessedTransactionInfo
         * @instance
         */
        SubscribePreprocessedTransactionInfo.prototype.transaction = null;

        /**
         * Creates a new SubscribePreprocessedTransactionInfo instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribePreprocessedTransactionInfo
         * @static
         * @param {geyser.ISubscribePreprocessedTransactionInfo=} [properties] Properties to set
         * @returns {geyser.SubscribePreprocessedTransactionInfo} SubscribePreprocessedTransactionInfo instance
         */
        SubscribePreprocessedTransactionInfo.create = function create(properties) {
            return new SubscribePreprocessedTransactionInfo(properties);
        };

        /**
         * Encodes the specified SubscribePreprocessedTransactionInfo message. Does not implicitly {@link geyser.SubscribePreprocessedTransactionInfo.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribePreprocessedTransactionInfo
         * @static
         * @param {geyser.ISubscribePreprocessedTransactionInfo} message SubscribePreprocessedTransactionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribePreprocessedTransactionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
            if (message.isVote != null && Object.hasOwnProperty.call(message, "isVote"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isVote);
            if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                $root.solana.storage.ConfirmedBlock.Transaction.encode(message.transaction, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubscribePreprocessedTransactionInfo message, length delimited. Does not implicitly {@link geyser.SubscribePreprocessedTransactionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribePreprocessedTransactionInfo
         * @static
         * @param {geyser.ISubscribePreprocessedTransactionInfo} message SubscribePreprocessedTransactionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribePreprocessedTransactionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribePreprocessedTransactionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribePreprocessedTransactionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribePreprocessedTransactionInfo} SubscribePreprocessedTransactionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribePreprocessedTransactionInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribePreprocessedTransactionInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.signature = reader.bytes();
                        break;
                    }
                case 2: {
                        message.isVote = reader.bool();
                        break;
                    }
                case 3: {
                        message.transaction = $root.solana.storage.ConfirmedBlock.Transaction.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribePreprocessedTransactionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribePreprocessedTransactionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribePreprocessedTransactionInfo} SubscribePreprocessedTransactionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribePreprocessedTransactionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribePreprocessedTransactionInfo message.
         * @function verify
         * @memberof geyser.SubscribePreprocessedTransactionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribePreprocessedTransactionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.isVote != null && message.hasOwnProperty("isVote"))
                if (typeof message.isVote !== "boolean")
                    return "isVote: boolean expected";
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                var error = $root.solana.storage.ConfirmedBlock.Transaction.verify(message.transaction);
                if (error)
                    return "transaction." + error;
            }
            return null;
        };

        /**
         * Creates a SubscribePreprocessedTransactionInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribePreprocessedTransactionInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribePreprocessedTransactionInfo} SubscribePreprocessedTransactionInfo
         */
        SubscribePreprocessedTransactionInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribePreprocessedTransactionInfo)
                return object;
            var message = new $root.geyser.SubscribePreprocessedTransactionInfo();
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length >= 0)
                    message.signature = object.signature;
            if (object.isVote != null)
                message.isVote = Boolean(object.isVote);
            if (object.transaction != null) {
                if (typeof object.transaction !== "object")
                    throw TypeError(".geyser.SubscribePreprocessedTransactionInfo.transaction: object expected");
                message.transaction = $root.solana.storage.ConfirmedBlock.Transaction.fromObject(object.transaction);
            }
            return message;
        };

        /**
         * Creates a plain object from a SubscribePreprocessedTransactionInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribePreprocessedTransactionInfo
         * @static
         * @param {geyser.SubscribePreprocessedTransactionInfo} message SubscribePreprocessedTransactionInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribePreprocessedTransactionInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
                object.isVote = false;
                object.transaction = null;
            }
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.isVote != null && message.hasOwnProperty("isVote"))
                object.isVote = message.isVote;
            if (message.transaction != null && message.hasOwnProperty("transaction"))
                object.transaction = $root.solana.storage.ConfirmedBlock.Transaction.toObject(message.transaction, options);
            return object;
        };

        /**
         * Converts this SubscribePreprocessedTransactionInfo to JSON.
         * @function toJSON
         * @memberof geyser.SubscribePreprocessedTransactionInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribePreprocessedTransactionInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribePreprocessedTransactionInfo
         * @function getTypeUrl
         * @memberof geyser.SubscribePreprocessedTransactionInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribePreprocessedTransactionInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribePreprocessedTransactionInfo";
        };

        return SubscribePreprocessedTransactionInfo;
    })();

    /**
     * CommitmentLevel enum.
     * @name geyser.CommitmentLevel
     * @enum {number}
     * @property {number} PROCESSED=0 PROCESSED value
     * @property {number} CONFIRMED=1 CONFIRMED value
     * @property {number} FINALIZED=2 FINALIZED value
     */
    geyser.CommitmentLevel = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PROCESSED"] = 0;
        values[valuesById[1] = "CONFIRMED"] = 1;
        values[valuesById[2] = "FINALIZED"] = 2;
        return values;
    })();

    /**
     * SlotStatus enum.
     * @name geyser.SlotStatus
     * @enum {number}
     * @property {number} SLOT_PROCESSED=0 SLOT_PROCESSED value
     * @property {number} SLOT_CONFIRMED=1 SLOT_CONFIRMED value
     * @property {number} SLOT_FINALIZED=2 SLOT_FINALIZED value
     * @property {number} SLOT_FIRST_SHRED_RECEIVED=3 SLOT_FIRST_SHRED_RECEIVED value
     * @property {number} SLOT_COMPLETED=4 SLOT_COMPLETED value
     * @property {number} SLOT_CREATED_BANK=5 SLOT_CREATED_BANK value
     * @property {number} SLOT_DEAD=6 SLOT_DEAD value
     */
    geyser.SlotStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SLOT_PROCESSED"] = 0;
        values[valuesById[1] = "SLOT_CONFIRMED"] = 1;
        values[valuesById[2] = "SLOT_FINALIZED"] = 2;
        values[valuesById[3] = "SLOT_FIRST_SHRED_RECEIVED"] = 3;
        values[valuesById[4] = "SLOT_COMPLETED"] = 4;
        values[valuesById[5] = "SLOT_CREATED_BANK"] = 5;
        values[valuesById[6] = "SLOT_DEAD"] = 6;
        return values;
    })();

    geyser.SubscribeRequest = (function() {

        /**
         * Properties of a SubscribeRequest.
         * @memberof geyser
         * @interface ISubscribeRequest
         * @property {Object.<string,geyser.ISubscribeRequestFilterAccounts>|null} [accounts] SubscribeRequest accounts
         * @property {Object.<string,geyser.ISubscribeRequestFilterSlots>|null} [slots] SubscribeRequest slots
         * @property {Object.<string,geyser.ISubscribeRequestFilterTransactions>|null} [transactions] SubscribeRequest transactions
         * @property {Object.<string,geyser.ISubscribeRequestFilterTransactions>|null} [transactionsStatus] SubscribeRequest transactionsStatus
         * @property {Object.<string,geyser.ISubscribeRequestFilterBlocks>|null} [blocks] SubscribeRequest blocks
         * @property {Object.<string,geyser.ISubscribeRequestFilterBlocksMeta>|null} [blocksMeta] SubscribeRequest blocksMeta
         * @property {Object.<string,geyser.ISubscribeRequestFilterEntry>|null} [entry] SubscribeRequest entry
         * @property {geyser.CommitmentLevel|null} [commitment] SubscribeRequest commitment
         * @property {Array.<geyser.ISubscribeRequestAccountsDataSlice>|null} [accountsDataSlice] SubscribeRequest accountsDataSlice
         * @property {geyser.ISubscribeRequestPing|null} [ping] SubscribeRequest ping
         * @property {number|Long|null} [fromSlot] SubscribeRequest fromSlot
         */

        /**
         * Constructs a new SubscribeRequest.
         * @memberof geyser
         * @classdesc Represents a SubscribeRequest.
         * @implements ISubscribeRequest
         * @constructor
         * @param {geyser.ISubscribeRequest=} [properties] Properties to set
         */
        function SubscribeRequest(properties) {
            this.accounts = {};
            this.slots = {};
            this.transactions = {};
            this.transactionsStatus = {};
            this.blocks = {};
            this.blocksMeta = {};
            this.entry = {};
            this.accountsDataSlice = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeRequest accounts.
         * @member {Object.<string,geyser.ISubscribeRequestFilterAccounts>} accounts
         * @memberof geyser.SubscribeRequest
         * @instance
         */
        SubscribeRequest.prototype.accounts = $util.emptyObject;

        /**
         * SubscribeRequest slots.
         * @member {Object.<string,geyser.ISubscribeRequestFilterSlots>} slots
         * @memberof geyser.SubscribeRequest
         * @instance
         */
        SubscribeRequest.prototype.slots = $util.emptyObject;

        /**
         * SubscribeRequest transactions.
         * @member {Object.<string,geyser.ISubscribeRequestFilterTransactions>} transactions
         * @memberof geyser.SubscribeRequest
         * @instance
         */
        SubscribeRequest.prototype.transactions = $util.emptyObject;

        /**
         * SubscribeRequest transactionsStatus.
         * @member {Object.<string,geyser.ISubscribeRequestFilterTransactions>} transactionsStatus
         * @memberof geyser.SubscribeRequest
         * @instance
         */
        SubscribeRequest.prototype.transactionsStatus = $util.emptyObject;

        /**
         * SubscribeRequest blocks.
         * @member {Object.<string,geyser.ISubscribeRequestFilterBlocks>} blocks
         * @memberof geyser.SubscribeRequest
         * @instance
         */
        SubscribeRequest.prototype.blocks = $util.emptyObject;

        /**
         * SubscribeRequest blocksMeta.
         * @member {Object.<string,geyser.ISubscribeRequestFilterBlocksMeta>} blocksMeta
         * @memberof geyser.SubscribeRequest
         * @instance
         */
        SubscribeRequest.prototype.blocksMeta = $util.emptyObject;

        /**
         * SubscribeRequest entry.
         * @member {Object.<string,geyser.ISubscribeRequestFilterEntry>} entry
         * @memberof geyser.SubscribeRequest
         * @instance
         */
        SubscribeRequest.prototype.entry = $util.emptyObject;

        /**
         * SubscribeRequest commitment.
         * @member {geyser.CommitmentLevel|null|undefined} commitment
         * @memberof geyser.SubscribeRequest
         * @instance
         */
        SubscribeRequest.prototype.commitment = null;

        /**
         * SubscribeRequest accountsDataSlice.
         * @member {Array.<geyser.ISubscribeRequestAccountsDataSlice>} accountsDataSlice
         * @memberof geyser.SubscribeRequest
         * @instance
         */
        SubscribeRequest.prototype.accountsDataSlice = $util.emptyArray;

        /**
         * SubscribeRequest ping.
         * @member {geyser.ISubscribeRequestPing|null|undefined} ping
         * @memberof geyser.SubscribeRequest
         * @instance
         */
        SubscribeRequest.prototype.ping = null;

        /**
         * SubscribeRequest fromSlot.
         * @member {number|Long|null|undefined} fromSlot
         * @memberof geyser.SubscribeRequest
         * @instance
         */
        SubscribeRequest.prototype.fromSlot = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribeRequest _commitment.
         * @member {"commitment"|undefined} _commitment
         * @memberof geyser.SubscribeRequest
         * @instance
         */
        Object.defineProperty(SubscribeRequest.prototype, "_commitment", {
            get: $util.oneOfGetter($oneOfFields = ["commitment"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * SubscribeRequest _ping.
         * @member {"ping"|undefined} _ping
         * @memberof geyser.SubscribeRequest
         * @instance
         */
        Object.defineProperty(SubscribeRequest.prototype, "_ping", {
            get: $util.oneOfGetter($oneOfFields = ["ping"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * SubscribeRequest _fromSlot.
         * @member {"fromSlot"|undefined} _fromSlot
         * @memberof geyser.SubscribeRequest
         * @instance
         */
        Object.defineProperty(SubscribeRequest.prototype, "_fromSlot", {
            get: $util.oneOfGetter($oneOfFields = ["fromSlot"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribeRequest instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeRequest
         * @static
         * @param {geyser.ISubscribeRequest=} [properties] Properties to set
         * @returns {geyser.SubscribeRequest} SubscribeRequest instance
         */
        SubscribeRequest.create = function create(properties) {
            return new SubscribeRequest(properties);
        };

        /**
         * Encodes the specified SubscribeRequest message. Does not implicitly {@link geyser.SubscribeRequest.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeRequest
         * @static
         * @param {geyser.ISubscribeRequest} message SubscribeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accounts != null && Object.hasOwnProperty.call(message, "accounts"))
                for (var keys = Object.keys(message.accounts), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.geyser.SubscribeRequestFilterAccounts.encode(message.accounts[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.slots != null && Object.hasOwnProperty.call(message, "slots"))
                for (var keys = Object.keys(message.slots), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.geyser.SubscribeRequestFilterSlots.encode(message.slots[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.transactions != null && Object.hasOwnProperty.call(message, "transactions"))
                for (var keys = Object.keys(message.transactions), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.geyser.SubscribeRequestFilterTransactions.encode(message.transactions[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.blocks != null && Object.hasOwnProperty.call(message, "blocks"))
                for (var keys = Object.keys(message.blocks), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.geyser.SubscribeRequestFilterBlocks.encode(message.blocks[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.blocksMeta != null && Object.hasOwnProperty.call(message, "blocksMeta"))
                for (var keys = Object.keys(message.blocksMeta), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.geyser.SubscribeRequestFilterBlocksMeta.encode(message.blocksMeta[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.commitment != null && Object.hasOwnProperty.call(message, "commitment"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.commitment);
            if (message.accountsDataSlice != null && message.accountsDataSlice.length)
                for (var i = 0; i < message.accountsDataSlice.length; ++i)
                    $root.geyser.SubscribeRequestAccountsDataSlice.encode(message.accountsDataSlice[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.entry != null && Object.hasOwnProperty.call(message, "entry"))
                for (var keys = Object.keys(message.entry), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 8, wireType 2 =*/66).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.geyser.SubscribeRequestFilterEntry.encode(message.entry[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.ping != null && Object.hasOwnProperty.call(message, "ping"))
                $root.geyser.SubscribeRequestPing.encode(message.ping, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.transactionsStatus != null && Object.hasOwnProperty.call(message, "transactionsStatus"))
                for (var keys = Object.keys(message.transactionsStatus), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 10, wireType 2 =*/82).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.geyser.SubscribeRequestFilterTransactions.encode(message.transactionsStatus[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.fromSlot != null && Object.hasOwnProperty.call(message, "fromSlot"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.fromSlot);
            return writer;
        };

        /**
         * Encodes the specified SubscribeRequest message, length delimited. Does not implicitly {@link geyser.SubscribeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeRequest
         * @static
         * @param {geyser.ISubscribeRequest} message SubscribeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeRequest} SubscribeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeRequest(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (message.accounts === $util.emptyObject)
                            message.accounts = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.geyser.SubscribeRequestFilterAccounts.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.accounts[key] = value;
                        break;
                    }
                case 2: {
                        if (message.slots === $util.emptyObject)
                            message.slots = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.geyser.SubscribeRequestFilterSlots.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.slots[key] = value;
                        break;
                    }
                case 3: {
                        if (message.transactions === $util.emptyObject)
                            message.transactions = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.geyser.SubscribeRequestFilterTransactions.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.transactions[key] = value;
                        break;
                    }
                case 10: {
                        if (message.transactionsStatus === $util.emptyObject)
                            message.transactionsStatus = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.geyser.SubscribeRequestFilterTransactions.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.transactionsStatus[key] = value;
                        break;
                    }
                case 4: {
                        if (message.blocks === $util.emptyObject)
                            message.blocks = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.geyser.SubscribeRequestFilterBlocks.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.blocks[key] = value;
                        break;
                    }
                case 5: {
                        if (message.blocksMeta === $util.emptyObject)
                            message.blocksMeta = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.geyser.SubscribeRequestFilterBlocksMeta.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.blocksMeta[key] = value;
                        break;
                    }
                case 8: {
                        if (message.entry === $util.emptyObject)
                            message.entry = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.geyser.SubscribeRequestFilterEntry.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.entry[key] = value;
                        break;
                    }
                case 6: {
                        message.commitment = reader.int32();
                        break;
                    }
                case 7: {
                        if (!(message.accountsDataSlice && message.accountsDataSlice.length))
                            message.accountsDataSlice = [];
                        message.accountsDataSlice.push($root.geyser.SubscribeRequestAccountsDataSlice.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        message.ping = $root.geyser.SubscribeRequestPing.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.fromSlot = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeRequest} SubscribeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeRequest message.
         * @function verify
         * @memberof geyser.SubscribeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.accounts != null && message.hasOwnProperty("accounts")) {
                if (!$util.isObject(message.accounts))
                    return "accounts: object expected";
                var key = Object.keys(message.accounts);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.geyser.SubscribeRequestFilterAccounts.verify(message.accounts[key[i]]);
                    if (error)
                        return "accounts." + error;
                }
            }
            if (message.slots != null && message.hasOwnProperty("slots")) {
                if (!$util.isObject(message.slots))
                    return "slots: object expected";
                var key = Object.keys(message.slots);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.geyser.SubscribeRequestFilterSlots.verify(message.slots[key[i]]);
                    if (error)
                        return "slots." + error;
                }
            }
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!$util.isObject(message.transactions))
                    return "transactions: object expected";
                var key = Object.keys(message.transactions);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.geyser.SubscribeRequestFilterTransactions.verify(message.transactions[key[i]]);
                    if (error)
                        return "transactions." + error;
                }
            }
            if (message.transactionsStatus != null && message.hasOwnProperty("transactionsStatus")) {
                if (!$util.isObject(message.transactionsStatus))
                    return "transactionsStatus: object expected";
                var key = Object.keys(message.transactionsStatus);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.geyser.SubscribeRequestFilterTransactions.verify(message.transactionsStatus[key[i]]);
                    if (error)
                        return "transactionsStatus." + error;
                }
            }
            if (message.blocks != null && message.hasOwnProperty("blocks")) {
                if (!$util.isObject(message.blocks))
                    return "blocks: object expected";
                var key = Object.keys(message.blocks);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.geyser.SubscribeRequestFilterBlocks.verify(message.blocks[key[i]]);
                    if (error)
                        return "blocks." + error;
                }
            }
            if (message.blocksMeta != null && message.hasOwnProperty("blocksMeta")) {
                if (!$util.isObject(message.blocksMeta))
                    return "blocksMeta: object expected";
                var key = Object.keys(message.blocksMeta);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.geyser.SubscribeRequestFilterBlocksMeta.verify(message.blocksMeta[key[i]]);
                    if (error)
                        return "blocksMeta." + error;
                }
            }
            if (message.entry != null && message.hasOwnProperty("entry")) {
                if (!$util.isObject(message.entry))
                    return "entry: object expected";
                var key = Object.keys(message.entry);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.geyser.SubscribeRequestFilterEntry.verify(message.entry[key[i]]);
                    if (error)
                        return "entry." + error;
                }
            }
            if (message.commitment != null && message.hasOwnProperty("commitment")) {
                properties._commitment = 1;
                switch (message.commitment) {
                default:
                    return "commitment: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            }
            if (message.accountsDataSlice != null && message.hasOwnProperty("accountsDataSlice")) {
                if (!Array.isArray(message.accountsDataSlice))
                    return "accountsDataSlice: array expected";
                for (var i = 0; i < message.accountsDataSlice.length; ++i) {
                    var error = $root.geyser.SubscribeRequestAccountsDataSlice.verify(message.accountsDataSlice[i]);
                    if (error)
                        return "accountsDataSlice." + error;
                }
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                properties._ping = 1;
                {
                    var error = $root.geyser.SubscribeRequestPing.verify(message.ping);
                    if (error)
                        return "ping." + error;
                }
            }
            if (message.fromSlot != null && message.hasOwnProperty("fromSlot")) {
                properties._fromSlot = 1;
                if (!$util.isInteger(message.fromSlot) && !(message.fromSlot && $util.isInteger(message.fromSlot.low) && $util.isInteger(message.fromSlot.high)))
                    return "fromSlot: integer|Long expected";
            }
            return null;
        };

        /**
         * Creates a SubscribeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeRequest} SubscribeRequest
         */
        SubscribeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeRequest)
                return object;
            var message = new $root.geyser.SubscribeRequest();
            if (object.accounts) {
                if (typeof object.accounts !== "object")
                    throw TypeError(".geyser.SubscribeRequest.accounts: object expected");
                message.accounts = {};
                for (var keys = Object.keys(object.accounts), i = 0; i < keys.length; ++i) {
                    if (typeof object.accounts[keys[i]] !== "object")
                        throw TypeError(".geyser.SubscribeRequest.accounts: object expected");
                    message.accounts[keys[i]] = $root.geyser.SubscribeRequestFilterAccounts.fromObject(object.accounts[keys[i]]);
                }
            }
            if (object.slots) {
                if (typeof object.slots !== "object")
                    throw TypeError(".geyser.SubscribeRequest.slots: object expected");
                message.slots = {};
                for (var keys = Object.keys(object.slots), i = 0; i < keys.length; ++i) {
                    if (typeof object.slots[keys[i]] !== "object")
                        throw TypeError(".geyser.SubscribeRequest.slots: object expected");
                    message.slots[keys[i]] = $root.geyser.SubscribeRequestFilterSlots.fromObject(object.slots[keys[i]]);
                }
            }
            if (object.transactions) {
                if (typeof object.transactions !== "object")
                    throw TypeError(".geyser.SubscribeRequest.transactions: object expected");
                message.transactions = {};
                for (var keys = Object.keys(object.transactions), i = 0; i < keys.length; ++i) {
                    if (typeof object.transactions[keys[i]] !== "object")
                        throw TypeError(".geyser.SubscribeRequest.transactions: object expected");
                    message.transactions[keys[i]] = $root.geyser.SubscribeRequestFilterTransactions.fromObject(object.transactions[keys[i]]);
                }
            }
            if (object.transactionsStatus) {
                if (typeof object.transactionsStatus !== "object")
                    throw TypeError(".geyser.SubscribeRequest.transactionsStatus: object expected");
                message.transactionsStatus = {};
                for (var keys = Object.keys(object.transactionsStatus), i = 0; i < keys.length; ++i) {
                    if (typeof object.transactionsStatus[keys[i]] !== "object")
                        throw TypeError(".geyser.SubscribeRequest.transactionsStatus: object expected");
                    message.transactionsStatus[keys[i]] = $root.geyser.SubscribeRequestFilterTransactions.fromObject(object.transactionsStatus[keys[i]]);
                }
            }
            if (object.blocks) {
                if (typeof object.blocks !== "object")
                    throw TypeError(".geyser.SubscribeRequest.blocks: object expected");
                message.blocks = {};
                for (var keys = Object.keys(object.blocks), i = 0; i < keys.length; ++i) {
                    if (typeof object.blocks[keys[i]] !== "object")
                        throw TypeError(".geyser.SubscribeRequest.blocks: object expected");
                    message.blocks[keys[i]] = $root.geyser.SubscribeRequestFilterBlocks.fromObject(object.blocks[keys[i]]);
                }
            }
            if (object.blocksMeta) {
                if (typeof object.blocksMeta !== "object")
                    throw TypeError(".geyser.SubscribeRequest.blocksMeta: object expected");
                message.blocksMeta = {};
                for (var keys = Object.keys(object.blocksMeta), i = 0; i < keys.length; ++i) {
                    if (typeof object.blocksMeta[keys[i]] !== "object")
                        throw TypeError(".geyser.SubscribeRequest.blocksMeta: object expected");
                    message.blocksMeta[keys[i]] = $root.geyser.SubscribeRequestFilterBlocksMeta.fromObject(object.blocksMeta[keys[i]]);
                }
            }
            if (object.entry) {
                if (typeof object.entry !== "object")
                    throw TypeError(".geyser.SubscribeRequest.entry: object expected");
                message.entry = {};
                for (var keys = Object.keys(object.entry), i = 0; i < keys.length; ++i) {
                    if (typeof object.entry[keys[i]] !== "object")
                        throw TypeError(".geyser.SubscribeRequest.entry: object expected");
                    message.entry[keys[i]] = $root.geyser.SubscribeRequestFilterEntry.fromObject(object.entry[keys[i]]);
                }
            }
            switch (object.commitment) {
            default:
                if (typeof object.commitment === "number") {
                    message.commitment = object.commitment;
                    break;
                }
                break;
            case "PROCESSED":
            case 0:
                message.commitment = 0;
                break;
            case "CONFIRMED":
            case 1:
                message.commitment = 1;
                break;
            case "FINALIZED":
            case 2:
                message.commitment = 2;
                break;
            }
            if (object.accountsDataSlice) {
                if (!Array.isArray(object.accountsDataSlice))
                    throw TypeError(".geyser.SubscribeRequest.accountsDataSlice: array expected");
                message.accountsDataSlice = [];
                for (var i = 0; i < object.accountsDataSlice.length; ++i) {
                    if (typeof object.accountsDataSlice[i] !== "object")
                        throw TypeError(".geyser.SubscribeRequest.accountsDataSlice: object expected");
                    message.accountsDataSlice[i] = $root.geyser.SubscribeRequestAccountsDataSlice.fromObject(object.accountsDataSlice[i]);
                }
            }
            if (object.ping != null) {
                if (typeof object.ping !== "object")
                    throw TypeError(".geyser.SubscribeRequest.ping: object expected");
                message.ping = $root.geyser.SubscribeRequestPing.fromObject(object.ping);
            }
            if (object.fromSlot != null)
                if ($util.Long)
                    (message.fromSlot = $util.Long.fromValue(object.fromSlot)).unsigned = true;
                else if (typeof object.fromSlot === "string")
                    message.fromSlot = parseInt(object.fromSlot, 10);
                else if (typeof object.fromSlot === "number")
                    message.fromSlot = object.fromSlot;
                else if (typeof object.fromSlot === "object")
                    message.fromSlot = new $util.LongBits(object.fromSlot.low >>> 0, object.fromSlot.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeRequest
         * @static
         * @param {geyser.SubscribeRequest} message SubscribeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.accountsDataSlice = [];
            if (options.objects || options.defaults) {
                object.accounts = {};
                object.slots = {};
                object.transactions = {};
                object.blocks = {};
                object.blocksMeta = {};
                object.entry = {};
                object.transactionsStatus = {};
            }
            var keys2;
            if (message.accounts && (keys2 = Object.keys(message.accounts)).length) {
                object.accounts = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.accounts[keys2[j]] = $root.geyser.SubscribeRequestFilterAccounts.toObject(message.accounts[keys2[j]], options);
            }
            if (message.slots && (keys2 = Object.keys(message.slots)).length) {
                object.slots = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.slots[keys2[j]] = $root.geyser.SubscribeRequestFilterSlots.toObject(message.slots[keys2[j]], options);
            }
            if (message.transactions && (keys2 = Object.keys(message.transactions)).length) {
                object.transactions = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.transactions[keys2[j]] = $root.geyser.SubscribeRequestFilterTransactions.toObject(message.transactions[keys2[j]], options);
            }
            if (message.blocks && (keys2 = Object.keys(message.blocks)).length) {
                object.blocks = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.blocks[keys2[j]] = $root.geyser.SubscribeRequestFilterBlocks.toObject(message.blocks[keys2[j]], options);
            }
            if (message.blocksMeta && (keys2 = Object.keys(message.blocksMeta)).length) {
                object.blocksMeta = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.blocksMeta[keys2[j]] = $root.geyser.SubscribeRequestFilterBlocksMeta.toObject(message.blocksMeta[keys2[j]], options);
            }
            if (message.commitment != null && message.hasOwnProperty("commitment")) {
                object.commitment = options.enums === String ? $root.geyser.CommitmentLevel[message.commitment] === undefined ? message.commitment : $root.geyser.CommitmentLevel[message.commitment] : message.commitment;
                if (options.oneofs)
                    object._commitment = "commitment";
            }
            if (message.accountsDataSlice && message.accountsDataSlice.length) {
                object.accountsDataSlice = [];
                for (var j = 0; j < message.accountsDataSlice.length; ++j)
                    object.accountsDataSlice[j] = $root.geyser.SubscribeRequestAccountsDataSlice.toObject(message.accountsDataSlice[j], options);
            }
            if (message.entry && (keys2 = Object.keys(message.entry)).length) {
                object.entry = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.entry[keys2[j]] = $root.geyser.SubscribeRequestFilterEntry.toObject(message.entry[keys2[j]], options);
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                object.ping = $root.geyser.SubscribeRequestPing.toObject(message.ping, options);
                if (options.oneofs)
                    object._ping = "ping";
            }
            if (message.transactionsStatus && (keys2 = Object.keys(message.transactionsStatus)).length) {
                object.transactionsStatus = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.transactionsStatus[keys2[j]] = $root.geyser.SubscribeRequestFilterTransactions.toObject(message.transactionsStatus[keys2[j]], options);
            }
            if (message.fromSlot != null && message.hasOwnProperty("fromSlot")) {
                if (typeof message.fromSlot === "number")
                    object.fromSlot = options.longs === String ? String(message.fromSlot) : message.fromSlot;
                else
                    object.fromSlot = options.longs === String ? $util.Long.prototype.toString.call(message.fromSlot) : options.longs === Number ? new $util.LongBits(message.fromSlot.low >>> 0, message.fromSlot.high >>> 0).toNumber(true) : message.fromSlot;
                if (options.oneofs)
                    object._fromSlot = "fromSlot";
            }
            return object;
        };

        /**
         * Converts this SubscribeRequest to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeRequest
         * @function getTypeUrl
         * @memberof geyser.SubscribeRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeRequest";
        };

        return SubscribeRequest;
    })();

    geyser.SubscribeRequestFilterAccounts = (function() {

        /**
         * Properties of a SubscribeRequestFilterAccounts.
         * @memberof geyser
         * @interface ISubscribeRequestFilterAccounts
         * @property {Array.<string>|null} [account] SubscribeRequestFilterAccounts account
         * @property {Array.<string>|null} [owner] SubscribeRequestFilterAccounts owner
         * @property {Array.<geyser.ISubscribeRequestFilterAccountsFilter>|null} [filters] SubscribeRequestFilterAccounts filters
         * @property {boolean|null} [nonemptyTxnSignature] SubscribeRequestFilterAccounts nonemptyTxnSignature
         */

        /**
         * Constructs a new SubscribeRequestFilterAccounts.
         * @memberof geyser
         * @classdesc Represents a SubscribeRequestFilterAccounts.
         * @implements ISubscribeRequestFilterAccounts
         * @constructor
         * @param {geyser.ISubscribeRequestFilterAccounts=} [properties] Properties to set
         */
        function SubscribeRequestFilterAccounts(properties) {
            this.account = [];
            this.owner = [];
            this.filters = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeRequestFilterAccounts account.
         * @member {Array.<string>} account
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @instance
         */
        SubscribeRequestFilterAccounts.prototype.account = $util.emptyArray;

        /**
         * SubscribeRequestFilterAccounts owner.
         * @member {Array.<string>} owner
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @instance
         */
        SubscribeRequestFilterAccounts.prototype.owner = $util.emptyArray;

        /**
         * SubscribeRequestFilterAccounts filters.
         * @member {Array.<geyser.ISubscribeRequestFilterAccountsFilter>} filters
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @instance
         */
        SubscribeRequestFilterAccounts.prototype.filters = $util.emptyArray;

        /**
         * SubscribeRequestFilterAccounts nonemptyTxnSignature.
         * @member {boolean|null|undefined} nonemptyTxnSignature
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @instance
         */
        SubscribeRequestFilterAccounts.prototype.nonemptyTxnSignature = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribeRequestFilterAccounts _nonemptyTxnSignature.
         * @member {"nonemptyTxnSignature"|undefined} _nonemptyTxnSignature
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @instance
         */
        Object.defineProperty(SubscribeRequestFilterAccounts.prototype, "_nonemptyTxnSignature", {
            get: $util.oneOfGetter($oneOfFields = ["nonemptyTxnSignature"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribeRequestFilterAccounts instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @static
         * @param {geyser.ISubscribeRequestFilterAccounts=} [properties] Properties to set
         * @returns {geyser.SubscribeRequestFilterAccounts} SubscribeRequestFilterAccounts instance
         */
        SubscribeRequestFilterAccounts.create = function create(properties) {
            return new SubscribeRequestFilterAccounts(properties);
        };

        /**
         * Encodes the specified SubscribeRequestFilterAccounts message. Does not implicitly {@link geyser.SubscribeRequestFilterAccounts.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @static
         * @param {geyser.ISubscribeRequestFilterAccounts} message SubscribeRequestFilterAccounts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterAccounts.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && message.account.length)
                for (var i = 0; i < message.account.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.account[i]);
            if (message.owner != null && message.owner.length)
                for (var i = 0; i < message.owner.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.owner[i]);
            if (message.filters != null && message.filters.length)
                for (var i = 0; i < message.filters.length; ++i)
                    $root.geyser.SubscribeRequestFilterAccountsFilter.encode(message.filters[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.nonemptyTxnSignature != null && Object.hasOwnProperty.call(message, "nonemptyTxnSignature"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.nonemptyTxnSignature);
            return writer;
        };

        /**
         * Encodes the specified SubscribeRequestFilterAccounts message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterAccounts.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @static
         * @param {geyser.ISubscribeRequestFilterAccounts} message SubscribeRequestFilterAccounts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterAccounts.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeRequestFilterAccounts message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeRequestFilterAccounts} SubscribeRequestFilterAccounts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterAccounts.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeRequestFilterAccounts();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 2: {
                        if (!(message.account && message.account.length))
                            message.account = [];
                        message.account.push(reader.string());
                        break;
                    }
                case 3: {
                        if (!(message.owner && message.owner.length))
                            message.owner = [];
                        message.owner.push(reader.string());
                        break;
                    }
                case 4: {
                        if (!(message.filters && message.filters.length))
                            message.filters = [];
                        message.filters.push($root.geyser.SubscribeRequestFilterAccountsFilter.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.nonemptyTxnSignature = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeRequestFilterAccounts message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeRequestFilterAccounts} SubscribeRequestFilterAccounts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterAccounts.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeRequestFilterAccounts message.
         * @function verify
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeRequestFilterAccounts.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.account != null && message.hasOwnProperty("account")) {
                if (!Array.isArray(message.account))
                    return "account: array expected";
                for (var i = 0; i < message.account.length; ++i)
                    if (!$util.isString(message.account[i]))
                        return "account: string[] expected";
            }
            if (message.owner != null && message.hasOwnProperty("owner")) {
                if (!Array.isArray(message.owner))
                    return "owner: array expected";
                for (var i = 0; i < message.owner.length; ++i)
                    if (!$util.isString(message.owner[i]))
                        return "owner: string[] expected";
            }
            if (message.filters != null && message.hasOwnProperty("filters")) {
                if (!Array.isArray(message.filters))
                    return "filters: array expected";
                for (var i = 0; i < message.filters.length; ++i) {
                    var error = $root.geyser.SubscribeRequestFilterAccountsFilter.verify(message.filters[i]);
                    if (error)
                        return "filters." + error;
                }
            }
            if (message.nonemptyTxnSignature != null && message.hasOwnProperty("nonemptyTxnSignature")) {
                properties._nonemptyTxnSignature = 1;
                if (typeof message.nonemptyTxnSignature !== "boolean")
                    return "nonemptyTxnSignature: boolean expected";
            }
            return null;
        };

        /**
         * Creates a SubscribeRequestFilterAccounts message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeRequestFilterAccounts} SubscribeRequestFilterAccounts
         */
        SubscribeRequestFilterAccounts.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeRequestFilterAccounts)
                return object;
            var message = new $root.geyser.SubscribeRequestFilterAccounts();
            if (object.account) {
                if (!Array.isArray(object.account))
                    throw TypeError(".geyser.SubscribeRequestFilterAccounts.account: array expected");
                message.account = [];
                for (var i = 0; i < object.account.length; ++i)
                    message.account[i] = String(object.account[i]);
            }
            if (object.owner) {
                if (!Array.isArray(object.owner))
                    throw TypeError(".geyser.SubscribeRequestFilterAccounts.owner: array expected");
                message.owner = [];
                for (var i = 0; i < object.owner.length; ++i)
                    message.owner[i] = String(object.owner[i]);
            }
            if (object.filters) {
                if (!Array.isArray(object.filters))
                    throw TypeError(".geyser.SubscribeRequestFilterAccounts.filters: array expected");
                message.filters = [];
                for (var i = 0; i < object.filters.length; ++i) {
                    if (typeof object.filters[i] !== "object")
                        throw TypeError(".geyser.SubscribeRequestFilterAccounts.filters: object expected");
                    message.filters[i] = $root.geyser.SubscribeRequestFilterAccountsFilter.fromObject(object.filters[i]);
                }
            }
            if (object.nonemptyTxnSignature != null)
                message.nonemptyTxnSignature = Boolean(object.nonemptyTxnSignature);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeRequestFilterAccounts message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @static
         * @param {geyser.SubscribeRequestFilterAccounts} message SubscribeRequestFilterAccounts
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeRequestFilterAccounts.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.account = [];
                object.owner = [];
                object.filters = [];
            }
            if (message.account && message.account.length) {
                object.account = [];
                for (var j = 0; j < message.account.length; ++j)
                    object.account[j] = message.account[j];
            }
            if (message.owner && message.owner.length) {
                object.owner = [];
                for (var j = 0; j < message.owner.length; ++j)
                    object.owner[j] = message.owner[j];
            }
            if (message.filters && message.filters.length) {
                object.filters = [];
                for (var j = 0; j < message.filters.length; ++j)
                    object.filters[j] = $root.geyser.SubscribeRequestFilterAccountsFilter.toObject(message.filters[j], options);
            }
            if (message.nonemptyTxnSignature != null && message.hasOwnProperty("nonemptyTxnSignature")) {
                object.nonemptyTxnSignature = message.nonemptyTxnSignature;
                if (options.oneofs)
                    object._nonemptyTxnSignature = "nonemptyTxnSignature";
            }
            return object;
        };

        /**
         * Converts this SubscribeRequestFilterAccounts to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeRequestFilterAccounts.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeRequestFilterAccounts
         * @function getTypeUrl
         * @memberof geyser.SubscribeRequestFilterAccounts
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeRequestFilterAccounts.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeRequestFilterAccounts";
        };

        return SubscribeRequestFilterAccounts;
    })();

    geyser.SubscribeRequestFilterAccountsFilter = (function() {

        /**
         * Properties of a SubscribeRequestFilterAccountsFilter.
         * @memberof geyser
         * @interface ISubscribeRequestFilterAccountsFilter
         * @property {geyser.ISubscribeRequestFilterAccountsFilterMemcmp|null} [memcmp] SubscribeRequestFilterAccountsFilter memcmp
         * @property {number|Long|null} [datasize] SubscribeRequestFilterAccountsFilter datasize
         * @property {boolean|null} [tokenAccountState] SubscribeRequestFilterAccountsFilter tokenAccountState
         * @property {geyser.ISubscribeRequestFilterAccountsFilterLamports|null} [lamports] SubscribeRequestFilterAccountsFilter lamports
         */

        /**
         * Constructs a new SubscribeRequestFilterAccountsFilter.
         * @memberof geyser
         * @classdesc Represents a SubscribeRequestFilterAccountsFilter.
         * @implements ISubscribeRequestFilterAccountsFilter
         * @constructor
         * @param {geyser.ISubscribeRequestFilterAccountsFilter=} [properties] Properties to set
         */
        function SubscribeRequestFilterAccountsFilter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeRequestFilterAccountsFilter memcmp.
         * @member {geyser.ISubscribeRequestFilterAccountsFilterMemcmp|null|undefined} memcmp
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @instance
         */
        SubscribeRequestFilterAccountsFilter.prototype.memcmp = null;

        /**
         * SubscribeRequestFilterAccountsFilter datasize.
         * @member {number|Long|null|undefined} datasize
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @instance
         */
        SubscribeRequestFilterAccountsFilter.prototype.datasize = null;

        /**
         * SubscribeRequestFilterAccountsFilter tokenAccountState.
         * @member {boolean|null|undefined} tokenAccountState
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @instance
         */
        SubscribeRequestFilterAccountsFilter.prototype.tokenAccountState = null;

        /**
         * SubscribeRequestFilterAccountsFilter lamports.
         * @member {geyser.ISubscribeRequestFilterAccountsFilterLamports|null|undefined} lamports
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @instance
         */
        SubscribeRequestFilterAccountsFilter.prototype.lamports = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribeRequestFilterAccountsFilter filter.
         * @member {"memcmp"|"datasize"|"tokenAccountState"|"lamports"|undefined} filter
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @instance
         */
        Object.defineProperty(SubscribeRequestFilterAccountsFilter.prototype, "filter", {
            get: $util.oneOfGetter($oneOfFields = ["memcmp", "datasize", "tokenAccountState", "lamports"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribeRequestFilterAccountsFilter instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @static
         * @param {geyser.ISubscribeRequestFilterAccountsFilter=} [properties] Properties to set
         * @returns {geyser.SubscribeRequestFilterAccountsFilter} SubscribeRequestFilterAccountsFilter instance
         */
        SubscribeRequestFilterAccountsFilter.create = function create(properties) {
            return new SubscribeRequestFilterAccountsFilter(properties);
        };

        /**
         * Encodes the specified SubscribeRequestFilterAccountsFilter message. Does not implicitly {@link geyser.SubscribeRequestFilterAccountsFilter.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @static
         * @param {geyser.ISubscribeRequestFilterAccountsFilter} message SubscribeRequestFilterAccountsFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterAccountsFilter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.memcmp != null && Object.hasOwnProperty.call(message, "memcmp"))
                $root.geyser.SubscribeRequestFilterAccountsFilterMemcmp.encode(message.memcmp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.datasize != null && Object.hasOwnProperty.call(message, "datasize"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.datasize);
            if (message.tokenAccountState != null && Object.hasOwnProperty.call(message, "tokenAccountState"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.tokenAccountState);
            if (message.lamports != null && Object.hasOwnProperty.call(message, "lamports"))
                $root.geyser.SubscribeRequestFilterAccountsFilterLamports.encode(message.lamports, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubscribeRequestFilterAccountsFilter message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterAccountsFilter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @static
         * @param {geyser.ISubscribeRequestFilterAccountsFilter} message SubscribeRequestFilterAccountsFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterAccountsFilter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeRequestFilterAccountsFilter message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeRequestFilterAccountsFilter} SubscribeRequestFilterAccountsFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterAccountsFilter.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeRequestFilterAccountsFilter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.memcmp = $root.geyser.SubscribeRequestFilterAccountsFilterMemcmp.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.datasize = reader.uint64();
                        break;
                    }
                case 3: {
                        message.tokenAccountState = reader.bool();
                        break;
                    }
                case 4: {
                        message.lamports = $root.geyser.SubscribeRequestFilterAccountsFilterLamports.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeRequestFilterAccountsFilter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeRequestFilterAccountsFilter} SubscribeRequestFilterAccountsFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterAccountsFilter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeRequestFilterAccountsFilter message.
         * @function verify
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeRequestFilterAccountsFilter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.memcmp != null && message.hasOwnProperty("memcmp")) {
                properties.filter = 1;
                {
                    var error = $root.geyser.SubscribeRequestFilterAccountsFilterMemcmp.verify(message.memcmp);
                    if (error)
                        return "memcmp." + error;
                }
            }
            if (message.datasize != null && message.hasOwnProperty("datasize")) {
                if (properties.filter === 1)
                    return "filter: multiple values";
                properties.filter = 1;
                if (!$util.isInteger(message.datasize) && !(message.datasize && $util.isInteger(message.datasize.low) && $util.isInteger(message.datasize.high)))
                    return "datasize: integer|Long expected";
            }
            if (message.tokenAccountState != null && message.hasOwnProperty("tokenAccountState")) {
                if (properties.filter === 1)
                    return "filter: multiple values";
                properties.filter = 1;
                if (typeof message.tokenAccountState !== "boolean")
                    return "tokenAccountState: boolean expected";
            }
            if (message.lamports != null && message.hasOwnProperty("lamports")) {
                if (properties.filter === 1)
                    return "filter: multiple values";
                properties.filter = 1;
                {
                    var error = $root.geyser.SubscribeRequestFilterAccountsFilterLamports.verify(message.lamports);
                    if (error)
                        return "lamports." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SubscribeRequestFilterAccountsFilter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeRequestFilterAccountsFilter} SubscribeRequestFilterAccountsFilter
         */
        SubscribeRequestFilterAccountsFilter.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeRequestFilterAccountsFilter)
                return object;
            var message = new $root.geyser.SubscribeRequestFilterAccountsFilter();
            if (object.memcmp != null) {
                if (typeof object.memcmp !== "object")
                    throw TypeError(".geyser.SubscribeRequestFilterAccountsFilter.memcmp: object expected");
                message.memcmp = $root.geyser.SubscribeRequestFilterAccountsFilterMemcmp.fromObject(object.memcmp);
            }
            if (object.datasize != null)
                if ($util.Long)
                    (message.datasize = $util.Long.fromValue(object.datasize)).unsigned = true;
                else if (typeof object.datasize === "string")
                    message.datasize = parseInt(object.datasize, 10);
                else if (typeof object.datasize === "number")
                    message.datasize = object.datasize;
                else if (typeof object.datasize === "object")
                    message.datasize = new $util.LongBits(object.datasize.low >>> 0, object.datasize.high >>> 0).toNumber(true);
            if (object.tokenAccountState != null)
                message.tokenAccountState = Boolean(object.tokenAccountState);
            if (object.lamports != null) {
                if (typeof object.lamports !== "object")
                    throw TypeError(".geyser.SubscribeRequestFilterAccountsFilter.lamports: object expected");
                message.lamports = $root.geyser.SubscribeRequestFilterAccountsFilterLamports.fromObject(object.lamports);
            }
            return message;
        };

        /**
         * Creates a plain object from a SubscribeRequestFilterAccountsFilter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @static
         * @param {geyser.SubscribeRequestFilterAccountsFilter} message SubscribeRequestFilterAccountsFilter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeRequestFilterAccountsFilter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.memcmp != null && message.hasOwnProperty("memcmp")) {
                object.memcmp = $root.geyser.SubscribeRequestFilterAccountsFilterMemcmp.toObject(message.memcmp, options);
                if (options.oneofs)
                    object.filter = "memcmp";
            }
            if (message.datasize != null && message.hasOwnProperty("datasize")) {
                if (typeof message.datasize === "number")
                    object.datasize = options.longs === String ? String(message.datasize) : message.datasize;
                else
                    object.datasize = options.longs === String ? $util.Long.prototype.toString.call(message.datasize) : options.longs === Number ? new $util.LongBits(message.datasize.low >>> 0, message.datasize.high >>> 0).toNumber(true) : message.datasize;
                if (options.oneofs)
                    object.filter = "datasize";
            }
            if (message.tokenAccountState != null && message.hasOwnProperty("tokenAccountState")) {
                object.tokenAccountState = message.tokenAccountState;
                if (options.oneofs)
                    object.filter = "tokenAccountState";
            }
            if (message.lamports != null && message.hasOwnProperty("lamports")) {
                object.lamports = $root.geyser.SubscribeRequestFilterAccountsFilterLamports.toObject(message.lamports, options);
                if (options.oneofs)
                    object.filter = "lamports";
            }
            return object;
        };

        /**
         * Converts this SubscribeRequestFilterAccountsFilter to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeRequestFilterAccountsFilter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeRequestFilterAccountsFilter
         * @function getTypeUrl
         * @memberof geyser.SubscribeRequestFilterAccountsFilter
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeRequestFilterAccountsFilter.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeRequestFilterAccountsFilter";
        };

        return SubscribeRequestFilterAccountsFilter;
    })();

    geyser.SubscribeRequestFilterAccountsFilterMemcmp = (function() {

        /**
         * Properties of a SubscribeRequestFilterAccountsFilterMemcmp.
         * @memberof geyser
         * @interface ISubscribeRequestFilterAccountsFilterMemcmp
         * @property {number|Long|null} [offset] SubscribeRequestFilterAccountsFilterMemcmp offset
         * @property {Uint8Array|null} [bytes] SubscribeRequestFilterAccountsFilterMemcmp bytes
         * @property {string|null} [base58] SubscribeRequestFilterAccountsFilterMemcmp base58
         * @property {string|null} [base64] SubscribeRequestFilterAccountsFilterMemcmp base64
         */

        /**
         * Constructs a new SubscribeRequestFilterAccountsFilterMemcmp.
         * @memberof geyser
         * @classdesc Represents a SubscribeRequestFilterAccountsFilterMemcmp.
         * @implements ISubscribeRequestFilterAccountsFilterMemcmp
         * @constructor
         * @param {geyser.ISubscribeRequestFilterAccountsFilterMemcmp=} [properties] Properties to set
         */
        function SubscribeRequestFilterAccountsFilterMemcmp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeRequestFilterAccountsFilterMemcmp offset.
         * @member {number|Long} offset
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @instance
         */
        SubscribeRequestFilterAccountsFilterMemcmp.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeRequestFilterAccountsFilterMemcmp bytes.
         * @member {Uint8Array|null|undefined} bytes
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @instance
         */
        SubscribeRequestFilterAccountsFilterMemcmp.prototype.bytes = null;

        /**
         * SubscribeRequestFilterAccountsFilterMemcmp base58.
         * @member {string|null|undefined} base58
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @instance
         */
        SubscribeRequestFilterAccountsFilterMemcmp.prototype.base58 = null;

        /**
         * SubscribeRequestFilterAccountsFilterMemcmp base64.
         * @member {string|null|undefined} base64
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @instance
         */
        SubscribeRequestFilterAccountsFilterMemcmp.prototype.base64 = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribeRequestFilterAccountsFilterMemcmp data.
         * @member {"bytes"|"base58"|"base64"|undefined} data
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @instance
         */
        Object.defineProperty(SubscribeRequestFilterAccountsFilterMemcmp.prototype, "data", {
            get: $util.oneOfGetter($oneOfFields = ["bytes", "base58", "base64"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribeRequestFilterAccountsFilterMemcmp instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @static
         * @param {geyser.ISubscribeRequestFilterAccountsFilterMemcmp=} [properties] Properties to set
         * @returns {geyser.SubscribeRequestFilterAccountsFilterMemcmp} SubscribeRequestFilterAccountsFilterMemcmp instance
         */
        SubscribeRequestFilterAccountsFilterMemcmp.create = function create(properties) {
            return new SubscribeRequestFilterAccountsFilterMemcmp(properties);
        };

        /**
         * Encodes the specified SubscribeRequestFilterAccountsFilterMemcmp message. Does not implicitly {@link geyser.SubscribeRequestFilterAccountsFilterMemcmp.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @static
         * @param {geyser.ISubscribeRequestFilterAccountsFilterMemcmp} message SubscribeRequestFilterAccountsFilterMemcmp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterAccountsFilterMemcmp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.offset);
            if (message.bytes != null && Object.hasOwnProperty.call(message, "bytes"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bytes);
            if (message.base58 != null && Object.hasOwnProperty.call(message, "base58"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.base58);
            if (message.base64 != null && Object.hasOwnProperty.call(message, "base64"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.base64);
            return writer;
        };

        /**
         * Encodes the specified SubscribeRequestFilterAccountsFilterMemcmp message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterAccountsFilterMemcmp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @static
         * @param {geyser.ISubscribeRequestFilterAccountsFilterMemcmp} message SubscribeRequestFilterAccountsFilterMemcmp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterAccountsFilterMemcmp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeRequestFilterAccountsFilterMemcmp message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeRequestFilterAccountsFilterMemcmp} SubscribeRequestFilterAccountsFilterMemcmp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterAccountsFilterMemcmp.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeRequestFilterAccountsFilterMemcmp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.offset = reader.uint64();
                        break;
                    }
                case 2: {
                        message.bytes = reader.bytes();
                        break;
                    }
                case 3: {
                        message.base58 = reader.string();
                        break;
                    }
                case 4: {
                        message.base64 = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeRequestFilterAccountsFilterMemcmp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeRequestFilterAccountsFilterMemcmp} SubscribeRequestFilterAccountsFilterMemcmp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterAccountsFilterMemcmp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeRequestFilterAccountsFilterMemcmp message.
         * @function verify
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeRequestFilterAccountsFilterMemcmp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))
                    return "offset: integer|Long expected";
            if (message.bytes != null && message.hasOwnProperty("bytes")) {
                properties.data = 1;
                if (!(message.bytes && typeof message.bytes.length === "number" || $util.isString(message.bytes)))
                    return "bytes: buffer expected";
            }
            if (message.base58 != null && message.hasOwnProperty("base58")) {
                if (properties.data === 1)
                    return "data: multiple values";
                properties.data = 1;
                if (!$util.isString(message.base58))
                    return "base58: string expected";
            }
            if (message.base64 != null && message.hasOwnProperty("base64")) {
                if (properties.data === 1)
                    return "data: multiple values";
                properties.data = 1;
                if (!$util.isString(message.base64))
                    return "base64: string expected";
            }
            return null;
        };

        /**
         * Creates a SubscribeRequestFilterAccountsFilterMemcmp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeRequestFilterAccountsFilterMemcmp} SubscribeRequestFilterAccountsFilterMemcmp
         */
        SubscribeRequestFilterAccountsFilterMemcmp.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeRequestFilterAccountsFilterMemcmp)
                return object;
            var message = new $root.geyser.SubscribeRequestFilterAccountsFilterMemcmp();
            if (object.offset != null)
                if ($util.Long)
                    (message.offset = $util.Long.fromValue(object.offset)).unsigned = true;
                else if (typeof object.offset === "string")
                    message.offset = parseInt(object.offset, 10);
                else if (typeof object.offset === "number")
                    message.offset = object.offset;
                else if (typeof object.offset === "object")
                    message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber(true);
            if (object.bytes != null)
                if (typeof object.bytes === "string")
                    $util.base64.decode(object.bytes, message.bytes = $util.newBuffer($util.base64.length(object.bytes)), 0);
                else if (object.bytes.length >= 0)
                    message.bytes = object.bytes;
            if (object.base58 != null)
                message.base58 = String(object.base58);
            if (object.base64 != null)
                message.base64 = String(object.base64);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeRequestFilterAccountsFilterMemcmp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @static
         * @param {geyser.SubscribeRequestFilterAccountsFilterMemcmp} message SubscribeRequestFilterAccountsFilterMemcmp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeRequestFilterAccountsFilterMemcmp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.offset = options.longs === String ? "0" : 0;
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (typeof message.offset === "number")
                    object.offset = options.longs === String ? String(message.offset) : message.offset;
                else
                    object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber(true) : message.offset;
            if (message.bytes != null && message.hasOwnProperty("bytes")) {
                object.bytes = options.bytes === String ? $util.base64.encode(message.bytes, 0, message.bytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytes) : message.bytes;
                if (options.oneofs)
                    object.data = "bytes";
            }
            if (message.base58 != null && message.hasOwnProperty("base58")) {
                object.base58 = message.base58;
                if (options.oneofs)
                    object.data = "base58";
            }
            if (message.base64 != null && message.hasOwnProperty("base64")) {
                object.base64 = message.base64;
                if (options.oneofs)
                    object.data = "base64";
            }
            return object;
        };

        /**
         * Converts this SubscribeRequestFilterAccountsFilterMemcmp to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeRequestFilterAccountsFilterMemcmp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeRequestFilterAccountsFilterMemcmp
         * @function getTypeUrl
         * @memberof geyser.SubscribeRequestFilterAccountsFilterMemcmp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeRequestFilterAccountsFilterMemcmp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeRequestFilterAccountsFilterMemcmp";
        };

        return SubscribeRequestFilterAccountsFilterMemcmp;
    })();

    geyser.SubscribeRequestFilterAccountsFilterLamports = (function() {

        /**
         * Properties of a SubscribeRequestFilterAccountsFilterLamports.
         * @memberof geyser
         * @interface ISubscribeRequestFilterAccountsFilterLamports
         * @property {number|Long|null} [eq] SubscribeRequestFilterAccountsFilterLamports eq
         * @property {number|Long|null} [ne] SubscribeRequestFilterAccountsFilterLamports ne
         * @property {number|Long|null} [lt] SubscribeRequestFilterAccountsFilterLamports lt
         * @property {number|Long|null} [gt] SubscribeRequestFilterAccountsFilterLamports gt
         */

        /**
         * Constructs a new SubscribeRequestFilterAccountsFilterLamports.
         * @memberof geyser
         * @classdesc Represents a SubscribeRequestFilterAccountsFilterLamports.
         * @implements ISubscribeRequestFilterAccountsFilterLamports
         * @constructor
         * @param {geyser.ISubscribeRequestFilterAccountsFilterLamports=} [properties] Properties to set
         */
        function SubscribeRequestFilterAccountsFilterLamports(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeRequestFilterAccountsFilterLamports eq.
         * @member {number|Long|null|undefined} eq
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @instance
         */
        SubscribeRequestFilterAccountsFilterLamports.prototype.eq = null;

        /**
         * SubscribeRequestFilterAccountsFilterLamports ne.
         * @member {number|Long|null|undefined} ne
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @instance
         */
        SubscribeRequestFilterAccountsFilterLamports.prototype.ne = null;

        /**
         * SubscribeRequestFilterAccountsFilterLamports lt.
         * @member {number|Long|null|undefined} lt
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @instance
         */
        SubscribeRequestFilterAccountsFilterLamports.prototype.lt = null;

        /**
         * SubscribeRequestFilterAccountsFilterLamports gt.
         * @member {number|Long|null|undefined} gt
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @instance
         */
        SubscribeRequestFilterAccountsFilterLamports.prototype.gt = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribeRequestFilterAccountsFilterLamports cmp.
         * @member {"eq"|"ne"|"lt"|"gt"|undefined} cmp
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @instance
         */
        Object.defineProperty(SubscribeRequestFilterAccountsFilterLamports.prototype, "cmp", {
            get: $util.oneOfGetter($oneOfFields = ["eq", "ne", "lt", "gt"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribeRequestFilterAccountsFilterLamports instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @static
         * @param {geyser.ISubscribeRequestFilterAccountsFilterLamports=} [properties] Properties to set
         * @returns {geyser.SubscribeRequestFilterAccountsFilterLamports} SubscribeRequestFilterAccountsFilterLamports instance
         */
        SubscribeRequestFilterAccountsFilterLamports.create = function create(properties) {
            return new SubscribeRequestFilterAccountsFilterLamports(properties);
        };

        /**
         * Encodes the specified SubscribeRequestFilterAccountsFilterLamports message. Does not implicitly {@link geyser.SubscribeRequestFilterAccountsFilterLamports.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @static
         * @param {geyser.ISubscribeRequestFilterAccountsFilterLamports} message SubscribeRequestFilterAccountsFilterLamports message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterAccountsFilterLamports.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eq != null && Object.hasOwnProperty.call(message, "eq"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.eq);
            if (message.ne != null && Object.hasOwnProperty.call(message, "ne"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.ne);
            if (message.lt != null && Object.hasOwnProperty.call(message, "lt"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.lt);
            if (message.gt != null && Object.hasOwnProperty.call(message, "gt"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.gt);
            return writer;
        };

        /**
         * Encodes the specified SubscribeRequestFilterAccountsFilterLamports message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterAccountsFilterLamports.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @static
         * @param {geyser.ISubscribeRequestFilterAccountsFilterLamports} message SubscribeRequestFilterAccountsFilterLamports message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterAccountsFilterLamports.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeRequestFilterAccountsFilterLamports message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeRequestFilterAccountsFilterLamports} SubscribeRequestFilterAccountsFilterLamports
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterAccountsFilterLamports.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeRequestFilterAccountsFilterLamports();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.eq = reader.uint64();
                        break;
                    }
                case 2: {
                        message.ne = reader.uint64();
                        break;
                    }
                case 3: {
                        message.lt = reader.uint64();
                        break;
                    }
                case 4: {
                        message.gt = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeRequestFilterAccountsFilterLamports message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeRequestFilterAccountsFilterLamports} SubscribeRequestFilterAccountsFilterLamports
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterAccountsFilterLamports.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeRequestFilterAccountsFilterLamports message.
         * @function verify
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeRequestFilterAccountsFilterLamports.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.eq != null && message.hasOwnProperty("eq")) {
                properties.cmp = 1;
                if (!$util.isInteger(message.eq) && !(message.eq && $util.isInteger(message.eq.low) && $util.isInteger(message.eq.high)))
                    return "eq: integer|Long expected";
            }
            if (message.ne != null && message.hasOwnProperty("ne")) {
                if (properties.cmp === 1)
                    return "cmp: multiple values";
                properties.cmp = 1;
                if (!$util.isInteger(message.ne) && !(message.ne && $util.isInteger(message.ne.low) && $util.isInteger(message.ne.high)))
                    return "ne: integer|Long expected";
            }
            if (message.lt != null && message.hasOwnProperty("lt")) {
                if (properties.cmp === 1)
                    return "cmp: multiple values";
                properties.cmp = 1;
                if (!$util.isInteger(message.lt) && !(message.lt && $util.isInteger(message.lt.low) && $util.isInteger(message.lt.high)))
                    return "lt: integer|Long expected";
            }
            if (message.gt != null && message.hasOwnProperty("gt")) {
                if (properties.cmp === 1)
                    return "cmp: multiple values";
                properties.cmp = 1;
                if (!$util.isInteger(message.gt) && !(message.gt && $util.isInteger(message.gt.low) && $util.isInteger(message.gt.high)))
                    return "gt: integer|Long expected";
            }
            return null;
        };

        /**
         * Creates a SubscribeRequestFilterAccountsFilterLamports message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeRequestFilterAccountsFilterLamports} SubscribeRequestFilterAccountsFilterLamports
         */
        SubscribeRequestFilterAccountsFilterLamports.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeRequestFilterAccountsFilterLamports)
                return object;
            var message = new $root.geyser.SubscribeRequestFilterAccountsFilterLamports();
            if (object.eq != null)
                if ($util.Long)
                    (message.eq = $util.Long.fromValue(object.eq)).unsigned = true;
                else if (typeof object.eq === "string")
                    message.eq = parseInt(object.eq, 10);
                else if (typeof object.eq === "number")
                    message.eq = object.eq;
                else if (typeof object.eq === "object")
                    message.eq = new $util.LongBits(object.eq.low >>> 0, object.eq.high >>> 0).toNumber(true);
            if (object.ne != null)
                if ($util.Long)
                    (message.ne = $util.Long.fromValue(object.ne)).unsigned = true;
                else if (typeof object.ne === "string")
                    message.ne = parseInt(object.ne, 10);
                else if (typeof object.ne === "number")
                    message.ne = object.ne;
                else if (typeof object.ne === "object")
                    message.ne = new $util.LongBits(object.ne.low >>> 0, object.ne.high >>> 0).toNumber(true);
            if (object.lt != null)
                if ($util.Long)
                    (message.lt = $util.Long.fromValue(object.lt)).unsigned = true;
                else if (typeof object.lt === "string")
                    message.lt = parseInt(object.lt, 10);
                else if (typeof object.lt === "number")
                    message.lt = object.lt;
                else if (typeof object.lt === "object")
                    message.lt = new $util.LongBits(object.lt.low >>> 0, object.lt.high >>> 0).toNumber(true);
            if (object.gt != null)
                if ($util.Long)
                    (message.gt = $util.Long.fromValue(object.gt)).unsigned = true;
                else if (typeof object.gt === "string")
                    message.gt = parseInt(object.gt, 10);
                else if (typeof object.gt === "number")
                    message.gt = object.gt;
                else if (typeof object.gt === "object")
                    message.gt = new $util.LongBits(object.gt.low >>> 0, object.gt.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeRequestFilterAccountsFilterLamports message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @static
         * @param {geyser.SubscribeRequestFilterAccountsFilterLamports} message SubscribeRequestFilterAccountsFilterLamports
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeRequestFilterAccountsFilterLamports.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.eq != null && message.hasOwnProperty("eq")) {
                if (typeof message.eq === "number")
                    object.eq = options.longs === String ? String(message.eq) : message.eq;
                else
                    object.eq = options.longs === String ? $util.Long.prototype.toString.call(message.eq) : options.longs === Number ? new $util.LongBits(message.eq.low >>> 0, message.eq.high >>> 0).toNumber(true) : message.eq;
                if (options.oneofs)
                    object.cmp = "eq";
            }
            if (message.ne != null && message.hasOwnProperty("ne")) {
                if (typeof message.ne === "number")
                    object.ne = options.longs === String ? String(message.ne) : message.ne;
                else
                    object.ne = options.longs === String ? $util.Long.prototype.toString.call(message.ne) : options.longs === Number ? new $util.LongBits(message.ne.low >>> 0, message.ne.high >>> 0).toNumber(true) : message.ne;
                if (options.oneofs)
                    object.cmp = "ne";
            }
            if (message.lt != null && message.hasOwnProperty("lt")) {
                if (typeof message.lt === "number")
                    object.lt = options.longs === String ? String(message.lt) : message.lt;
                else
                    object.lt = options.longs === String ? $util.Long.prototype.toString.call(message.lt) : options.longs === Number ? new $util.LongBits(message.lt.low >>> 0, message.lt.high >>> 0).toNumber(true) : message.lt;
                if (options.oneofs)
                    object.cmp = "lt";
            }
            if (message.gt != null && message.hasOwnProperty("gt")) {
                if (typeof message.gt === "number")
                    object.gt = options.longs === String ? String(message.gt) : message.gt;
                else
                    object.gt = options.longs === String ? $util.Long.prototype.toString.call(message.gt) : options.longs === Number ? new $util.LongBits(message.gt.low >>> 0, message.gt.high >>> 0).toNumber(true) : message.gt;
                if (options.oneofs)
                    object.cmp = "gt";
            }
            return object;
        };

        /**
         * Converts this SubscribeRequestFilterAccountsFilterLamports to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeRequestFilterAccountsFilterLamports.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeRequestFilterAccountsFilterLamports
         * @function getTypeUrl
         * @memberof geyser.SubscribeRequestFilterAccountsFilterLamports
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeRequestFilterAccountsFilterLamports.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeRequestFilterAccountsFilterLamports";
        };

        return SubscribeRequestFilterAccountsFilterLamports;
    })();

    geyser.SubscribeRequestFilterSlots = (function() {

        /**
         * Properties of a SubscribeRequestFilterSlots.
         * @memberof geyser
         * @interface ISubscribeRequestFilterSlots
         * @property {boolean|null} [filterByCommitment] SubscribeRequestFilterSlots filterByCommitment
         * @property {boolean|null} [interslotUpdates] SubscribeRequestFilterSlots interslotUpdates
         */

        /**
         * Constructs a new SubscribeRequestFilterSlots.
         * @memberof geyser
         * @classdesc Represents a SubscribeRequestFilterSlots.
         * @implements ISubscribeRequestFilterSlots
         * @constructor
         * @param {geyser.ISubscribeRequestFilterSlots=} [properties] Properties to set
         */
        function SubscribeRequestFilterSlots(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeRequestFilterSlots filterByCommitment.
         * @member {boolean|null|undefined} filterByCommitment
         * @memberof geyser.SubscribeRequestFilterSlots
         * @instance
         */
        SubscribeRequestFilterSlots.prototype.filterByCommitment = null;

        /**
         * SubscribeRequestFilterSlots interslotUpdates.
         * @member {boolean|null|undefined} interslotUpdates
         * @memberof geyser.SubscribeRequestFilterSlots
         * @instance
         */
        SubscribeRequestFilterSlots.prototype.interslotUpdates = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribeRequestFilterSlots _filterByCommitment.
         * @member {"filterByCommitment"|undefined} _filterByCommitment
         * @memberof geyser.SubscribeRequestFilterSlots
         * @instance
         */
        Object.defineProperty(SubscribeRequestFilterSlots.prototype, "_filterByCommitment", {
            get: $util.oneOfGetter($oneOfFields = ["filterByCommitment"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * SubscribeRequestFilterSlots _interslotUpdates.
         * @member {"interslotUpdates"|undefined} _interslotUpdates
         * @memberof geyser.SubscribeRequestFilterSlots
         * @instance
         */
        Object.defineProperty(SubscribeRequestFilterSlots.prototype, "_interslotUpdates", {
            get: $util.oneOfGetter($oneOfFields = ["interslotUpdates"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribeRequestFilterSlots instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeRequestFilterSlots
         * @static
         * @param {geyser.ISubscribeRequestFilterSlots=} [properties] Properties to set
         * @returns {geyser.SubscribeRequestFilterSlots} SubscribeRequestFilterSlots instance
         */
        SubscribeRequestFilterSlots.create = function create(properties) {
            return new SubscribeRequestFilterSlots(properties);
        };

        /**
         * Encodes the specified SubscribeRequestFilterSlots message. Does not implicitly {@link geyser.SubscribeRequestFilterSlots.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeRequestFilterSlots
         * @static
         * @param {geyser.ISubscribeRequestFilterSlots} message SubscribeRequestFilterSlots message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterSlots.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filterByCommitment != null && Object.hasOwnProperty.call(message, "filterByCommitment"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.filterByCommitment);
            if (message.interslotUpdates != null && Object.hasOwnProperty.call(message, "interslotUpdates"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.interslotUpdates);
            return writer;
        };

        /**
         * Encodes the specified SubscribeRequestFilterSlots message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterSlots.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeRequestFilterSlots
         * @static
         * @param {geyser.ISubscribeRequestFilterSlots} message SubscribeRequestFilterSlots message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterSlots.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeRequestFilterSlots message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeRequestFilterSlots
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeRequestFilterSlots} SubscribeRequestFilterSlots
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterSlots.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeRequestFilterSlots();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.filterByCommitment = reader.bool();
                        break;
                    }
                case 2: {
                        message.interslotUpdates = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeRequestFilterSlots message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeRequestFilterSlots
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeRequestFilterSlots} SubscribeRequestFilterSlots
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterSlots.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeRequestFilterSlots message.
         * @function verify
         * @memberof geyser.SubscribeRequestFilterSlots
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeRequestFilterSlots.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.filterByCommitment != null && message.hasOwnProperty("filterByCommitment")) {
                properties._filterByCommitment = 1;
                if (typeof message.filterByCommitment !== "boolean")
                    return "filterByCommitment: boolean expected";
            }
            if (message.interslotUpdates != null && message.hasOwnProperty("interslotUpdates")) {
                properties._interslotUpdates = 1;
                if (typeof message.interslotUpdates !== "boolean")
                    return "interslotUpdates: boolean expected";
            }
            return null;
        };

        /**
         * Creates a SubscribeRequestFilterSlots message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeRequestFilterSlots
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeRequestFilterSlots} SubscribeRequestFilterSlots
         */
        SubscribeRequestFilterSlots.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeRequestFilterSlots)
                return object;
            var message = new $root.geyser.SubscribeRequestFilterSlots();
            if (object.filterByCommitment != null)
                message.filterByCommitment = Boolean(object.filterByCommitment);
            if (object.interslotUpdates != null)
                message.interslotUpdates = Boolean(object.interslotUpdates);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeRequestFilterSlots message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeRequestFilterSlots
         * @static
         * @param {geyser.SubscribeRequestFilterSlots} message SubscribeRequestFilterSlots
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeRequestFilterSlots.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.filterByCommitment != null && message.hasOwnProperty("filterByCommitment")) {
                object.filterByCommitment = message.filterByCommitment;
                if (options.oneofs)
                    object._filterByCommitment = "filterByCommitment";
            }
            if (message.interslotUpdates != null && message.hasOwnProperty("interslotUpdates")) {
                object.interslotUpdates = message.interslotUpdates;
                if (options.oneofs)
                    object._interslotUpdates = "interslotUpdates";
            }
            return object;
        };

        /**
         * Converts this SubscribeRequestFilterSlots to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeRequestFilterSlots
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeRequestFilterSlots.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeRequestFilterSlots
         * @function getTypeUrl
         * @memberof geyser.SubscribeRequestFilterSlots
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeRequestFilterSlots.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeRequestFilterSlots";
        };

        return SubscribeRequestFilterSlots;
    })();

    geyser.SubscribeRequestFilterTransactions = (function() {

        /**
         * Properties of a SubscribeRequestFilterTransactions.
         * @memberof geyser
         * @interface ISubscribeRequestFilterTransactions
         * @property {boolean|null} [vote] SubscribeRequestFilterTransactions vote
         * @property {boolean|null} [failed] SubscribeRequestFilterTransactions failed
         * @property {string|null} [signature] SubscribeRequestFilterTransactions signature
         * @property {Array.<string>|null} [accountInclude] SubscribeRequestFilterTransactions accountInclude
         * @property {Array.<string>|null} [accountExclude] SubscribeRequestFilterTransactions accountExclude
         * @property {Array.<string>|null} [accountRequired] SubscribeRequestFilterTransactions accountRequired
         */

        /**
         * Constructs a new SubscribeRequestFilterTransactions.
         * @memberof geyser
         * @classdesc Represents a SubscribeRequestFilterTransactions.
         * @implements ISubscribeRequestFilterTransactions
         * @constructor
         * @param {geyser.ISubscribeRequestFilterTransactions=} [properties] Properties to set
         */
        function SubscribeRequestFilterTransactions(properties) {
            this.accountInclude = [];
            this.accountExclude = [];
            this.accountRequired = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeRequestFilterTransactions vote.
         * @member {boolean|null|undefined} vote
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @instance
         */
        SubscribeRequestFilterTransactions.prototype.vote = null;

        /**
         * SubscribeRequestFilterTransactions failed.
         * @member {boolean|null|undefined} failed
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @instance
         */
        SubscribeRequestFilterTransactions.prototype.failed = null;

        /**
         * SubscribeRequestFilterTransactions signature.
         * @member {string|null|undefined} signature
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @instance
         */
        SubscribeRequestFilterTransactions.prototype.signature = null;

        /**
         * SubscribeRequestFilterTransactions accountInclude.
         * @member {Array.<string>} accountInclude
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @instance
         */
        SubscribeRequestFilterTransactions.prototype.accountInclude = $util.emptyArray;

        /**
         * SubscribeRequestFilterTransactions accountExclude.
         * @member {Array.<string>} accountExclude
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @instance
         */
        SubscribeRequestFilterTransactions.prototype.accountExclude = $util.emptyArray;

        /**
         * SubscribeRequestFilterTransactions accountRequired.
         * @member {Array.<string>} accountRequired
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @instance
         */
        SubscribeRequestFilterTransactions.prototype.accountRequired = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribeRequestFilterTransactions _vote.
         * @member {"vote"|undefined} _vote
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @instance
         */
        Object.defineProperty(SubscribeRequestFilterTransactions.prototype, "_vote", {
            get: $util.oneOfGetter($oneOfFields = ["vote"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * SubscribeRequestFilterTransactions _failed.
         * @member {"failed"|undefined} _failed
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @instance
         */
        Object.defineProperty(SubscribeRequestFilterTransactions.prototype, "_failed", {
            get: $util.oneOfGetter($oneOfFields = ["failed"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * SubscribeRequestFilterTransactions _signature.
         * @member {"signature"|undefined} _signature
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @instance
         */
        Object.defineProperty(SubscribeRequestFilterTransactions.prototype, "_signature", {
            get: $util.oneOfGetter($oneOfFields = ["signature"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribeRequestFilterTransactions instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @static
         * @param {geyser.ISubscribeRequestFilterTransactions=} [properties] Properties to set
         * @returns {geyser.SubscribeRequestFilterTransactions} SubscribeRequestFilterTransactions instance
         */
        SubscribeRequestFilterTransactions.create = function create(properties) {
            return new SubscribeRequestFilterTransactions(properties);
        };

        /**
         * Encodes the specified SubscribeRequestFilterTransactions message. Does not implicitly {@link geyser.SubscribeRequestFilterTransactions.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @static
         * @param {geyser.ISubscribeRequestFilterTransactions} message SubscribeRequestFilterTransactions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterTransactions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vote != null && Object.hasOwnProperty.call(message, "vote"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.vote);
            if (message.failed != null && Object.hasOwnProperty.call(message, "failed"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.failed);
            if (message.accountInclude != null && message.accountInclude.length)
                for (var i = 0; i < message.accountInclude.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.accountInclude[i]);
            if (message.accountExclude != null && message.accountExclude.length)
                for (var i = 0; i < message.accountExclude.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.accountExclude[i]);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.signature);
            if (message.accountRequired != null && message.accountRequired.length)
                for (var i = 0; i < message.accountRequired.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.accountRequired[i]);
            return writer;
        };

        /**
         * Encodes the specified SubscribeRequestFilterTransactions message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterTransactions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @static
         * @param {geyser.ISubscribeRequestFilterTransactions} message SubscribeRequestFilterTransactions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterTransactions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeRequestFilterTransactions message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeRequestFilterTransactions} SubscribeRequestFilterTransactions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterTransactions.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeRequestFilterTransactions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.vote = reader.bool();
                        break;
                    }
                case 2: {
                        message.failed = reader.bool();
                        break;
                    }
                case 5: {
                        message.signature = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.accountInclude && message.accountInclude.length))
                            message.accountInclude = [];
                        message.accountInclude.push(reader.string());
                        break;
                    }
                case 4: {
                        if (!(message.accountExclude && message.accountExclude.length))
                            message.accountExclude = [];
                        message.accountExclude.push(reader.string());
                        break;
                    }
                case 6: {
                        if (!(message.accountRequired && message.accountRequired.length))
                            message.accountRequired = [];
                        message.accountRequired.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeRequestFilterTransactions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeRequestFilterTransactions} SubscribeRequestFilterTransactions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterTransactions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeRequestFilterTransactions message.
         * @function verify
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeRequestFilterTransactions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.vote != null && message.hasOwnProperty("vote")) {
                properties._vote = 1;
                if (typeof message.vote !== "boolean")
                    return "vote: boolean expected";
            }
            if (message.failed != null && message.hasOwnProperty("failed")) {
                properties._failed = 1;
                if (typeof message.failed !== "boolean")
                    return "failed: boolean expected";
            }
            if (message.signature != null && message.hasOwnProperty("signature")) {
                properties._signature = 1;
                if (!$util.isString(message.signature))
                    return "signature: string expected";
            }
            if (message.accountInclude != null && message.hasOwnProperty("accountInclude")) {
                if (!Array.isArray(message.accountInclude))
                    return "accountInclude: array expected";
                for (var i = 0; i < message.accountInclude.length; ++i)
                    if (!$util.isString(message.accountInclude[i]))
                        return "accountInclude: string[] expected";
            }
            if (message.accountExclude != null && message.hasOwnProperty("accountExclude")) {
                if (!Array.isArray(message.accountExclude))
                    return "accountExclude: array expected";
                for (var i = 0; i < message.accountExclude.length; ++i)
                    if (!$util.isString(message.accountExclude[i]))
                        return "accountExclude: string[] expected";
            }
            if (message.accountRequired != null && message.hasOwnProperty("accountRequired")) {
                if (!Array.isArray(message.accountRequired))
                    return "accountRequired: array expected";
                for (var i = 0; i < message.accountRequired.length; ++i)
                    if (!$util.isString(message.accountRequired[i]))
                        return "accountRequired: string[] expected";
            }
            return null;
        };

        /**
         * Creates a SubscribeRequestFilterTransactions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeRequestFilterTransactions} SubscribeRequestFilterTransactions
         */
        SubscribeRequestFilterTransactions.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeRequestFilterTransactions)
                return object;
            var message = new $root.geyser.SubscribeRequestFilterTransactions();
            if (object.vote != null)
                message.vote = Boolean(object.vote);
            if (object.failed != null)
                message.failed = Boolean(object.failed);
            if (object.signature != null)
                message.signature = String(object.signature);
            if (object.accountInclude) {
                if (!Array.isArray(object.accountInclude))
                    throw TypeError(".geyser.SubscribeRequestFilterTransactions.accountInclude: array expected");
                message.accountInclude = [];
                for (var i = 0; i < object.accountInclude.length; ++i)
                    message.accountInclude[i] = String(object.accountInclude[i]);
            }
            if (object.accountExclude) {
                if (!Array.isArray(object.accountExclude))
                    throw TypeError(".geyser.SubscribeRequestFilterTransactions.accountExclude: array expected");
                message.accountExclude = [];
                for (var i = 0; i < object.accountExclude.length; ++i)
                    message.accountExclude[i] = String(object.accountExclude[i]);
            }
            if (object.accountRequired) {
                if (!Array.isArray(object.accountRequired))
                    throw TypeError(".geyser.SubscribeRequestFilterTransactions.accountRequired: array expected");
                message.accountRequired = [];
                for (var i = 0; i < object.accountRequired.length; ++i)
                    message.accountRequired[i] = String(object.accountRequired[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a SubscribeRequestFilterTransactions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @static
         * @param {geyser.SubscribeRequestFilterTransactions} message SubscribeRequestFilterTransactions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeRequestFilterTransactions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.accountInclude = [];
                object.accountExclude = [];
                object.accountRequired = [];
            }
            if (message.vote != null && message.hasOwnProperty("vote")) {
                object.vote = message.vote;
                if (options.oneofs)
                    object._vote = "vote";
            }
            if (message.failed != null && message.hasOwnProperty("failed")) {
                object.failed = message.failed;
                if (options.oneofs)
                    object._failed = "failed";
            }
            if (message.accountInclude && message.accountInclude.length) {
                object.accountInclude = [];
                for (var j = 0; j < message.accountInclude.length; ++j)
                    object.accountInclude[j] = message.accountInclude[j];
            }
            if (message.accountExclude && message.accountExclude.length) {
                object.accountExclude = [];
                for (var j = 0; j < message.accountExclude.length; ++j)
                    object.accountExclude[j] = message.accountExclude[j];
            }
            if (message.signature != null && message.hasOwnProperty("signature")) {
                object.signature = message.signature;
                if (options.oneofs)
                    object._signature = "signature";
            }
            if (message.accountRequired && message.accountRequired.length) {
                object.accountRequired = [];
                for (var j = 0; j < message.accountRequired.length; ++j)
                    object.accountRequired[j] = message.accountRequired[j];
            }
            return object;
        };

        /**
         * Converts this SubscribeRequestFilterTransactions to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeRequestFilterTransactions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeRequestFilterTransactions
         * @function getTypeUrl
         * @memberof geyser.SubscribeRequestFilterTransactions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeRequestFilterTransactions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeRequestFilterTransactions";
        };

        return SubscribeRequestFilterTransactions;
    })();

    geyser.SubscribeRequestFilterBlocks = (function() {

        /**
         * Properties of a SubscribeRequestFilterBlocks.
         * @memberof geyser
         * @interface ISubscribeRequestFilterBlocks
         * @property {Array.<string>|null} [accountInclude] SubscribeRequestFilterBlocks accountInclude
         * @property {boolean|null} [includeTransactions] SubscribeRequestFilterBlocks includeTransactions
         * @property {boolean|null} [includeAccounts] SubscribeRequestFilterBlocks includeAccounts
         * @property {boolean|null} [includeEntries] SubscribeRequestFilterBlocks includeEntries
         */

        /**
         * Constructs a new SubscribeRequestFilterBlocks.
         * @memberof geyser
         * @classdesc Represents a SubscribeRequestFilterBlocks.
         * @implements ISubscribeRequestFilterBlocks
         * @constructor
         * @param {geyser.ISubscribeRequestFilterBlocks=} [properties] Properties to set
         */
        function SubscribeRequestFilterBlocks(properties) {
            this.accountInclude = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeRequestFilterBlocks accountInclude.
         * @member {Array.<string>} accountInclude
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @instance
         */
        SubscribeRequestFilterBlocks.prototype.accountInclude = $util.emptyArray;

        /**
         * SubscribeRequestFilterBlocks includeTransactions.
         * @member {boolean|null|undefined} includeTransactions
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @instance
         */
        SubscribeRequestFilterBlocks.prototype.includeTransactions = null;

        /**
         * SubscribeRequestFilterBlocks includeAccounts.
         * @member {boolean|null|undefined} includeAccounts
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @instance
         */
        SubscribeRequestFilterBlocks.prototype.includeAccounts = null;

        /**
         * SubscribeRequestFilterBlocks includeEntries.
         * @member {boolean|null|undefined} includeEntries
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @instance
         */
        SubscribeRequestFilterBlocks.prototype.includeEntries = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribeRequestFilterBlocks _includeTransactions.
         * @member {"includeTransactions"|undefined} _includeTransactions
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @instance
         */
        Object.defineProperty(SubscribeRequestFilterBlocks.prototype, "_includeTransactions", {
            get: $util.oneOfGetter($oneOfFields = ["includeTransactions"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * SubscribeRequestFilterBlocks _includeAccounts.
         * @member {"includeAccounts"|undefined} _includeAccounts
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @instance
         */
        Object.defineProperty(SubscribeRequestFilterBlocks.prototype, "_includeAccounts", {
            get: $util.oneOfGetter($oneOfFields = ["includeAccounts"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * SubscribeRequestFilterBlocks _includeEntries.
         * @member {"includeEntries"|undefined} _includeEntries
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @instance
         */
        Object.defineProperty(SubscribeRequestFilterBlocks.prototype, "_includeEntries", {
            get: $util.oneOfGetter($oneOfFields = ["includeEntries"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribeRequestFilterBlocks instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @static
         * @param {geyser.ISubscribeRequestFilterBlocks=} [properties] Properties to set
         * @returns {geyser.SubscribeRequestFilterBlocks} SubscribeRequestFilterBlocks instance
         */
        SubscribeRequestFilterBlocks.create = function create(properties) {
            return new SubscribeRequestFilterBlocks(properties);
        };

        /**
         * Encodes the specified SubscribeRequestFilterBlocks message. Does not implicitly {@link geyser.SubscribeRequestFilterBlocks.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @static
         * @param {geyser.ISubscribeRequestFilterBlocks} message SubscribeRequestFilterBlocks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterBlocks.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountInclude != null && message.accountInclude.length)
                for (var i = 0; i < message.accountInclude.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.accountInclude[i]);
            if (message.includeTransactions != null && Object.hasOwnProperty.call(message, "includeTransactions"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.includeTransactions);
            if (message.includeAccounts != null && Object.hasOwnProperty.call(message, "includeAccounts"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeAccounts);
            if (message.includeEntries != null && Object.hasOwnProperty.call(message, "includeEntries"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.includeEntries);
            return writer;
        };

        /**
         * Encodes the specified SubscribeRequestFilterBlocks message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterBlocks.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @static
         * @param {geyser.ISubscribeRequestFilterBlocks} message SubscribeRequestFilterBlocks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterBlocks.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeRequestFilterBlocks message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeRequestFilterBlocks} SubscribeRequestFilterBlocks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterBlocks.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeRequestFilterBlocks();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.accountInclude && message.accountInclude.length))
                            message.accountInclude = [];
                        message.accountInclude.push(reader.string());
                        break;
                    }
                case 2: {
                        message.includeTransactions = reader.bool();
                        break;
                    }
                case 3: {
                        message.includeAccounts = reader.bool();
                        break;
                    }
                case 4: {
                        message.includeEntries = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeRequestFilterBlocks message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeRequestFilterBlocks} SubscribeRequestFilterBlocks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterBlocks.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeRequestFilterBlocks message.
         * @function verify
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeRequestFilterBlocks.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.accountInclude != null && message.hasOwnProperty("accountInclude")) {
                if (!Array.isArray(message.accountInclude))
                    return "accountInclude: array expected";
                for (var i = 0; i < message.accountInclude.length; ++i)
                    if (!$util.isString(message.accountInclude[i]))
                        return "accountInclude: string[] expected";
            }
            if (message.includeTransactions != null && message.hasOwnProperty("includeTransactions")) {
                properties._includeTransactions = 1;
                if (typeof message.includeTransactions !== "boolean")
                    return "includeTransactions: boolean expected";
            }
            if (message.includeAccounts != null && message.hasOwnProperty("includeAccounts")) {
                properties._includeAccounts = 1;
                if (typeof message.includeAccounts !== "boolean")
                    return "includeAccounts: boolean expected";
            }
            if (message.includeEntries != null && message.hasOwnProperty("includeEntries")) {
                properties._includeEntries = 1;
                if (typeof message.includeEntries !== "boolean")
                    return "includeEntries: boolean expected";
            }
            return null;
        };

        /**
         * Creates a SubscribeRequestFilterBlocks message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeRequestFilterBlocks} SubscribeRequestFilterBlocks
         */
        SubscribeRequestFilterBlocks.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeRequestFilterBlocks)
                return object;
            var message = new $root.geyser.SubscribeRequestFilterBlocks();
            if (object.accountInclude) {
                if (!Array.isArray(object.accountInclude))
                    throw TypeError(".geyser.SubscribeRequestFilterBlocks.accountInclude: array expected");
                message.accountInclude = [];
                for (var i = 0; i < object.accountInclude.length; ++i)
                    message.accountInclude[i] = String(object.accountInclude[i]);
            }
            if (object.includeTransactions != null)
                message.includeTransactions = Boolean(object.includeTransactions);
            if (object.includeAccounts != null)
                message.includeAccounts = Boolean(object.includeAccounts);
            if (object.includeEntries != null)
                message.includeEntries = Boolean(object.includeEntries);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeRequestFilterBlocks message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @static
         * @param {geyser.SubscribeRequestFilterBlocks} message SubscribeRequestFilterBlocks
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeRequestFilterBlocks.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.accountInclude = [];
            if (message.accountInclude && message.accountInclude.length) {
                object.accountInclude = [];
                for (var j = 0; j < message.accountInclude.length; ++j)
                    object.accountInclude[j] = message.accountInclude[j];
            }
            if (message.includeTransactions != null && message.hasOwnProperty("includeTransactions")) {
                object.includeTransactions = message.includeTransactions;
                if (options.oneofs)
                    object._includeTransactions = "includeTransactions";
            }
            if (message.includeAccounts != null && message.hasOwnProperty("includeAccounts")) {
                object.includeAccounts = message.includeAccounts;
                if (options.oneofs)
                    object._includeAccounts = "includeAccounts";
            }
            if (message.includeEntries != null && message.hasOwnProperty("includeEntries")) {
                object.includeEntries = message.includeEntries;
                if (options.oneofs)
                    object._includeEntries = "includeEntries";
            }
            return object;
        };

        /**
         * Converts this SubscribeRequestFilterBlocks to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeRequestFilterBlocks.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeRequestFilterBlocks
         * @function getTypeUrl
         * @memberof geyser.SubscribeRequestFilterBlocks
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeRequestFilterBlocks.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeRequestFilterBlocks";
        };

        return SubscribeRequestFilterBlocks;
    })();

    geyser.SubscribeRequestFilterBlocksMeta = (function() {

        /**
         * Properties of a SubscribeRequestFilterBlocksMeta.
         * @memberof geyser
         * @interface ISubscribeRequestFilterBlocksMeta
         */

        /**
         * Constructs a new SubscribeRequestFilterBlocksMeta.
         * @memberof geyser
         * @classdesc Represents a SubscribeRequestFilterBlocksMeta.
         * @implements ISubscribeRequestFilterBlocksMeta
         * @constructor
         * @param {geyser.ISubscribeRequestFilterBlocksMeta=} [properties] Properties to set
         */
        function SubscribeRequestFilterBlocksMeta(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SubscribeRequestFilterBlocksMeta instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeRequestFilterBlocksMeta
         * @static
         * @param {geyser.ISubscribeRequestFilterBlocksMeta=} [properties] Properties to set
         * @returns {geyser.SubscribeRequestFilterBlocksMeta} SubscribeRequestFilterBlocksMeta instance
         */
        SubscribeRequestFilterBlocksMeta.create = function create(properties) {
            return new SubscribeRequestFilterBlocksMeta(properties);
        };

        /**
         * Encodes the specified SubscribeRequestFilterBlocksMeta message. Does not implicitly {@link geyser.SubscribeRequestFilterBlocksMeta.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeRequestFilterBlocksMeta
         * @static
         * @param {geyser.ISubscribeRequestFilterBlocksMeta} message SubscribeRequestFilterBlocksMeta message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterBlocksMeta.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SubscribeRequestFilterBlocksMeta message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterBlocksMeta.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeRequestFilterBlocksMeta
         * @static
         * @param {geyser.ISubscribeRequestFilterBlocksMeta} message SubscribeRequestFilterBlocksMeta message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterBlocksMeta.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeRequestFilterBlocksMeta message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeRequestFilterBlocksMeta
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeRequestFilterBlocksMeta} SubscribeRequestFilterBlocksMeta
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterBlocksMeta.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeRequestFilterBlocksMeta();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeRequestFilterBlocksMeta message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeRequestFilterBlocksMeta
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeRequestFilterBlocksMeta} SubscribeRequestFilterBlocksMeta
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterBlocksMeta.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeRequestFilterBlocksMeta message.
         * @function verify
         * @memberof geyser.SubscribeRequestFilterBlocksMeta
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeRequestFilterBlocksMeta.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SubscribeRequestFilterBlocksMeta message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeRequestFilterBlocksMeta
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeRequestFilterBlocksMeta} SubscribeRequestFilterBlocksMeta
         */
        SubscribeRequestFilterBlocksMeta.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeRequestFilterBlocksMeta)
                return object;
            return new $root.geyser.SubscribeRequestFilterBlocksMeta();
        };

        /**
         * Creates a plain object from a SubscribeRequestFilterBlocksMeta message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeRequestFilterBlocksMeta
         * @static
         * @param {geyser.SubscribeRequestFilterBlocksMeta} message SubscribeRequestFilterBlocksMeta
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeRequestFilterBlocksMeta.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SubscribeRequestFilterBlocksMeta to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeRequestFilterBlocksMeta
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeRequestFilterBlocksMeta.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeRequestFilterBlocksMeta
         * @function getTypeUrl
         * @memberof geyser.SubscribeRequestFilterBlocksMeta
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeRequestFilterBlocksMeta.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeRequestFilterBlocksMeta";
        };

        return SubscribeRequestFilterBlocksMeta;
    })();

    geyser.SubscribeRequestFilterEntry = (function() {

        /**
         * Properties of a SubscribeRequestFilterEntry.
         * @memberof geyser
         * @interface ISubscribeRequestFilterEntry
         */

        /**
         * Constructs a new SubscribeRequestFilterEntry.
         * @memberof geyser
         * @classdesc Represents a SubscribeRequestFilterEntry.
         * @implements ISubscribeRequestFilterEntry
         * @constructor
         * @param {geyser.ISubscribeRequestFilterEntry=} [properties] Properties to set
         */
        function SubscribeRequestFilterEntry(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SubscribeRequestFilterEntry instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeRequestFilterEntry
         * @static
         * @param {geyser.ISubscribeRequestFilterEntry=} [properties] Properties to set
         * @returns {geyser.SubscribeRequestFilterEntry} SubscribeRequestFilterEntry instance
         */
        SubscribeRequestFilterEntry.create = function create(properties) {
            return new SubscribeRequestFilterEntry(properties);
        };

        /**
         * Encodes the specified SubscribeRequestFilterEntry message. Does not implicitly {@link geyser.SubscribeRequestFilterEntry.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeRequestFilterEntry
         * @static
         * @param {geyser.ISubscribeRequestFilterEntry} message SubscribeRequestFilterEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SubscribeRequestFilterEntry message, length delimited. Does not implicitly {@link geyser.SubscribeRequestFilterEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeRequestFilterEntry
         * @static
         * @param {geyser.ISubscribeRequestFilterEntry} message SubscribeRequestFilterEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestFilterEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeRequestFilterEntry message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeRequestFilterEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeRequestFilterEntry} SubscribeRequestFilterEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterEntry.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeRequestFilterEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeRequestFilterEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeRequestFilterEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeRequestFilterEntry} SubscribeRequestFilterEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestFilterEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeRequestFilterEntry message.
         * @function verify
         * @memberof geyser.SubscribeRequestFilterEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeRequestFilterEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SubscribeRequestFilterEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeRequestFilterEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeRequestFilterEntry} SubscribeRequestFilterEntry
         */
        SubscribeRequestFilterEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeRequestFilterEntry)
                return object;
            return new $root.geyser.SubscribeRequestFilterEntry();
        };

        /**
         * Creates a plain object from a SubscribeRequestFilterEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeRequestFilterEntry
         * @static
         * @param {geyser.SubscribeRequestFilterEntry} message SubscribeRequestFilterEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeRequestFilterEntry.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SubscribeRequestFilterEntry to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeRequestFilterEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeRequestFilterEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeRequestFilterEntry
         * @function getTypeUrl
         * @memberof geyser.SubscribeRequestFilterEntry
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeRequestFilterEntry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeRequestFilterEntry";
        };

        return SubscribeRequestFilterEntry;
    })();

    geyser.SubscribeRequestAccountsDataSlice = (function() {

        /**
         * Properties of a SubscribeRequestAccountsDataSlice.
         * @memberof geyser
         * @interface ISubscribeRequestAccountsDataSlice
         * @property {number|Long|null} [offset] SubscribeRequestAccountsDataSlice offset
         * @property {number|Long|null} [length] SubscribeRequestAccountsDataSlice length
         */

        /**
         * Constructs a new SubscribeRequestAccountsDataSlice.
         * @memberof geyser
         * @classdesc Represents a SubscribeRequestAccountsDataSlice.
         * @implements ISubscribeRequestAccountsDataSlice
         * @constructor
         * @param {geyser.ISubscribeRequestAccountsDataSlice=} [properties] Properties to set
         */
        function SubscribeRequestAccountsDataSlice(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeRequestAccountsDataSlice offset.
         * @member {number|Long} offset
         * @memberof geyser.SubscribeRequestAccountsDataSlice
         * @instance
         */
        SubscribeRequestAccountsDataSlice.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeRequestAccountsDataSlice length.
         * @member {number|Long} length
         * @memberof geyser.SubscribeRequestAccountsDataSlice
         * @instance
         */
        SubscribeRequestAccountsDataSlice.prototype.length = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SubscribeRequestAccountsDataSlice instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeRequestAccountsDataSlice
         * @static
         * @param {geyser.ISubscribeRequestAccountsDataSlice=} [properties] Properties to set
         * @returns {geyser.SubscribeRequestAccountsDataSlice} SubscribeRequestAccountsDataSlice instance
         */
        SubscribeRequestAccountsDataSlice.create = function create(properties) {
            return new SubscribeRequestAccountsDataSlice(properties);
        };

        /**
         * Encodes the specified SubscribeRequestAccountsDataSlice message. Does not implicitly {@link geyser.SubscribeRequestAccountsDataSlice.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeRequestAccountsDataSlice
         * @static
         * @param {geyser.ISubscribeRequestAccountsDataSlice} message SubscribeRequestAccountsDataSlice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestAccountsDataSlice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.offset);
            if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.length);
            return writer;
        };

        /**
         * Encodes the specified SubscribeRequestAccountsDataSlice message, length delimited. Does not implicitly {@link geyser.SubscribeRequestAccountsDataSlice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeRequestAccountsDataSlice
         * @static
         * @param {geyser.ISubscribeRequestAccountsDataSlice} message SubscribeRequestAccountsDataSlice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestAccountsDataSlice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeRequestAccountsDataSlice message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeRequestAccountsDataSlice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeRequestAccountsDataSlice} SubscribeRequestAccountsDataSlice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestAccountsDataSlice.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeRequestAccountsDataSlice();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.offset = reader.uint64();
                        break;
                    }
                case 2: {
                        message.length = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeRequestAccountsDataSlice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeRequestAccountsDataSlice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeRequestAccountsDataSlice} SubscribeRequestAccountsDataSlice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestAccountsDataSlice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeRequestAccountsDataSlice message.
         * @function verify
         * @memberof geyser.SubscribeRequestAccountsDataSlice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeRequestAccountsDataSlice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))
                    return "offset: integer|Long expected";
            if (message.length != null && message.hasOwnProperty("length"))
                if (!$util.isInteger(message.length) && !(message.length && $util.isInteger(message.length.low) && $util.isInteger(message.length.high)))
                    return "length: integer|Long expected";
            return null;
        };

        /**
         * Creates a SubscribeRequestAccountsDataSlice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeRequestAccountsDataSlice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeRequestAccountsDataSlice} SubscribeRequestAccountsDataSlice
         */
        SubscribeRequestAccountsDataSlice.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeRequestAccountsDataSlice)
                return object;
            var message = new $root.geyser.SubscribeRequestAccountsDataSlice();
            if (object.offset != null)
                if ($util.Long)
                    (message.offset = $util.Long.fromValue(object.offset)).unsigned = true;
                else if (typeof object.offset === "string")
                    message.offset = parseInt(object.offset, 10);
                else if (typeof object.offset === "number")
                    message.offset = object.offset;
                else if (typeof object.offset === "object")
                    message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber(true);
            if (object.length != null)
                if ($util.Long)
                    (message.length = $util.Long.fromValue(object.length)).unsigned = true;
                else if (typeof object.length === "string")
                    message.length = parseInt(object.length, 10);
                else if (typeof object.length === "number")
                    message.length = object.length;
                else if (typeof object.length === "object")
                    message.length = new $util.LongBits(object.length.low >>> 0, object.length.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeRequestAccountsDataSlice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeRequestAccountsDataSlice
         * @static
         * @param {geyser.SubscribeRequestAccountsDataSlice} message SubscribeRequestAccountsDataSlice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeRequestAccountsDataSlice.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.offset = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.length = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.length = options.longs === String ? "0" : 0;
            }
            if (message.offset != null && message.hasOwnProperty("offset"))
                if (typeof message.offset === "number")
                    object.offset = options.longs === String ? String(message.offset) : message.offset;
                else
                    object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber(true) : message.offset;
            if (message.length != null && message.hasOwnProperty("length"))
                if (typeof message.length === "number")
                    object.length = options.longs === String ? String(message.length) : message.length;
                else
                    object.length = options.longs === String ? $util.Long.prototype.toString.call(message.length) : options.longs === Number ? new $util.LongBits(message.length.low >>> 0, message.length.high >>> 0).toNumber(true) : message.length;
            return object;
        };

        /**
         * Converts this SubscribeRequestAccountsDataSlice to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeRequestAccountsDataSlice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeRequestAccountsDataSlice.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeRequestAccountsDataSlice
         * @function getTypeUrl
         * @memberof geyser.SubscribeRequestAccountsDataSlice
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeRequestAccountsDataSlice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeRequestAccountsDataSlice";
        };

        return SubscribeRequestAccountsDataSlice;
    })();

    geyser.SubscribeRequestPing = (function() {

        /**
         * Properties of a SubscribeRequestPing.
         * @memberof geyser
         * @interface ISubscribeRequestPing
         * @property {number|null} [id] SubscribeRequestPing id
         */

        /**
         * Constructs a new SubscribeRequestPing.
         * @memberof geyser
         * @classdesc Represents a SubscribeRequestPing.
         * @implements ISubscribeRequestPing
         * @constructor
         * @param {geyser.ISubscribeRequestPing=} [properties] Properties to set
         */
        function SubscribeRequestPing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeRequestPing id.
         * @member {number} id
         * @memberof geyser.SubscribeRequestPing
         * @instance
         */
        SubscribeRequestPing.prototype.id = 0;

        /**
         * Creates a new SubscribeRequestPing instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeRequestPing
         * @static
         * @param {geyser.ISubscribeRequestPing=} [properties] Properties to set
         * @returns {geyser.SubscribeRequestPing} SubscribeRequestPing instance
         */
        SubscribeRequestPing.create = function create(properties) {
            return new SubscribeRequestPing(properties);
        };

        /**
         * Encodes the specified SubscribeRequestPing message. Does not implicitly {@link geyser.SubscribeRequestPing.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeRequestPing
         * @static
         * @param {geyser.ISubscribeRequestPing} message SubscribeRequestPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestPing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            return writer;
        };

        /**
         * Encodes the specified SubscribeRequestPing message, length delimited. Does not implicitly {@link geyser.SubscribeRequestPing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeRequestPing
         * @static
         * @param {geyser.ISubscribeRequestPing} message SubscribeRequestPing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequestPing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeRequestPing message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeRequestPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeRequestPing} SubscribeRequestPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestPing.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeRequestPing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeRequestPing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeRequestPing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeRequestPing} SubscribeRequestPing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequestPing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeRequestPing message.
         * @function verify
         * @memberof geyser.SubscribeRequestPing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeRequestPing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        /**
         * Creates a SubscribeRequestPing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeRequestPing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeRequestPing} SubscribeRequestPing
         */
        SubscribeRequestPing.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeRequestPing)
                return object;
            var message = new $root.geyser.SubscribeRequestPing();
            if (object.id != null)
                message.id = object.id | 0;
            return message;
        };

        /**
         * Creates a plain object from a SubscribeRequestPing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeRequestPing
         * @static
         * @param {geyser.SubscribeRequestPing} message SubscribeRequestPing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeRequestPing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this SubscribeRequestPing to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeRequestPing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeRequestPing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeRequestPing
         * @function getTypeUrl
         * @memberof geyser.SubscribeRequestPing
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeRequestPing.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeRequestPing";
        };

        return SubscribeRequestPing;
    })();

    geyser.SubscribeUpdate = (function() {

        /**
         * Properties of a SubscribeUpdate.
         * @memberof geyser
         * @interface ISubscribeUpdate
         * @property {Array.<string>|null} [filters] SubscribeUpdate filters
         * @property {geyser.ISubscribeUpdateAccount|null} [account] SubscribeUpdate account
         * @property {geyser.ISubscribeUpdateSlot|null} [slot] SubscribeUpdate slot
         * @property {geyser.ISubscribeUpdateTransaction|null} [transaction] SubscribeUpdate transaction
         * @property {geyser.ISubscribeUpdateTransactionStatus|null} [transactionStatus] SubscribeUpdate transactionStatus
         * @property {geyser.ISubscribeUpdateBlock|null} [block] SubscribeUpdate block
         * @property {geyser.ISubscribeUpdatePing|null} [ping] SubscribeUpdate ping
         * @property {geyser.ISubscribeUpdatePong|null} [pong] SubscribeUpdate pong
         * @property {geyser.ISubscribeUpdateBlockMeta|null} [blockMeta] SubscribeUpdate blockMeta
         * @property {geyser.ISubscribeUpdateEntry|null} [entry] SubscribeUpdate entry
         * @property {google.protobuf.ITimestamp|null} [createdAt] SubscribeUpdate createdAt
         */

        /**
         * Constructs a new SubscribeUpdate.
         * @memberof geyser
         * @classdesc Represents a SubscribeUpdate.
         * @implements ISubscribeUpdate
         * @constructor
         * @param {geyser.ISubscribeUpdate=} [properties] Properties to set
         */
        function SubscribeUpdate(properties) {
            this.filters = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeUpdate filters.
         * @member {Array.<string>} filters
         * @memberof geyser.SubscribeUpdate
         * @instance
         */
        SubscribeUpdate.prototype.filters = $util.emptyArray;

        /**
         * SubscribeUpdate account.
         * @member {geyser.ISubscribeUpdateAccount|null|undefined} account
         * @memberof geyser.SubscribeUpdate
         * @instance
         */
        SubscribeUpdate.prototype.account = null;

        /**
         * SubscribeUpdate slot.
         * @member {geyser.ISubscribeUpdateSlot|null|undefined} slot
         * @memberof geyser.SubscribeUpdate
         * @instance
         */
        SubscribeUpdate.prototype.slot = null;

        /**
         * SubscribeUpdate transaction.
         * @member {geyser.ISubscribeUpdateTransaction|null|undefined} transaction
         * @memberof geyser.SubscribeUpdate
         * @instance
         */
        SubscribeUpdate.prototype.transaction = null;

        /**
         * SubscribeUpdate transactionStatus.
         * @member {geyser.ISubscribeUpdateTransactionStatus|null|undefined} transactionStatus
         * @memberof geyser.SubscribeUpdate
         * @instance
         */
        SubscribeUpdate.prototype.transactionStatus = null;

        /**
         * SubscribeUpdate block.
         * @member {geyser.ISubscribeUpdateBlock|null|undefined} block
         * @memberof geyser.SubscribeUpdate
         * @instance
         */
        SubscribeUpdate.prototype.block = null;

        /**
         * SubscribeUpdate ping.
         * @member {geyser.ISubscribeUpdatePing|null|undefined} ping
         * @memberof geyser.SubscribeUpdate
         * @instance
         */
        SubscribeUpdate.prototype.ping = null;

        /**
         * SubscribeUpdate pong.
         * @member {geyser.ISubscribeUpdatePong|null|undefined} pong
         * @memberof geyser.SubscribeUpdate
         * @instance
         */
        SubscribeUpdate.prototype.pong = null;

        /**
         * SubscribeUpdate blockMeta.
         * @member {geyser.ISubscribeUpdateBlockMeta|null|undefined} blockMeta
         * @memberof geyser.SubscribeUpdate
         * @instance
         */
        SubscribeUpdate.prototype.blockMeta = null;

        /**
         * SubscribeUpdate entry.
         * @member {geyser.ISubscribeUpdateEntry|null|undefined} entry
         * @memberof geyser.SubscribeUpdate
         * @instance
         */
        SubscribeUpdate.prototype.entry = null;

        /**
         * SubscribeUpdate createdAt.
         * @member {google.protobuf.ITimestamp|null|undefined} createdAt
         * @memberof geyser.SubscribeUpdate
         * @instance
         */
        SubscribeUpdate.prototype.createdAt = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribeUpdate updateOneof.
         * @member {"account"|"slot"|"transaction"|"transactionStatus"|"block"|"ping"|"pong"|"blockMeta"|"entry"|undefined} updateOneof
         * @memberof geyser.SubscribeUpdate
         * @instance
         */
        Object.defineProperty(SubscribeUpdate.prototype, "updateOneof", {
            get: $util.oneOfGetter($oneOfFields = ["account", "slot", "transaction", "transactionStatus", "block", "ping", "pong", "blockMeta", "entry"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribeUpdate instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeUpdate
         * @static
         * @param {geyser.ISubscribeUpdate=} [properties] Properties to set
         * @returns {geyser.SubscribeUpdate} SubscribeUpdate instance
         */
        SubscribeUpdate.create = function create(properties) {
            return new SubscribeUpdate(properties);
        };

        /**
         * Encodes the specified SubscribeUpdate message. Does not implicitly {@link geyser.SubscribeUpdate.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeUpdate
         * @static
         * @param {geyser.ISubscribeUpdate} message SubscribeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filters != null && message.filters.length)
                for (var i = 0; i < message.filters.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.filters[i]);
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                $root.geyser.SubscribeUpdateAccount.encode(message.account, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                $root.geyser.SubscribeUpdateSlot.encode(message.slot, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                $root.geyser.SubscribeUpdateTransaction.encode(message.transaction, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                $root.geyser.SubscribeUpdateBlock.encode(message.block, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.ping != null && Object.hasOwnProperty.call(message, "ping"))
                $root.geyser.SubscribeUpdatePing.encode(message.ping, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.blockMeta != null && Object.hasOwnProperty.call(message, "blockMeta"))
                $root.geyser.SubscribeUpdateBlockMeta.encode(message.blockMeta, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.entry != null && Object.hasOwnProperty.call(message, "entry"))
                $root.geyser.SubscribeUpdateEntry.encode(message.entry, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.pong != null && Object.hasOwnProperty.call(message, "pong"))
                $root.geyser.SubscribeUpdatePong.encode(message.pong, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.transactionStatus != null && Object.hasOwnProperty.call(message, "transactionStatus"))
                $root.geyser.SubscribeUpdateTransactionStatus.encode(message.transactionStatus, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.createdAt != null && Object.hasOwnProperty.call(message, "createdAt"))
                $root.google.protobuf.Timestamp.encode(message.createdAt, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubscribeUpdate message, length delimited. Does not implicitly {@link geyser.SubscribeUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeUpdate
         * @static
         * @param {geyser.ISubscribeUpdate} message SubscribeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeUpdate} SubscribeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdate.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.filters && message.filters.length))
                            message.filters = [];
                        message.filters.push(reader.string());
                        break;
                    }
                case 2: {
                        message.account = $root.geyser.SubscribeUpdateAccount.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.slot = $root.geyser.SubscribeUpdateSlot.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.transaction = $root.geyser.SubscribeUpdateTransaction.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.transactionStatus = $root.geyser.SubscribeUpdateTransactionStatus.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.block = $root.geyser.SubscribeUpdateBlock.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.ping = $root.geyser.SubscribeUpdatePing.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.pong = $root.geyser.SubscribeUpdatePong.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.blockMeta = $root.geyser.SubscribeUpdateBlockMeta.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.entry = $root.geyser.SubscribeUpdateEntry.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.createdAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeUpdate} SubscribeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeUpdate message.
         * @function verify
         * @memberof geyser.SubscribeUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.filters != null && message.hasOwnProperty("filters")) {
                if (!Array.isArray(message.filters))
                    return "filters: array expected";
                for (var i = 0; i < message.filters.length; ++i)
                    if (!$util.isString(message.filters[i]))
                        return "filters: string[] expected";
            }
            if (message.account != null && message.hasOwnProperty("account")) {
                properties.updateOneof = 1;
                {
                    var error = $root.geyser.SubscribeUpdateAccount.verify(message.account);
                    if (error)
                        return "account." + error;
                }
            }
            if (message.slot != null && message.hasOwnProperty("slot")) {
                if (properties.updateOneof === 1)
                    return "updateOneof: multiple values";
                properties.updateOneof = 1;
                {
                    var error = $root.geyser.SubscribeUpdateSlot.verify(message.slot);
                    if (error)
                        return "slot." + error;
                }
            }
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                if (properties.updateOneof === 1)
                    return "updateOneof: multiple values";
                properties.updateOneof = 1;
                {
                    var error = $root.geyser.SubscribeUpdateTransaction.verify(message.transaction);
                    if (error)
                        return "transaction." + error;
                }
            }
            if (message.transactionStatus != null && message.hasOwnProperty("transactionStatus")) {
                if (properties.updateOneof === 1)
                    return "updateOneof: multiple values";
                properties.updateOneof = 1;
                {
                    var error = $root.geyser.SubscribeUpdateTransactionStatus.verify(message.transactionStatus);
                    if (error)
                        return "transactionStatus." + error;
                }
            }
            if (message.block != null && message.hasOwnProperty("block")) {
                if (properties.updateOneof === 1)
                    return "updateOneof: multiple values";
                properties.updateOneof = 1;
                {
                    var error = $root.geyser.SubscribeUpdateBlock.verify(message.block);
                    if (error)
                        return "block." + error;
                }
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                if (properties.updateOneof === 1)
                    return "updateOneof: multiple values";
                properties.updateOneof = 1;
                {
                    var error = $root.geyser.SubscribeUpdatePing.verify(message.ping);
                    if (error)
                        return "ping." + error;
                }
            }
            if (message.pong != null && message.hasOwnProperty("pong")) {
                if (properties.updateOneof === 1)
                    return "updateOneof: multiple values";
                properties.updateOneof = 1;
                {
                    var error = $root.geyser.SubscribeUpdatePong.verify(message.pong);
                    if (error)
                        return "pong." + error;
                }
            }
            if (message.blockMeta != null && message.hasOwnProperty("blockMeta")) {
                if (properties.updateOneof === 1)
                    return "updateOneof: multiple values";
                properties.updateOneof = 1;
                {
                    var error = $root.geyser.SubscribeUpdateBlockMeta.verify(message.blockMeta);
                    if (error)
                        return "blockMeta." + error;
                }
            }
            if (message.entry != null && message.hasOwnProperty("entry")) {
                if (properties.updateOneof === 1)
                    return "updateOneof: multiple values";
                properties.updateOneof = 1;
                {
                    var error = $root.geyser.SubscribeUpdateEntry.verify(message.entry);
                    if (error)
                        return "entry." + error;
                }
            }
            if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                var error = $root.google.protobuf.Timestamp.verify(message.createdAt);
                if (error)
                    return "createdAt." + error;
            }
            return null;
        };

        /**
         * Creates a SubscribeUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeUpdate} SubscribeUpdate
         */
        SubscribeUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeUpdate)
                return object;
            var message = new $root.geyser.SubscribeUpdate();
            if (object.filters) {
                if (!Array.isArray(object.filters))
                    throw TypeError(".geyser.SubscribeUpdate.filters: array expected");
                message.filters = [];
                for (var i = 0; i < object.filters.length; ++i)
                    message.filters[i] = String(object.filters[i]);
            }
            if (object.account != null) {
                if (typeof object.account !== "object")
                    throw TypeError(".geyser.SubscribeUpdate.account: object expected");
                message.account = $root.geyser.SubscribeUpdateAccount.fromObject(object.account);
            }
            if (object.slot != null) {
                if (typeof object.slot !== "object")
                    throw TypeError(".geyser.SubscribeUpdate.slot: object expected");
                message.slot = $root.geyser.SubscribeUpdateSlot.fromObject(object.slot);
            }
            if (object.transaction != null) {
                if (typeof object.transaction !== "object")
                    throw TypeError(".geyser.SubscribeUpdate.transaction: object expected");
                message.transaction = $root.geyser.SubscribeUpdateTransaction.fromObject(object.transaction);
            }
            if (object.transactionStatus != null) {
                if (typeof object.transactionStatus !== "object")
                    throw TypeError(".geyser.SubscribeUpdate.transactionStatus: object expected");
                message.transactionStatus = $root.geyser.SubscribeUpdateTransactionStatus.fromObject(object.transactionStatus);
            }
            if (object.block != null) {
                if (typeof object.block !== "object")
                    throw TypeError(".geyser.SubscribeUpdate.block: object expected");
                message.block = $root.geyser.SubscribeUpdateBlock.fromObject(object.block);
            }
            if (object.ping != null) {
                if (typeof object.ping !== "object")
                    throw TypeError(".geyser.SubscribeUpdate.ping: object expected");
                message.ping = $root.geyser.SubscribeUpdatePing.fromObject(object.ping);
            }
            if (object.pong != null) {
                if (typeof object.pong !== "object")
                    throw TypeError(".geyser.SubscribeUpdate.pong: object expected");
                message.pong = $root.geyser.SubscribeUpdatePong.fromObject(object.pong);
            }
            if (object.blockMeta != null) {
                if (typeof object.blockMeta !== "object")
                    throw TypeError(".geyser.SubscribeUpdate.blockMeta: object expected");
                message.blockMeta = $root.geyser.SubscribeUpdateBlockMeta.fromObject(object.blockMeta);
            }
            if (object.entry != null) {
                if (typeof object.entry !== "object")
                    throw TypeError(".geyser.SubscribeUpdate.entry: object expected");
                message.entry = $root.geyser.SubscribeUpdateEntry.fromObject(object.entry);
            }
            if (object.createdAt != null) {
                if (typeof object.createdAt !== "object")
                    throw TypeError(".geyser.SubscribeUpdate.createdAt: object expected");
                message.createdAt = $root.google.protobuf.Timestamp.fromObject(object.createdAt);
            }
            return message;
        };

        /**
         * Creates a plain object from a SubscribeUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeUpdate
         * @static
         * @param {geyser.SubscribeUpdate} message SubscribeUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.filters = [];
            if (options.defaults)
                object.createdAt = null;
            if (message.filters && message.filters.length) {
                object.filters = [];
                for (var j = 0; j < message.filters.length; ++j)
                    object.filters[j] = message.filters[j];
            }
            if (message.account != null && message.hasOwnProperty("account")) {
                object.account = $root.geyser.SubscribeUpdateAccount.toObject(message.account, options);
                if (options.oneofs)
                    object.updateOneof = "account";
            }
            if (message.slot != null && message.hasOwnProperty("slot")) {
                object.slot = $root.geyser.SubscribeUpdateSlot.toObject(message.slot, options);
                if (options.oneofs)
                    object.updateOneof = "slot";
            }
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                object.transaction = $root.geyser.SubscribeUpdateTransaction.toObject(message.transaction, options);
                if (options.oneofs)
                    object.updateOneof = "transaction";
            }
            if (message.block != null && message.hasOwnProperty("block")) {
                object.block = $root.geyser.SubscribeUpdateBlock.toObject(message.block, options);
                if (options.oneofs)
                    object.updateOneof = "block";
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                object.ping = $root.geyser.SubscribeUpdatePing.toObject(message.ping, options);
                if (options.oneofs)
                    object.updateOneof = "ping";
            }
            if (message.blockMeta != null && message.hasOwnProperty("blockMeta")) {
                object.blockMeta = $root.geyser.SubscribeUpdateBlockMeta.toObject(message.blockMeta, options);
                if (options.oneofs)
                    object.updateOneof = "blockMeta";
            }
            if (message.entry != null && message.hasOwnProperty("entry")) {
                object.entry = $root.geyser.SubscribeUpdateEntry.toObject(message.entry, options);
                if (options.oneofs)
                    object.updateOneof = "entry";
            }
            if (message.pong != null && message.hasOwnProperty("pong")) {
                object.pong = $root.geyser.SubscribeUpdatePong.toObject(message.pong, options);
                if (options.oneofs)
                    object.updateOneof = "pong";
            }
            if (message.transactionStatus != null && message.hasOwnProperty("transactionStatus")) {
                object.transactionStatus = $root.geyser.SubscribeUpdateTransactionStatus.toObject(message.transactionStatus, options);
                if (options.oneofs)
                    object.updateOneof = "transactionStatus";
            }
            if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                object.createdAt = $root.google.protobuf.Timestamp.toObject(message.createdAt, options);
            return object;
        };

        /**
         * Converts this SubscribeUpdate to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeUpdate
         * @function getTypeUrl
         * @memberof geyser.SubscribeUpdate
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeUpdate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeUpdate";
        };

        return SubscribeUpdate;
    })();

    geyser.SubscribeUpdateBatch = (function() {

        /**
         * Properties of a SubscribeUpdateBatch.
         * @memberof geyser
         * @interface ISubscribeUpdateBatch
         * @property {Array.<geyser.ISubscribeUpdate>|null} [updates] SubscribeUpdateBatch updates
         */

        /**
         * Constructs a new SubscribeUpdateBatch.
         * @memberof geyser
         * @classdesc Represents a SubscribeUpdateBatch.
         * @implements ISubscribeUpdateBatch
         * @constructor
         * @param {geyser.ISubscribeUpdateBatch=} [properties] Properties to set
         */
        function SubscribeUpdateBatch(properties) {
            this.updates = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeUpdateBatch updates.
         * @member {Array.<geyser.ISubscribeUpdate>} updates
         * @memberof geyser.SubscribeUpdateBatch
         * @instance
         */
        SubscribeUpdateBatch.prototype.updates = $util.emptyArray;

        /**
         * Creates a new SubscribeUpdateBatch instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeUpdateBatch
         * @static
         * @param {geyser.ISubscribeUpdateBatch=} [properties] Properties to set
         * @returns {geyser.SubscribeUpdateBatch} SubscribeUpdateBatch instance
         */
        SubscribeUpdateBatch.create = function create(properties) {
            return new SubscribeUpdateBatch(properties);
        };

        /**
         * Encodes the specified SubscribeUpdateBatch message. Does not implicitly {@link geyser.SubscribeUpdateBatch.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeUpdateBatch
         * @static
         * @param {geyser.ISubscribeUpdateBatch} message SubscribeUpdateBatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateBatch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.updates != null && message.updates.length)
                for (var i = 0; i < message.updates.length; ++i)
                    $root.geyser.SubscribeUpdate.encode(message.updates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubscribeUpdateBatch message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateBatch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeUpdateBatch
         * @static
         * @param {geyser.ISubscribeUpdateBatch} message SubscribeUpdateBatch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateBatch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeUpdateBatch message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeUpdateBatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeUpdateBatch} SubscribeUpdateBatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateBatch.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeUpdateBatch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.updates && message.updates.length))
                            message.updates = [];
                        message.updates.push($root.geyser.SubscribeUpdate.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeUpdateBatch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeUpdateBatch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeUpdateBatch} SubscribeUpdateBatch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateBatch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeUpdateBatch message.
         * @function verify
         * @memberof geyser.SubscribeUpdateBatch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeUpdateBatch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.updates != null && message.hasOwnProperty("updates")) {
                if (!Array.isArray(message.updates))
                    return "updates: array expected";
                for (var i = 0; i < message.updates.length; ++i) {
                    var error = $root.geyser.SubscribeUpdate.verify(message.updates[i]);
                    if (error)
                        return "updates." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SubscribeUpdateBatch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeUpdateBatch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeUpdateBatch} SubscribeUpdateBatch
         */
        SubscribeUpdateBatch.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeUpdateBatch)
                return object;
            var message = new $root.geyser.SubscribeUpdateBatch();
            if (object.updates) {
                if (!Array.isArray(object.updates))
                    throw TypeError(".geyser.SubscribeUpdateBatch.updates: array expected");
                message.updates = [];
                for (var i = 0; i < object.updates.length; ++i) {
                    if (typeof object.updates[i] !== "object")
                        throw TypeError(".geyser.SubscribeUpdateBatch.updates: object expected");
                    message.updates[i] = $root.geyser.SubscribeUpdate.fromObject(object.updates[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SubscribeUpdateBatch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeUpdateBatch
         * @static
         * @param {geyser.SubscribeUpdateBatch} message SubscribeUpdateBatch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeUpdateBatch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.updates = [];
            if (message.updates && message.updates.length) {
                object.updates = [];
                for (var j = 0; j < message.updates.length; ++j)
                    object.updates[j] = $root.geyser.SubscribeUpdate.toObject(message.updates[j], options);
            }
            return object;
        };

        /**
         * Converts this SubscribeUpdateBatch to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeUpdateBatch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeUpdateBatch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeUpdateBatch
         * @function getTypeUrl
         * @memberof geyser.SubscribeUpdateBatch
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeUpdateBatch.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeUpdateBatch";
        };

        return SubscribeUpdateBatch;
    })();

    geyser.SubscribeUpdateAccount = (function() {

        /**
         * Properties of a SubscribeUpdateAccount.
         * @memberof geyser
         * @interface ISubscribeUpdateAccount
         * @property {geyser.ISubscribeUpdateAccountInfo|null} [account] SubscribeUpdateAccount account
         * @property {number|Long|null} [slot] SubscribeUpdateAccount slot
         * @property {boolean|null} [isStartup] SubscribeUpdateAccount isStartup
         */

        /**
         * Constructs a new SubscribeUpdateAccount.
         * @memberof geyser
         * @classdesc Represents a SubscribeUpdateAccount.
         * @implements ISubscribeUpdateAccount
         * @constructor
         * @param {geyser.ISubscribeUpdateAccount=} [properties] Properties to set
         */
        function SubscribeUpdateAccount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeUpdateAccount account.
         * @member {geyser.ISubscribeUpdateAccountInfo|null|undefined} account
         * @memberof geyser.SubscribeUpdateAccount
         * @instance
         */
        SubscribeUpdateAccount.prototype.account = null;

        /**
         * SubscribeUpdateAccount slot.
         * @member {number|Long} slot
         * @memberof geyser.SubscribeUpdateAccount
         * @instance
         */
        SubscribeUpdateAccount.prototype.slot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateAccount isStartup.
         * @member {boolean} isStartup
         * @memberof geyser.SubscribeUpdateAccount
         * @instance
         */
        SubscribeUpdateAccount.prototype.isStartup = false;

        /**
         * Creates a new SubscribeUpdateAccount instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeUpdateAccount
         * @static
         * @param {geyser.ISubscribeUpdateAccount=} [properties] Properties to set
         * @returns {geyser.SubscribeUpdateAccount} SubscribeUpdateAccount instance
         */
        SubscribeUpdateAccount.create = function create(properties) {
            return new SubscribeUpdateAccount(properties);
        };

        /**
         * Encodes the specified SubscribeUpdateAccount message. Does not implicitly {@link geyser.SubscribeUpdateAccount.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeUpdateAccount
         * @static
         * @param {geyser.ISubscribeUpdateAccount} message SubscribeUpdateAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateAccount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                $root.geyser.SubscribeUpdateAccountInfo.encode(message.account, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.slot);
            if (message.isStartup != null && Object.hasOwnProperty.call(message, "isStartup"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isStartup);
            return writer;
        };

        /**
         * Encodes the specified SubscribeUpdateAccount message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateAccount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeUpdateAccount
         * @static
         * @param {geyser.ISubscribeUpdateAccount} message SubscribeUpdateAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateAccount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeUpdateAccount message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeUpdateAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeUpdateAccount} SubscribeUpdateAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateAccount.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeUpdateAccount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.account = $root.geyser.SubscribeUpdateAccountInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.slot = reader.uint64();
                        break;
                    }
                case 3: {
                        message.isStartup = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeUpdateAccount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeUpdateAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeUpdateAccount} SubscribeUpdateAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateAccount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeUpdateAccount message.
         * @function verify
         * @memberof geyser.SubscribeUpdateAccount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeUpdateAccount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account")) {
                var error = $root.geyser.SubscribeUpdateAccountInfo.verify(message.account);
                if (error)
                    return "account." + error;
            }
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot) && !(message.slot && $util.isInteger(message.slot.low) && $util.isInteger(message.slot.high)))
                    return "slot: integer|Long expected";
            if (message.isStartup != null && message.hasOwnProperty("isStartup"))
                if (typeof message.isStartup !== "boolean")
                    return "isStartup: boolean expected";
            return null;
        };

        /**
         * Creates a SubscribeUpdateAccount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeUpdateAccount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeUpdateAccount} SubscribeUpdateAccount
         */
        SubscribeUpdateAccount.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeUpdateAccount)
                return object;
            var message = new $root.geyser.SubscribeUpdateAccount();
            if (object.account != null) {
                if (typeof object.account !== "object")
                    throw TypeError(".geyser.SubscribeUpdateAccount.account: object expected");
                message.account = $root.geyser.SubscribeUpdateAccountInfo.fromObject(object.account);
            }
            if (object.slot != null)
                if ($util.Long)
                    (message.slot = $util.Long.fromValue(object.slot)).unsigned = true;
                else if (typeof object.slot === "string")
                    message.slot = parseInt(object.slot, 10);
                else if (typeof object.slot === "number")
                    message.slot = object.slot;
                else if (typeof object.slot === "object")
                    message.slot = new $util.LongBits(object.slot.low >>> 0, object.slot.high >>> 0).toNumber(true);
            if (object.isStartup != null)
                message.isStartup = Boolean(object.isStartup);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeUpdateAccount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeUpdateAccount
         * @static
         * @param {geyser.SubscribeUpdateAccount} message SubscribeUpdateAccount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeUpdateAccount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.account = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.slot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.slot = options.longs === String ? "0" : 0;
                object.isStartup = false;
            }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = $root.geyser.SubscribeUpdateAccountInfo.toObject(message.account, options);
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (typeof message.slot === "number")
                    object.slot = options.longs === String ? String(message.slot) : message.slot;
                else
                    object.slot = options.longs === String ? $util.Long.prototype.toString.call(message.slot) : options.longs === Number ? new $util.LongBits(message.slot.low >>> 0, message.slot.high >>> 0).toNumber(true) : message.slot;
            if (message.isStartup != null && message.hasOwnProperty("isStartup"))
                object.isStartup = message.isStartup;
            return object;
        };

        /**
         * Converts this SubscribeUpdateAccount to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeUpdateAccount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeUpdateAccount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeUpdateAccount
         * @function getTypeUrl
         * @memberof geyser.SubscribeUpdateAccount
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeUpdateAccount.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeUpdateAccount";
        };

        return SubscribeUpdateAccount;
    })();

    geyser.SubscribeUpdateAccountInfo = (function() {

        /**
         * Properties of a SubscribeUpdateAccountInfo.
         * @memberof geyser
         * @interface ISubscribeUpdateAccountInfo
         * @property {Uint8Array|null} [pubkey] SubscribeUpdateAccountInfo pubkey
         * @property {number|Long|null} [lamports] SubscribeUpdateAccountInfo lamports
         * @property {Uint8Array|null} [owner] SubscribeUpdateAccountInfo owner
         * @property {boolean|null} [executable] SubscribeUpdateAccountInfo executable
         * @property {number|Long|null} [rentEpoch] SubscribeUpdateAccountInfo rentEpoch
         * @property {Uint8Array|null} [data] SubscribeUpdateAccountInfo data
         * @property {number|Long|null} [writeVersion] SubscribeUpdateAccountInfo writeVersion
         * @property {Uint8Array|null} [txnSignature] SubscribeUpdateAccountInfo txnSignature
         */

        /**
         * Constructs a new SubscribeUpdateAccountInfo.
         * @memberof geyser
         * @classdesc Represents a SubscribeUpdateAccountInfo.
         * @implements ISubscribeUpdateAccountInfo
         * @constructor
         * @param {geyser.ISubscribeUpdateAccountInfo=} [properties] Properties to set
         */
        function SubscribeUpdateAccountInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeUpdateAccountInfo pubkey.
         * @member {Uint8Array} pubkey
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @instance
         */
        SubscribeUpdateAccountInfo.prototype.pubkey = $util.newBuffer([]);

        /**
         * SubscribeUpdateAccountInfo lamports.
         * @member {number|Long} lamports
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @instance
         */
        SubscribeUpdateAccountInfo.prototype.lamports = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateAccountInfo owner.
         * @member {Uint8Array} owner
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @instance
         */
        SubscribeUpdateAccountInfo.prototype.owner = $util.newBuffer([]);

        /**
         * SubscribeUpdateAccountInfo executable.
         * @member {boolean} executable
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @instance
         */
        SubscribeUpdateAccountInfo.prototype.executable = false;

        /**
         * SubscribeUpdateAccountInfo rentEpoch.
         * @member {number|Long} rentEpoch
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @instance
         */
        SubscribeUpdateAccountInfo.prototype.rentEpoch = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateAccountInfo data.
         * @member {Uint8Array} data
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @instance
         */
        SubscribeUpdateAccountInfo.prototype.data = $util.newBuffer([]);

        /**
         * SubscribeUpdateAccountInfo writeVersion.
         * @member {number|Long} writeVersion
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @instance
         */
        SubscribeUpdateAccountInfo.prototype.writeVersion = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateAccountInfo txnSignature.
         * @member {Uint8Array|null|undefined} txnSignature
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @instance
         */
        SubscribeUpdateAccountInfo.prototype.txnSignature = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribeUpdateAccountInfo _txnSignature.
         * @member {"txnSignature"|undefined} _txnSignature
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @instance
         */
        Object.defineProperty(SubscribeUpdateAccountInfo.prototype, "_txnSignature", {
            get: $util.oneOfGetter($oneOfFields = ["txnSignature"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribeUpdateAccountInfo instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @static
         * @param {geyser.ISubscribeUpdateAccountInfo=} [properties] Properties to set
         * @returns {geyser.SubscribeUpdateAccountInfo} SubscribeUpdateAccountInfo instance
         */
        SubscribeUpdateAccountInfo.create = function create(properties) {
            return new SubscribeUpdateAccountInfo(properties);
        };

        /**
         * Encodes the specified SubscribeUpdateAccountInfo message. Does not implicitly {@link geyser.SubscribeUpdateAccountInfo.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @static
         * @param {geyser.ISubscribeUpdateAccountInfo} message SubscribeUpdateAccountInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateAccountInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubkey != null && Object.hasOwnProperty.call(message, "pubkey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pubkey);
            if (message.lamports != null && Object.hasOwnProperty.call(message, "lamports"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.lamports);
            if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.owner);
            if (message.executable != null && Object.hasOwnProperty.call(message, "executable"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.executable);
            if (message.rentEpoch != null && Object.hasOwnProperty.call(message, "rentEpoch"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.rentEpoch);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.data);
            if (message.writeVersion != null && Object.hasOwnProperty.call(message, "writeVersion"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.writeVersion);
            if (message.txnSignature != null && Object.hasOwnProperty.call(message, "txnSignature"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.txnSignature);
            return writer;
        };

        /**
         * Encodes the specified SubscribeUpdateAccountInfo message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateAccountInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @static
         * @param {geyser.ISubscribeUpdateAccountInfo} message SubscribeUpdateAccountInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateAccountInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeUpdateAccountInfo message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeUpdateAccountInfo} SubscribeUpdateAccountInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateAccountInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeUpdateAccountInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.pubkey = reader.bytes();
                        break;
                    }
                case 2: {
                        message.lamports = reader.uint64();
                        break;
                    }
                case 3: {
                        message.owner = reader.bytes();
                        break;
                    }
                case 4: {
                        message.executable = reader.bool();
                        break;
                    }
                case 5: {
                        message.rentEpoch = reader.uint64();
                        break;
                    }
                case 6: {
                        message.data = reader.bytes();
                        break;
                    }
                case 7: {
                        message.writeVersion = reader.uint64();
                        break;
                    }
                case 8: {
                        message.txnSignature = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeUpdateAccountInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeUpdateAccountInfo} SubscribeUpdateAccountInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateAccountInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeUpdateAccountInfo message.
         * @function verify
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeUpdateAccountInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                if (!(message.pubkey && typeof message.pubkey.length === "number" || $util.isString(message.pubkey)))
                    return "pubkey: buffer expected";
            if (message.lamports != null && message.hasOwnProperty("lamports"))
                if (!$util.isInteger(message.lamports) && !(message.lamports && $util.isInteger(message.lamports.low) && $util.isInteger(message.lamports.high)))
                    return "lamports: integer|Long expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                    return "owner: buffer expected";
            if (message.executable != null && message.hasOwnProperty("executable"))
                if (typeof message.executable !== "boolean")
                    return "executable: boolean expected";
            if (message.rentEpoch != null && message.hasOwnProperty("rentEpoch"))
                if (!$util.isInteger(message.rentEpoch) && !(message.rentEpoch && $util.isInteger(message.rentEpoch.low) && $util.isInteger(message.rentEpoch.high)))
                    return "rentEpoch: integer|Long expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.writeVersion != null && message.hasOwnProperty("writeVersion"))
                if (!$util.isInteger(message.writeVersion) && !(message.writeVersion && $util.isInteger(message.writeVersion.low) && $util.isInteger(message.writeVersion.high)))
                    return "writeVersion: integer|Long expected";
            if (message.txnSignature != null && message.hasOwnProperty("txnSignature")) {
                properties._txnSignature = 1;
                if (!(message.txnSignature && typeof message.txnSignature.length === "number" || $util.isString(message.txnSignature)))
                    return "txnSignature: buffer expected";
            }
            return null;
        };

        /**
         * Creates a SubscribeUpdateAccountInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeUpdateAccountInfo} SubscribeUpdateAccountInfo
         */
        SubscribeUpdateAccountInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeUpdateAccountInfo)
                return object;
            var message = new $root.geyser.SubscribeUpdateAccountInfo();
            if (object.pubkey != null)
                if (typeof object.pubkey === "string")
                    $util.base64.decode(object.pubkey, message.pubkey = $util.newBuffer($util.base64.length(object.pubkey)), 0);
                else if (object.pubkey.length >= 0)
                    message.pubkey = object.pubkey;
            if (object.lamports != null)
                if ($util.Long)
                    (message.lamports = $util.Long.fromValue(object.lamports)).unsigned = true;
                else if (typeof object.lamports === "string")
                    message.lamports = parseInt(object.lamports, 10);
                else if (typeof object.lamports === "number")
                    message.lamports = object.lamports;
                else if (typeof object.lamports === "object")
                    message.lamports = new $util.LongBits(object.lamports.low >>> 0, object.lamports.high >>> 0).toNumber(true);
            if (object.owner != null)
                if (typeof object.owner === "string")
                    $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                else if (object.owner.length >= 0)
                    message.owner = object.owner;
            if (object.executable != null)
                message.executable = Boolean(object.executable);
            if (object.rentEpoch != null)
                if ($util.Long)
                    (message.rentEpoch = $util.Long.fromValue(object.rentEpoch)).unsigned = true;
                else if (typeof object.rentEpoch === "string")
                    message.rentEpoch = parseInt(object.rentEpoch, 10);
                else if (typeof object.rentEpoch === "number")
                    message.rentEpoch = object.rentEpoch;
                else if (typeof object.rentEpoch === "object")
                    message.rentEpoch = new $util.LongBits(object.rentEpoch.low >>> 0, object.rentEpoch.high >>> 0).toNumber(true);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            if (object.writeVersion != null)
                if ($util.Long)
                    (message.writeVersion = $util.Long.fromValue(object.writeVersion)).unsigned = true;
                else if (typeof object.writeVersion === "string")
                    message.writeVersion = parseInt(object.writeVersion, 10);
                else if (typeof object.writeVersion === "number")
                    message.writeVersion = object.writeVersion;
                else if (typeof object.writeVersion === "object")
                    message.writeVersion = new $util.LongBits(object.writeVersion.low >>> 0, object.writeVersion.high >>> 0).toNumber(true);
            if (object.txnSignature != null)
                if (typeof object.txnSignature === "string")
                    $util.base64.decode(object.txnSignature, message.txnSignature = $util.newBuffer($util.base64.length(object.txnSignature)), 0);
                else if (object.txnSignature.length >= 0)
                    message.txnSignature = object.txnSignature;
            return message;
        };

        /**
         * Creates a plain object from a SubscribeUpdateAccountInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @static
         * @param {geyser.SubscribeUpdateAccountInfo} message SubscribeUpdateAccountInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeUpdateAccountInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.pubkey = "";
                else {
                    object.pubkey = [];
                    if (options.bytes !== Array)
                        object.pubkey = $util.newBuffer(object.pubkey);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.lamports = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lamports = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.owner = "";
                else {
                    object.owner = [];
                    if (options.bytes !== Array)
                        object.owner = $util.newBuffer(object.owner);
                }
                object.executable = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.rentEpoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.rentEpoch = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.writeVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.writeVersion = options.longs === String ? "0" : 0;
            }
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                object.pubkey = options.bytes === String ? $util.base64.encode(message.pubkey, 0, message.pubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubkey) : message.pubkey;
            if (message.lamports != null && message.hasOwnProperty("lamports"))
                if (typeof message.lamports === "number")
                    object.lamports = options.longs === String ? String(message.lamports) : message.lamports;
                else
                    object.lamports = options.longs === String ? $util.Long.prototype.toString.call(message.lamports) : options.longs === Number ? new $util.LongBits(message.lamports.low >>> 0, message.lamports.high >>> 0).toNumber(true) : message.lamports;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
            if (message.executable != null && message.hasOwnProperty("executable"))
                object.executable = message.executable;
            if (message.rentEpoch != null && message.hasOwnProperty("rentEpoch"))
                if (typeof message.rentEpoch === "number")
                    object.rentEpoch = options.longs === String ? String(message.rentEpoch) : message.rentEpoch;
                else
                    object.rentEpoch = options.longs === String ? $util.Long.prototype.toString.call(message.rentEpoch) : options.longs === Number ? new $util.LongBits(message.rentEpoch.low >>> 0, message.rentEpoch.high >>> 0).toNumber(true) : message.rentEpoch;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.writeVersion != null && message.hasOwnProperty("writeVersion"))
                if (typeof message.writeVersion === "number")
                    object.writeVersion = options.longs === String ? String(message.writeVersion) : message.writeVersion;
                else
                    object.writeVersion = options.longs === String ? $util.Long.prototype.toString.call(message.writeVersion) : options.longs === Number ? new $util.LongBits(message.writeVersion.low >>> 0, message.writeVersion.high >>> 0).toNumber(true) : message.writeVersion;
            if (message.txnSignature != null && message.hasOwnProperty("txnSignature")) {
                object.txnSignature = options.bytes === String ? $util.base64.encode(message.txnSignature, 0, message.txnSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.txnSignature) : message.txnSignature;
                if (options.oneofs)
                    object._txnSignature = "txnSignature";
            }
            return object;
        };

        /**
         * Converts this SubscribeUpdateAccountInfo to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeUpdateAccountInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeUpdateAccountInfo
         * @function getTypeUrl
         * @memberof geyser.SubscribeUpdateAccountInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeUpdateAccountInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeUpdateAccountInfo";
        };

        return SubscribeUpdateAccountInfo;
    })();

    geyser.SubscribeUpdateSlot = (function() {

        /**
         * Properties of a SubscribeUpdateSlot.
         * @memberof geyser
         * @interface ISubscribeUpdateSlot
         * @property {number|Long|null} [slot] SubscribeUpdateSlot slot
         * @property {number|Long|null} [parent] SubscribeUpdateSlot parent
         * @property {geyser.SlotStatus|null} [status] SubscribeUpdateSlot status
         * @property {string|null} [deadError] SubscribeUpdateSlot deadError
         */

        /**
         * Constructs a new SubscribeUpdateSlot.
         * @memberof geyser
         * @classdesc Represents a SubscribeUpdateSlot.
         * @implements ISubscribeUpdateSlot
         * @constructor
         * @param {geyser.ISubscribeUpdateSlot=} [properties] Properties to set
         */
        function SubscribeUpdateSlot(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeUpdateSlot slot.
         * @member {number|Long} slot
         * @memberof geyser.SubscribeUpdateSlot
         * @instance
         */
        SubscribeUpdateSlot.prototype.slot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateSlot parent.
         * @member {number|Long|null|undefined} parent
         * @memberof geyser.SubscribeUpdateSlot
         * @instance
         */
        SubscribeUpdateSlot.prototype.parent = null;

        /**
         * SubscribeUpdateSlot status.
         * @member {geyser.SlotStatus} status
         * @memberof geyser.SubscribeUpdateSlot
         * @instance
         */
        SubscribeUpdateSlot.prototype.status = 0;

        /**
         * SubscribeUpdateSlot deadError.
         * @member {string|null|undefined} deadError
         * @memberof geyser.SubscribeUpdateSlot
         * @instance
         */
        SubscribeUpdateSlot.prototype.deadError = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribeUpdateSlot _parent.
         * @member {"parent"|undefined} _parent
         * @memberof geyser.SubscribeUpdateSlot
         * @instance
         */
        Object.defineProperty(SubscribeUpdateSlot.prototype, "_parent", {
            get: $util.oneOfGetter($oneOfFields = ["parent"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * SubscribeUpdateSlot _deadError.
         * @member {"deadError"|undefined} _deadError
         * @memberof geyser.SubscribeUpdateSlot
         * @instance
         */
        Object.defineProperty(SubscribeUpdateSlot.prototype, "_deadError", {
            get: $util.oneOfGetter($oneOfFields = ["deadError"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribeUpdateSlot instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeUpdateSlot
         * @static
         * @param {geyser.ISubscribeUpdateSlot=} [properties] Properties to set
         * @returns {geyser.SubscribeUpdateSlot} SubscribeUpdateSlot instance
         */
        SubscribeUpdateSlot.create = function create(properties) {
            return new SubscribeUpdateSlot(properties);
        };

        /**
         * Encodes the specified SubscribeUpdateSlot message. Does not implicitly {@link geyser.SubscribeUpdateSlot.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeUpdateSlot
         * @static
         * @param {geyser.ISubscribeUpdateSlot} message SubscribeUpdateSlot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateSlot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.slot);
            if (message.parent != null && Object.hasOwnProperty.call(message, "parent"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.parent);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
            if (message.deadError != null && Object.hasOwnProperty.call(message, "deadError"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.deadError);
            return writer;
        };

        /**
         * Encodes the specified SubscribeUpdateSlot message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateSlot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeUpdateSlot
         * @static
         * @param {geyser.ISubscribeUpdateSlot} message SubscribeUpdateSlot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateSlot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeUpdateSlot message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeUpdateSlot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeUpdateSlot} SubscribeUpdateSlot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateSlot.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeUpdateSlot();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.slot = reader.uint64();
                        break;
                    }
                case 2: {
                        message.parent = reader.uint64();
                        break;
                    }
                case 3: {
                        message.status = reader.int32();
                        break;
                    }
                case 4: {
                        message.deadError = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeUpdateSlot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeUpdateSlot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeUpdateSlot} SubscribeUpdateSlot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateSlot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeUpdateSlot message.
         * @function verify
         * @memberof geyser.SubscribeUpdateSlot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeUpdateSlot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot) && !(message.slot && $util.isInteger(message.slot.low) && $util.isInteger(message.slot.high)))
                    return "slot: integer|Long expected";
            if (message.parent != null && message.hasOwnProperty("parent")) {
                properties._parent = 1;
                if (!$util.isInteger(message.parent) && !(message.parent && $util.isInteger(message.parent.low) && $util.isInteger(message.parent.high)))
                    return "parent: integer|Long expected";
            }
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.deadError != null && message.hasOwnProperty("deadError")) {
                properties._deadError = 1;
                if (!$util.isString(message.deadError))
                    return "deadError: string expected";
            }
            return null;
        };

        /**
         * Creates a SubscribeUpdateSlot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeUpdateSlot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeUpdateSlot} SubscribeUpdateSlot
         */
        SubscribeUpdateSlot.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeUpdateSlot)
                return object;
            var message = new $root.geyser.SubscribeUpdateSlot();
            if (object.slot != null)
                if ($util.Long)
                    (message.slot = $util.Long.fromValue(object.slot)).unsigned = true;
                else if (typeof object.slot === "string")
                    message.slot = parseInt(object.slot, 10);
                else if (typeof object.slot === "number")
                    message.slot = object.slot;
                else if (typeof object.slot === "object")
                    message.slot = new $util.LongBits(object.slot.low >>> 0, object.slot.high >>> 0).toNumber(true);
            if (object.parent != null)
                if ($util.Long)
                    (message.parent = $util.Long.fromValue(object.parent)).unsigned = true;
                else if (typeof object.parent === "string")
                    message.parent = parseInt(object.parent, 10);
                else if (typeof object.parent === "number")
                    message.parent = object.parent;
                else if (typeof object.parent === "object")
                    message.parent = new $util.LongBits(object.parent.low >>> 0, object.parent.high >>> 0).toNumber(true);
            switch (object.status) {
            default:
                if (typeof object.status === "number") {
                    message.status = object.status;
                    break;
                }
                break;
            case "SLOT_PROCESSED":
            case 0:
                message.status = 0;
                break;
            case "SLOT_CONFIRMED":
            case 1:
                message.status = 1;
                break;
            case "SLOT_FINALIZED":
            case 2:
                message.status = 2;
                break;
            case "SLOT_FIRST_SHRED_RECEIVED":
            case 3:
                message.status = 3;
                break;
            case "SLOT_COMPLETED":
            case 4:
                message.status = 4;
                break;
            case "SLOT_CREATED_BANK":
            case 5:
                message.status = 5;
                break;
            case "SLOT_DEAD":
            case 6:
                message.status = 6;
                break;
            }
            if (object.deadError != null)
                message.deadError = String(object.deadError);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeUpdateSlot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeUpdateSlot
         * @static
         * @param {geyser.SubscribeUpdateSlot} message SubscribeUpdateSlot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeUpdateSlot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.slot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.slot = options.longs === String ? "0" : 0;
                object.status = options.enums === String ? "SLOT_PROCESSED" : 0;
            }
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (typeof message.slot === "number")
                    object.slot = options.longs === String ? String(message.slot) : message.slot;
                else
                    object.slot = options.longs === String ? $util.Long.prototype.toString.call(message.slot) : options.longs === Number ? new $util.LongBits(message.slot.low >>> 0, message.slot.high >>> 0).toNumber(true) : message.slot;
            if (message.parent != null && message.hasOwnProperty("parent")) {
                if (typeof message.parent === "number")
                    object.parent = options.longs === String ? String(message.parent) : message.parent;
                else
                    object.parent = options.longs === String ? $util.Long.prototype.toString.call(message.parent) : options.longs === Number ? new $util.LongBits(message.parent.low >>> 0, message.parent.high >>> 0).toNumber(true) : message.parent;
                if (options.oneofs)
                    object._parent = "parent";
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.geyser.SlotStatus[message.status] === undefined ? message.status : $root.geyser.SlotStatus[message.status] : message.status;
            if (message.deadError != null && message.hasOwnProperty("deadError")) {
                object.deadError = message.deadError;
                if (options.oneofs)
                    object._deadError = "deadError";
            }
            return object;
        };

        /**
         * Converts this SubscribeUpdateSlot to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeUpdateSlot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeUpdateSlot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeUpdateSlot
         * @function getTypeUrl
         * @memberof geyser.SubscribeUpdateSlot
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeUpdateSlot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeUpdateSlot";
        };

        return SubscribeUpdateSlot;
    })();

    geyser.SubscribeUpdateTransaction = (function() {

        /**
         * Properties of a SubscribeUpdateTransaction.
         * @memberof geyser
         * @interface ISubscribeUpdateTransaction
         * @property {geyser.ISubscribeUpdateTransactionInfo|null} [transaction] SubscribeUpdateTransaction transaction
         * @property {number|Long|null} [slot] SubscribeUpdateTransaction slot
         */

        /**
         * Constructs a new SubscribeUpdateTransaction.
         * @memberof geyser
         * @classdesc Represents a SubscribeUpdateTransaction.
         * @implements ISubscribeUpdateTransaction
         * @constructor
         * @param {geyser.ISubscribeUpdateTransaction=} [properties] Properties to set
         */
        function SubscribeUpdateTransaction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeUpdateTransaction transaction.
         * @member {geyser.ISubscribeUpdateTransactionInfo|null|undefined} transaction
         * @memberof geyser.SubscribeUpdateTransaction
         * @instance
         */
        SubscribeUpdateTransaction.prototype.transaction = null;

        /**
         * SubscribeUpdateTransaction slot.
         * @member {number|Long} slot
         * @memberof geyser.SubscribeUpdateTransaction
         * @instance
         */
        SubscribeUpdateTransaction.prototype.slot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SubscribeUpdateTransaction instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeUpdateTransaction
         * @static
         * @param {geyser.ISubscribeUpdateTransaction=} [properties] Properties to set
         * @returns {geyser.SubscribeUpdateTransaction} SubscribeUpdateTransaction instance
         */
        SubscribeUpdateTransaction.create = function create(properties) {
            return new SubscribeUpdateTransaction(properties);
        };

        /**
         * Encodes the specified SubscribeUpdateTransaction message. Does not implicitly {@link geyser.SubscribeUpdateTransaction.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeUpdateTransaction
         * @static
         * @param {geyser.ISubscribeUpdateTransaction} message SubscribeUpdateTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                $root.geyser.SubscribeUpdateTransactionInfo.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.slot);
            return writer;
        };

        /**
         * Encodes the specified SubscribeUpdateTransaction message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeUpdateTransaction
         * @static
         * @param {geyser.ISubscribeUpdateTransaction} message SubscribeUpdateTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeUpdateTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeUpdateTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeUpdateTransaction} SubscribeUpdateTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateTransaction.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeUpdateTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.transaction = $root.geyser.SubscribeUpdateTransactionInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.slot = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeUpdateTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeUpdateTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeUpdateTransaction} SubscribeUpdateTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeUpdateTransaction message.
         * @function verify
         * @memberof geyser.SubscribeUpdateTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeUpdateTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                var error = $root.geyser.SubscribeUpdateTransactionInfo.verify(message.transaction);
                if (error)
                    return "transaction." + error;
            }
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot) && !(message.slot && $util.isInteger(message.slot.low) && $util.isInteger(message.slot.high)))
                    return "slot: integer|Long expected";
            return null;
        };

        /**
         * Creates a SubscribeUpdateTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeUpdateTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeUpdateTransaction} SubscribeUpdateTransaction
         */
        SubscribeUpdateTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeUpdateTransaction)
                return object;
            var message = new $root.geyser.SubscribeUpdateTransaction();
            if (object.transaction != null) {
                if (typeof object.transaction !== "object")
                    throw TypeError(".geyser.SubscribeUpdateTransaction.transaction: object expected");
                message.transaction = $root.geyser.SubscribeUpdateTransactionInfo.fromObject(object.transaction);
            }
            if (object.slot != null)
                if ($util.Long)
                    (message.slot = $util.Long.fromValue(object.slot)).unsigned = true;
                else if (typeof object.slot === "string")
                    message.slot = parseInt(object.slot, 10);
                else if (typeof object.slot === "number")
                    message.slot = object.slot;
                else if (typeof object.slot === "object")
                    message.slot = new $util.LongBits(object.slot.low >>> 0, object.slot.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeUpdateTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeUpdateTransaction
         * @static
         * @param {geyser.SubscribeUpdateTransaction} message SubscribeUpdateTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeUpdateTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.transaction = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.slot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.slot = options.longs === String ? "0" : 0;
            }
            if (message.transaction != null && message.hasOwnProperty("transaction"))
                object.transaction = $root.geyser.SubscribeUpdateTransactionInfo.toObject(message.transaction, options);
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (typeof message.slot === "number")
                    object.slot = options.longs === String ? String(message.slot) : message.slot;
                else
                    object.slot = options.longs === String ? $util.Long.prototype.toString.call(message.slot) : options.longs === Number ? new $util.LongBits(message.slot.low >>> 0, message.slot.high >>> 0).toNumber(true) : message.slot;
            return object;
        };

        /**
         * Converts this SubscribeUpdateTransaction to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeUpdateTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeUpdateTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeUpdateTransaction
         * @function getTypeUrl
         * @memberof geyser.SubscribeUpdateTransaction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeUpdateTransaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeUpdateTransaction";
        };

        return SubscribeUpdateTransaction;
    })();

    geyser.SubscribeUpdateTransactionInfo = (function() {

        /**
         * Properties of a SubscribeUpdateTransactionInfo.
         * @memberof geyser
         * @interface ISubscribeUpdateTransactionInfo
         * @property {Uint8Array|null} [signature] SubscribeUpdateTransactionInfo signature
         * @property {boolean|null} [isVote] SubscribeUpdateTransactionInfo isVote
         * @property {solana.storage.ConfirmedBlock.ITransaction|null} [transaction] SubscribeUpdateTransactionInfo transaction
         * @property {solana.storage.ConfirmedBlock.ITransactionStatusMeta|null} [meta] SubscribeUpdateTransactionInfo meta
         * @property {number|Long|null} [index] SubscribeUpdateTransactionInfo index
         */

        /**
         * Constructs a new SubscribeUpdateTransactionInfo.
         * @memberof geyser
         * @classdesc Represents a SubscribeUpdateTransactionInfo.
         * @implements ISubscribeUpdateTransactionInfo
         * @constructor
         * @param {geyser.ISubscribeUpdateTransactionInfo=} [properties] Properties to set
         */
        function SubscribeUpdateTransactionInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeUpdateTransactionInfo signature.
         * @member {Uint8Array} signature
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @instance
         */
        SubscribeUpdateTransactionInfo.prototype.signature = $util.newBuffer([]);

        /**
         * SubscribeUpdateTransactionInfo isVote.
         * @member {boolean} isVote
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @instance
         */
        SubscribeUpdateTransactionInfo.prototype.isVote = false;

        /**
         * SubscribeUpdateTransactionInfo transaction.
         * @member {solana.storage.ConfirmedBlock.ITransaction|null|undefined} transaction
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @instance
         */
        SubscribeUpdateTransactionInfo.prototype.transaction = null;

        /**
         * SubscribeUpdateTransactionInfo meta.
         * @member {solana.storage.ConfirmedBlock.ITransactionStatusMeta|null|undefined} meta
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @instance
         */
        SubscribeUpdateTransactionInfo.prototype.meta = null;

        /**
         * SubscribeUpdateTransactionInfo index.
         * @member {number|Long} index
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @instance
         */
        SubscribeUpdateTransactionInfo.prototype.index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SubscribeUpdateTransactionInfo instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @static
         * @param {geyser.ISubscribeUpdateTransactionInfo=} [properties] Properties to set
         * @returns {geyser.SubscribeUpdateTransactionInfo} SubscribeUpdateTransactionInfo instance
         */
        SubscribeUpdateTransactionInfo.create = function create(properties) {
            return new SubscribeUpdateTransactionInfo(properties);
        };

        /**
         * Encodes the specified SubscribeUpdateTransactionInfo message. Does not implicitly {@link geyser.SubscribeUpdateTransactionInfo.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @static
         * @param {geyser.ISubscribeUpdateTransactionInfo} message SubscribeUpdateTransactionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateTransactionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
            if (message.isVote != null && Object.hasOwnProperty.call(message, "isVote"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isVote);
            if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                $root.solana.storage.ConfirmedBlock.Transaction.encode(message.transaction, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.meta != null && Object.hasOwnProperty.call(message, "meta"))
                $root.solana.storage.ConfirmedBlock.TransactionStatusMeta.encode(message.meta, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.index);
            return writer;
        };

        /**
         * Encodes the specified SubscribeUpdateTransactionInfo message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateTransactionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @static
         * @param {geyser.ISubscribeUpdateTransactionInfo} message SubscribeUpdateTransactionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateTransactionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeUpdateTransactionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeUpdateTransactionInfo} SubscribeUpdateTransactionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateTransactionInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeUpdateTransactionInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.signature = reader.bytes();
                        break;
                    }
                case 2: {
                        message.isVote = reader.bool();
                        break;
                    }
                case 3: {
                        message.transaction = $root.solana.storage.ConfirmedBlock.Transaction.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.meta = $root.solana.storage.ConfirmedBlock.TransactionStatusMeta.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.index = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeUpdateTransactionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeUpdateTransactionInfo} SubscribeUpdateTransactionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateTransactionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeUpdateTransactionInfo message.
         * @function verify
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeUpdateTransactionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.isVote != null && message.hasOwnProperty("isVote"))
                if (typeof message.isVote !== "boolean")
                    return "isVote: boolean expected";
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                var error = $root.solana.storage.ConfirmedBlock.Transaction.verify(message.transaction);
                if (error)
                    return "transaction." + error;
            }
            if (message.meta != null && message.hasOwnProperty("meta")) {
                var error = $root.solana.storage.ConfirmedBlock.TransactionStatusMeta.verify(message.meta);
                if (error)
                    return "meta." + error;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                    return "index: integer|Long expected";
            return null;
        };

        /**
         * Creates a SubscribeUpdateTransactionInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeUpdateTransactionInfo} SubscribeUpdateTransactionInfo
         */
        SubscribeUpdateTransactionInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeUpdateTransactionInfo)
                return object;
            var message = new $root.geyser.SubscribeUpdateTransactionInfo();
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length >= 0)
                    message.signature = object.signature;
            if (object.isVote != null)
                message.isVote = Boolean(object.isVote);
            if (object.transaction != null) {
                if (typeof object.transaction !== "object")
                    throw TypeError(".geyser.SubscribeUpdateTransactionInfo.transaction: object expected");
                message.transaction = $root.solana.storage.ConfirmedBlock.Transaction.fromObject(object.transaction);
            }
            if (object.meta != null) {
                if (typeof object.meta !== "object")
                    throw TypeError(".geyser.SubscribeUpdateTransactionInfo.meta: object expected");
                message.meta = $root.solana.storage.ConfirmedBlock.TransactionStatusMeta.fromObject(object.meta);
            }
            if (object.index != null)
                if ($util.Long)
                    (message.index = $util.Long.fromValue(object.index)).unsigned = true;
                else if (typeof object.index === "string")
                    message.index = parseInt(object.index, 10);
                else if (typeof object.index === "number")
                    message.index = object.index;
                else if (typeof object.index === "object")
                    message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeUpdateTransactionInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @static
         * @param {geyser.SubscribeUpdateTransactionInfo} message SubscribeUpdateTransactionInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeUpdateTransactionInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
                object.isVote = false;
                object.transaction = null;
                object.meta = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.index = options.longs === String ? "0" : 0;
            }
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.isVote != null && message.hasOwnProperty("isVote"))
                object.isVote = message.isVote;
            if (message.transaction != null && message.hasOwnProperty("transaction"))
                object.transaction = $root.solana.storage.ConfirmedBlock.Transaction.toObject(message.transaction, options);
            if (message.meta != null && message.hasOwnProperty("meta"))
                object.meta = $root.solana.storage.ConfirmedBlock.TransactionStatusMeta.toObject(message.meta, options);
            if (message.index != null && message.hasOwnProperty("index"))
                if (typeof message.index === "number")
                    object.index = options.longs === String ? String(message.index) : message.index;
                else
                    object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber(true) : message.index;
            return object;
        };

        /**
         * Converts this SubscribeUpdateTransactionInfo to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeUpdateTransactionInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeUpdateTransactionInfo
         * @function getTypeUrl
         * @memberof geyser.SubscribeUpdateTransactionInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeUpdateTransactionInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeUpdateTransactionInfo";
        };

        return SubscribeUpdateTransactionInfo;
    })();

    geyser.SubscribeUpdateTransactionStatus = (function() {

        /**
         * Properties of a SubscribeUpdateTransactionStatus.
         * @memberof geyser
         * @interface ISubscribeUpdateTransactionStatus
         * @property {number|Long|null} [slot] SubscribeUpdateTransactionStatus slot
         * @property {Uint8Array|null} [signature] SubscribeUpdateTransactionStatus signature
         * @property {boolean|null} [isVote] SubscribeUpdateTransactionStatus isVote
         * @property {number|Long|null} [index] SubscribeUpdateTransactionStatus index
         * @property {solana.storage.ConfirmedBlock.ITransactionError|null} [err] SubscribeUpdateTransactionStatus err
         */

        /**
         * Constructs a new SubscribeUpdateTransactionStatus.
         * @memberof geyser
         * @classdesc Represents a SubscribeUpdateTransactionStatus.
         * @implements ISubscribeUpdateTransactionStatus
         * @constructor
         * @param {geyser.ISubscribeUpdateTransactionStatus=} [properties] Properties to set
         */
        function SubscribeUpdateTransactionStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeUpdateTransactionStatus slot.
         * @member {number|Long} slot
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @instance
         */
        SubscribeUpdateTransactionStatus.prototype.slot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateTransactionStatus signature.
         * @member {Uint8Array} signature
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @instance
         */
        SubscribeUpdateTransactionStatus.prototype.signature = $util.newBuffer([]);

        /**
         * SubscribeUpdateTransactionStatus isVote.
         * @member {boolean} isVote
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @instance
         */
        SubscribeUpdateTransactionStatus.prototype.isVote = false;

        /**
         * SubscribeUpdateTransactionStatus index.
         * @member {number|Long} index
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @instance
         */
        SubscribeUpdateTransactionStatus.prototype.index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateTransactionStatus err.
         * @member {solana.storage.ConfirmedBlock.ITransactionError|null|undefined} err
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @instance
         */
        SubscribeUpdateTransactionStatus.prototype.err = null;

        /**
         * Creates a new SubscribeUpdateTransactionStatus instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @static
         * @param {geyser.ISubscribeUpdateTransactionStatus=} [properties] Properties to set
         * @returns {geyser.SubscribeUpdateTransactionStatus} SubscribeUpdateTransactionStatus instance
         */
        SubscribeUpdateTransactionStatus.create = function create(properties) {
            return new SubscribeUpdateTransactionStatus(properties);
        };

        /**
         * Encodes the specified SubscribeUpdateTransactionStatus message. Does not implicitly {@link geyser.SubscribeUpdateTransactionStatus.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @static
         * @param {geyser.ISubscribeUpdateTransactionStatus} message SubscribeUpdateTransactionStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateTransactionStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.slot);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            if (message.isVote != null && Object.hasOwnProperty.call(message, "isVote"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isVote);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.index);
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                $root.solana.storage.ConfirmedBlock.TransactionError.encode(message.err, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubscribeUpdateTransactionStatus message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateTransactionStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @static
         * @param {geyser.ISubscribeUpdateTransactionStatus} message SubscribeUpdateTransactionStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateTransactionStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeUpdateTransactionStatus message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeUpdateTransactionStatus} SubscribeUpdateTransactionStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateTransactionStatus.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeUpdateTransactionStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.slot = reader.uint64();
                        break;
                    }
                case 2: {
                        message.signature = reader.bytes();
                        break;
                    }
                case 3: {
                        message.isVote = reader.bool();
                        break;
                    }
                case 4: {
                        message.index = reader.uint64();
                        break;
                    }
                case 5: {
                        message.err = $root.solana.storage.ConfirmedBlock.TransactionError.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeUpdateTransactionStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeUpdateTransactionStatus} SubscribeUpdateTransactionStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateTransactionStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeUpdateTransactionStatus message.
         * @function verify
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeUpdateTransactionStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot) && !(message.slot && $util.isInteger(message.slot.low) && $util.isInteger(message.slot.high)))
                    return "slot: integer|Long expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.isVote != null && message.hasOwnProperty("isVote"))
                if (typeof message.isVote !== "boolean")
                    return "isVote: boolean expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                    return "index: integer|Long expected";
            if (message.err != null && message.hasOwnProperty("err")) {
                var error = $root.solana.storage.ConfirmedBlock.TransactionError.verify(message.err);
                if (error)
                    return "err." + error;
            }
            return null;
        };

        /**
         * Creates a SubscribeUpdateTransactionStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeUpdateTransactionStatus} SubscribeUpdateTransactionStatus
         */
        SubscribeUpdateTransactionStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeUpdateTransactionStatus)
                return object;
            var message = new $root.geyser.SubscribeUpdateTransactionStatus();
            if (object.slot != null)
                if ($util.Long)
                    (message.slot = $util.Long.fromValue(object.slot)).unsigned = true;
                else if (typeof object.slot === "string")
                    message.slot = parseInt(object.slot, 10);
                else if (typeof object.slot === "number")
                    message.slot = object.slot;
                else if (typeof object.slot === "object")
                    message.slot = new $util.LongBits(object.slot.low >>> 0, object.slot.high >>> 0).toNumber(true);
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length >= 0)
                    message.signature = object.signature;
            if (object.isVote != null)
                message.isVote = Boolean(object.isVote);
            if (object.index != null)
                if ($util.Long)
                    (message.index = $util.Long.fromValue(object.index)).unsigned = true;
                else if (typeof object.index === "string")
                    message.index = parseInt(object.index, 10);
                else if (typeof object.index === "number")
                    message.index = object.index;
                else if (typeof object.index === "object")
                    message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber(true);
            if (object.err != null) {
                if (typeof object.err !== "object")
                    throw TypeError(".geyser.SubscribeUpdateTransactionStatus.err: object expected");
                message.err = $root.solana.storage.ConfirmedBlock.TransactionError.fromObject(object.err);
            }
            return message;
        };

        /**
         * Creates a plain object from a SubscribeUpdateTransactionStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @static
         * @param {geyser.SubscribeUpdateTransactionStatus} message SubscribeUpdateTransactionStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeUpdateTransactionStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.slot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.slot = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
                object.isVote = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.index = options.longs === String ? "0" : 0;
                object.err = null;
            }
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (typeof message.slot === "number")
                    object.slot = options.longs === String ? String(message.slot) : message.slot;
                else
                    object.slot = options.longs === String ? $util.Long.prototype.toString.call(message.slot) : options.longs === Number ? new $util.LongBits(message.slot.low >>> 0, message.slot.high >>> 0).toNumber(true) : message.slot;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.isVote != null && message.hasOwnProperty("isVote"))
                object.isVote = message.isVote;
            if (message.index != null && message.hasOwnProperty("index"))
                if (typeof message.index === "number")
                    object.index = options.longs === String ? String(message.index) : message.index;
                else
                    object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber(true) : message.index;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = $root.solana.storage.ConfirmedBlock.TransactionError.toObject(message.err, options);
            return object;
        };

        /**
         * Converts this SubscribeUpdateTransactionStatus to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeUpdateTransactionStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeUpdateTransactionStatus
         * @function getTypeUrl
         * @memberof geyser.SubscribeUpdateTransactionStatus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeUpdateTransactionStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeUpdateTransactionStatus";
        };

        return SubscribeUpdateTransactionStatus;
    })();

    geyser.SubscribeUpdateBlock = (function() {

        /**
         * Properties of a SubscribeUpdateBlock.
         * @memberof geyser
         * @interface ISubscribeUpdateBlock
         * @property {number|Long|null} [slot] SubscribeUpdateBlock slot
         * @property {string|null} [blockhash] SubscribeUpdateBlock blockhash
         * @property {solana.storage.ConfirmedBlock.IRewards|null} [rewards] SubscribeUpdateBlock rewards
         * @property {solana.storage.ConfirmedBlock.IUnixTimestamp|null} [blockTime] SubscribeUpdateBlock blockTime
         * @property {solana.storage.ConfirmedBlock.IBlockHeight|null} [blockHeight] SubscribeUpdateBlock blockHeight
         * @property {number|Long|null} [parentSlot] SubscribeUpdateBlock parentSlot
         * @property {string|null} [parentBlockhash] SubscribeUpdateBlock parentBlockhash
         * @property {number|Long|null} [executedTransactionCount] SubscribeUpdateBlock executedTransactionCount
         * @property {Array.<geyser.ISubscribeUpdateTransactionInfo>|null} [transactions] SubscribeUpdateBlock transactions
         * @property {number|Long|null} [updatedAccountCount] SubscribeUpdateBlock updatedAccountCount
         * @property {Array.<geyser.ISubscribeUpdateAccountInfo>|null} [accounts] SubscribeUpdateBlock accounts
         * @property {number|Long|null} [entriesCount] SubscribeUpdateBlock entriesCount
         * @property {Array.<geyser.ISubscribeUpdateEntry>|null} [entries] SubscribeUpdateBlock entries
         */

        /**
         * Constructs a new SubscribeUpdateBlock.
         * @memberof geyser
         * @classdesc Represents a SubscribeUpdateBlock.
         * @implements ISubscribeUpdateBlock
         * @constructor
         * @param {geyser.ISubscribeUpdateBlock=} [properties] Properties to set
         */
        function SubscribeUpdateBlock(properties) {
            this.transactions = [];
            this.accounts = [];
            this.entries = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeUpdateBlock slot.
         * @member {number|Long} slot
         * @memberof geyser.SubscribeUpdateBlock
         * @instance
         */
        SubscribeUpdateBlock.prototype.slot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateBlock blockhash.
         * @member {string} blockhash
         * @memberof geyser.SubscribeUpdateBlock
         * @instance
         */
        SubscribeUpdateBlock.prototype.blockhash = "";

        /**
         * SubscribeUpdateBlock rewards.
         * @member {solana.storage.ConfirmedBlock.IRewards|null|undefined} rewards
         * @memberof geyser.SubscribeUpdateBlock
         * @instance
         */
        SubscribeUpdateBlock.prototype.rewards = null;

        /**
         * SubscribeUpdateBlock blockTime.
         * @member {solana.storage.ConfirmedBlock.IUnixTimestamp|null|undefined} blockTime
         * @memberof geyser.SubscribeUpdateBlock
         * @instance
         */
        SubscribeUpdateBlock.prototype.blockTime = null;

        /**
         * SubscribeUpdateBlock blockHeight.
         * @member {solana.storage.ConfirmedBlock.IBlockHeight|null|undefined} blockHeight
         * @memberof geyser.SubscribeUpdateBlock
         * @instance
         */
        SubscribeUpdateBlock.prototype.blockHeight = null;

        /**
         * SubscribeUpdateBlock parentSlot.
         * @member {number|Long} parentSlot
         * @memberof geyser.SubscribeUpdateBlock
         * @instance
         */
        SubscribeUpdateBlock.prototype.parentSlot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateBlock parentBlockhash.
         * @member {string} parentBlockhash
         * @memberof geyser.SubscribeUpdateBlock
         * @instance
         */
        SubscribeUpdateBlock.prototype.parentBlockhash = "";

        /**
         * SubscribeUpdateBlock executedTransactionCount.
         * @member {number|Long} executedTransactionCount
         * @memberof geyser.SubscribeUpdateBlock
         * @instance
         */
        SubscribeUpdateBlock.prototype.executedTransactionCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateBlock transactions.
         * @member {Array.<geyser.ISubscribeUpdateTransactionInfo>} transactions
         * @memberof geyser.SubscribeUpdateBlock
         * @instance
         */
        SubscribeUpdateBlock.prototype.transactions = $util.emptyArray;

        /**
         * SubscribeUpdateBlock updatedAccountCount.
         * @member {number|Long} updatedAccountCount
         * @memberof geyser.SubscribeUpdateBlock
         * @instance
         */
        SubscribeUpdateBlock.prototype.updatedAccountCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateBlock accounts.
         * @member {Array.<geyser.ISubscribeUpdateAccountInfo>} accounts
         * @memberof geyser.SubscribeUpdateBlock
         * @instance
         */
        SubscribeUpdateBlock.prototype.accounts = $util.emptyArray;

        /**
         * SubscribeUpdateBlock entriesCount.
         * @member {number|Long} entriesCount
         * @memberof geyser.SubscribeUpdateBlock
         * @instance
         */
        SubscribeUpdateBlock.prototype.entriesCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateBlock entries.
         * @member {Array.<geyser.ISubscribeUpdateEntry>} entries
         * @memberof geyser.SubscribeUpdateBlock
         * @instance
         */
        SubscribeUpdateBlock.prototype.entries = $util.emptyArray;

        /**
         * Creates a new SubscribeUpdateBlock instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeUpdateBlock
         * @static
         * @param {geyser.ISubscribeUpdateBlock=} [properties] Properties to set
         * @returns {geyser.SubscribeUpdateBlock} SubscribeUpdateBlock instance
         */
        SubscribeUpdateBlock.create = function create(properties) {
            return new SubscribeUpdateBlock(properties);
        };

        /**
         * Encodes the specified SubscribeUpdateBlock message. Does not implicitly {@link geyser.SubscribeUpdateBlock.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeUpdateBlock
         * @static
         * @param {geyser.ISubscribeUpdateBlock} message SubscribeUpdateBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateBlock.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.slot);
            if (message.blockhash != null && Object.hasOwnProperty.call(message, "blockhash"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockhash);
            if (message.rewards != null && Object.hasOwnProperty.call(message, "rewards"))
                $root.solana.storage.ConfirmedBlock.Rewards.encode(message.rewards, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.blockTime != null && Object.hasOwnProperty.call(message, "blockTime"))
                $root.solana.storage.ConfirmedBlock.UnixTimestamp.encode(message.blockTime, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
                $root.solana.storage.ConfirmedBlock.BlockHeight.encode(message.blockHeight, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.transactions != null && message.transactions.length)
                for (var i = 0; i < message.transactions.length; ++i)
                    $root.geyser.SubscribeUpdateTransactionInfo.encode(message.transactions[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.parentSlot != null && Object.hasOwnProperty.call(message, "parentSlot"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.parentSlot);
            if (message.parentBlockhash != null && Object.hasOwnProperty.call(message, "parentBlockhash"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.parentBlockhash);
            if (message.executedTransactionCount != null && Object.hasOwnProperty.call(message, "executedTransactionCount"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.executedTransactionCount);
            if (message.updatedAccountCount != null && Object.hasOwnProperty.call(message, "updatedAccountCount"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.updatedAccountCount);
            if (message.accounts != null && message.accounts.length)
                for (var i = 0; i < message.accounts.length; ++i)
                    $root.geyser.SubscribeUpdateAccountInfo.encode(message.accounts[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.entriesCount != null && Object.hasOwnProperty.call(message, "entriesCount"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.entriesCount);
            if (message.entries != null && message.entries.length)
                for (var i = 0; i < message.entries.length; ++i)
                    $root.geyser.SubscribeUpdateEntry.encode(message.entries[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubscribeUpdateBlock message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateBlock.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeUpdateBlock
         * @static
         * @param {geyser.ISubscribeUpdateBlock} message SubscribeUpdateBlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateBlock.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeUpdateBlock message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeUpdateBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeUpdateBlock} SubscribeUpdateBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateBlock.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeUpdateBlock();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.slot = reader.uint64();
                        break;
                    }
                case 2: {
                        message.blockhash = reader.string();
                        break;
                    }
                case 3: {
                        message.rewards = $root.solana.storage.ConfirmedBlock.Rewards.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.blockTime = $root.solana.storage.ConfirmedBlock.UnixTimestamp.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.blockHeight = $root.solana.storage.ConfirmedBlock.BlockHeight.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.parentSlot = reader.uint64();
                        break;
                    }
                case 8: {
                        message.parentBlockhash = reader.string();
                        break;
                    }
                case 9: {
                        message.executedTransactionCount = reader.uint64();
                        break;
                    }
                case 6: {
                        if (!(message.transactions && message.transactions.length))
                            message.transactions = [];
                        message.transactions.push($root.geyser.SubscribeUpdateTransactionInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 10: {
                        message.updatedAccountCount = reader.uint64();
                        break;
                    }
                case 11: {
                        if (!(message.accounts && message.accounts.length))
                            message.accounts = [];
                        message.accounts.push($root.geyser.SubscribeUpdateAccountInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 12: {
                        message.entriesCount = reader.uint64();
                        break;
                    }
                case 13: {
                        if (!(message.entries && message.entries.length))
                            message.entries = [];
                        message.entries.push($root.geyser.SubscribeUpdateEntry.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeUpdateBlock message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeUpdateBlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeUpdateBlock} SubscribeUpdateBlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateBlock.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeUpdateBlock message.
         * @function verify
         * @memberof geyser.SubscribeUpdateBlock
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeUpdateBlock.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot) && !(message.slot && $util.isInteger(message.slot.low) && $util.isInteger(message.slot.high)))
                    return "slot: integer|Long expected";
            if (message.blockhash != null && message.hasOwnProperty("blockhash"))
                if (!$util.isString(message.blockhash))
                    return "blockhash: string expected";
            if (message.rewards != null && message.hasOwnProperty("rewards")) {
                var error = $root.solana.storage.ConfirmedBlock.Rewards.verify(message.rewards);
                if (error)
                    return "rewards." + error;
            }
            if (message.blockTime != null && message.hasOwnProperty("blockTime")) {
                var error = $root.solana.storage.ConfirmedBlock.UnixTimestamp.verify(message.blockTime);
                if (error)
                    return "blockTime." + error;
            }
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight")) {
                var error = $root.solana.storage.ConfirmedBlock.BlockHeight.verify(message.blockHeight);
                if (error)
                    return "blockHeight." + error;
            }
            if (message.parentSlot != null && message.hasOwnProperty("parentSlot"))
                if (!$util.isInteger(message.parentSlot) && !(message.parentSlot && $util.isInteger(message.parentSlot.low) && $util.isInteger(message.parentSlot.high)))
                    return "parentSlot: integer|Long expected";
            if (message.parentBlockhash != null && message.hasOwnProperty("parentBlockhash"))
                if (!$util.isString(message.parentBlockhash))
                    return "parentBlockhash: string expected";
            if (message.executedTransactionCount != null && message.hasOwnProperty("executedTransactionCount"))
                if (!$util.isInteger(message.executedTransactionCount) && !(message.executedTransactionCount && $util.isInteger(message.executedTransactionCount.low) && $util.isInteger(message.executedTransactionCount.high)))
                    return "executedTransactionCount: integer|Long expected";
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (var i = 0; i < message.transactions.length; ++i) {
                    var error = $root.geyser.SubscribeUpdateTransactionInfo.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            if (message.updatedAccountCount != null && message.hasOwnProperty("updatedAccountCount"))
                if (!$util.isInteger(message.updatedAccountCount) && !(message.updatedAccountCount && $util.isInteger(message.updatedAccountCount.low) && $util.isInteger(message.updatedAccountCount.high)))
                    return "updatedAccountCount: integer|Long expected";
            if (message.accounts != null && message.hasOwnProperty("accounts")) {
                if (!Array.isArray(message.accounts))
                    return "accounts: array expected";
                for (var i = 0; i < message.accounts.length; ++i) {
                    var error = $root.geyser.SubscribeUpdateAccountInfo.verify(message.accounts[i]);
                    if (error)
                        return "accounts." + error;
                }
            }
            if (message.entriesCount != null && message.hasOwnProperty("entriesCount"))
                if (!$util.isInteger(message.entriesCount) && !(message.entriesCount && $util.isInteger(message.entriesCount.low) && $util.isInteger(message.entriesCount.high)))
                    return "entriesCount: integer|Long expected";
            if (message.entries != null && message.hasOwnProperty("entries")) {
                if (!Array.isArray(message.entries))
                    return "entries: array expected";
                for (var i = 0; i < message.entries.length; ++i) {
                    var error = $root.geyser.SubscribeUpdateEntry.verify(message.entries[i]);
                    if (error)
                        return "entries." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SubscribeUpdateBlock message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeUpdateBlock
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeUpdateBlock} SubscribeUpdateBlock
         */
        SubscribeUpdateBlock.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeUpdateBlock)
                return object;
            var message = new $root.geyser.SubscribeUpdateBlock();
            if (object.slot != null)
                if ($util.Long)
                    (message.slot = $util.Long.fromValue(object.slot)).unsigned = true;
                else if (typeof object.slot === "string")
                    message.slot = parseInt(object.slot, 10);
                else if (typeof object.slot === "number")
                    message.slot = object.slot;
                else if (typeof object.slot === "object")
                    message.slot = new $util.LongBits(object.slot.low >>> 0, object.slot.high >>> 0).toNumber(true);
            if (object.blockhash != null)
                message.blockhash = String(object.blockhash);
            if (object.rewards != null) {
                if (typeof object.rewards !== "object")
                    throw TypeError(".geyser.SubscribeUpdateBlock.rewards: object expected");
                message.rewards = $root.solana.storage.ConfirmedBlock.Rewards.fromObject(object.rewards);
            }
            if (object.blockTime != null) {
                if (typeof object.blockTime !== "object")
                    throw TypeError(".geyser.SubscribeUpdateBlock.blockTime: object expected");
                message.blockTime = $root.solana.storage.ConfirmedBlock.UnixTimestamp.fromObject(object.blockTime);
            }
            if (object.blockHeight != null) {
                if (typeof object.blockHeight !== "object")
                    throw TypeError(".geyser.SubscribeUpdateBlock.blockHeight: object expected");
                message.blockHeight = $root.solana.storage.ConfirmedBlock.BlockHeight.fromObject(object.blockHeight);
            }
            if (object.parentSlot != null)
                if ($util.Long)
                    (message.parentSlot = $util.Long.fromValue(object.parentSlot)).unsigned = true;
                else if (typeof object.parentSlot === "string")
                    message.parentSlot = parseInt(object.parentSlot, 10);
                else if (typeof object.parentSlot === "number")
                    message.parentSlot = object.parentSlot;
                else if (typeof object.parentSlot === "object")
                    message.parentSlot = new $util.LongBits(object.parentSlot.low >>> 0, object.parentSlot.high >>> 0).toNumber(true);
            if (object.parentBlockhash != null)
                message.parentBlockhash = String(object.parentBlockhash);
            if (object.executedTransactionCount != null)
                if ($util.Long)
                    (message.executedTransactionCount = $util.Long.fromValue(object.executedTransactionCount)).unsigned = true;
                else if (typeof object.executedTransactionCount === "string")
                    message.executedTransactionCount = parseInt(object.executedTransactionCount, 10);
                else if (typeof object.executedTransactionCount === "number")
                    message.executedTransactionCount = object.executedTransactionCount;
                else if (typeof object.executedTransactionCount === "object")
                    message.executedTransactionCount = new $util.LongBits(object.executedTransactionCount.low >>> 0, object.executedTransactionCount.high >>> 0).toNumber(true);
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".geyser.SubscribeUpdateBlock.transactions: array expected");
                message.transactions = [];
                for (var i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".geyser.SubscribeUpdateBlock.transactions: object expected");
                    message.transactions[i] = $root.geyser.SubscribeUpdateTransactionInfo.fromObject(object.transactions[i]);
                }
            }
            if (object.updatedAccountCount != null)
                if ($util.Long)
                    (message.updatedAccountCount = $util.Long.fromValue(object.updatedAccountCount)).unsigned = true;
                else if (typeof object.updatedAccountCount === "string")
                    message.updatedAccountCount = parseInt(object.updatedAccountCount, 10);
                else if (typeof object.updatedAccountCount === "number")
                    message.updatedAccountCount = object.updatedAccountCount;
                else if (typeof object.updatedAccountCount === "object")
                    message.updatedAccountCount = new $util.LongBits(object.updatedAccountCount.low >>> 0, object.updatedAccountCount.high >>> 0).toNumber(true);
            if (object.accounts) {
                if (!Array.isArray(object.accounts))
                    throw TypeError(".geyser.SubscribeUpdateBlock.accounts: array expected");
                message.accounts = [];
                for (var i = 0; i < object.accounts.length; ++i) {
                    if (typeof object.accounts[i] !== "object")
                        throw TypeError(".geyser.SubscribeUpdateBlock.accounts: object expected");
                    message.accounts[i] = $root.geyser.SubscribeUpdateAccountInfo.fromObject(object.accounts[i]);
                }
            }
            if (object.entriesCount != null)
                if ($util.Long)
                    (message.entriesCount = $util.Long.fromValue(object.entriesCount)).unsigned = true;
                else if (typeof object.entriesCount === "string")
                    message.entriesCount = parseInt(object.entriesCount, 10);
                else if (typeof object.entriesCount === "number")
                    message.entriesCount = object.entriesCount;
                else if (typeof object.entriesCount === "object")
                    message.entriesCount = new $util.LongBits(object.entriesCount.low >>> 0, object.entriesCount.high >>> 0).toNumber(true);
            if (object.entries) {
                if (!Array.isArray(object.entries))
                    throw TypeError(".geyser.SubscribeUpdateBlock.entries: array expected");
                message.entries = [];
                for (var i = 0; i < object.entries.length; ++i) {
                    if (typeof object.entries[i] !== "object")
                        throw TypeError(".geyser.SubscribeUpdateBlock.entries: object expected");
                    message.entries[i] = $root.geyser.SubscribeUpdateEntry.fromObject(object.entries[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SubscribeUpdateBlock message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeUpdateBlock
         * @static
         * @param {geyser.SubscribeUpdateBlock} message SubscribeUpdateBlock
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeUpdateBlock.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.transactions = [];
                object.accounts = [];
                object.entries = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.slot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.slot = options.longs === String ? "0" : 0;
                object.blockhash = "";
                object.rewards = null;
                object.blockTime = null;
                object.blockHeight = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.parentSlot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.parentSlot = options.longs === String ? "0" : 0;
                object.parentBlockhash = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.executedTransactionCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.executedTransactionCount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.updatedAccountCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.updatedAccountCount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.entriesCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.entriesCount = options.longs === String ? "0" : 0;
            }
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (typeof message.slot === "number")
                    object.slot = options.longs === String ? String(message.slot) : message.slot;
                else
                    object.slot = options.longs === String ? $util.Long.prototype.toString.call(message.slot) : options.longs === Number ? new $util.LongBits(message.slot.low >>> 0, message.slot.high >>> 0).toNumber(true) : message.slot;
            if (message.blockhash != null && message.hasOwnProperty("blockhash"))
                object.blockhash = message.blockhash;
            if (message.rewards != null && message.hasOwnProperty("rewards"))
                object.rewards = $root.solana.storage.ConfirmedBlock.Rewards.toObject(message.rewards, options);
            if (message.blockTime != null && message.hasOwnProperty("blockTime"))
                object.blockTime = $root.solana.storage.ConfirmedBlock.UnixTimestamp.toObject(message.blockTime, options);
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                object.blockHeight = $root.solana.storage.ConfirmedBlock.BlockHeight.toObject(message.blockHeight, options);
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (var j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.geyser.SubscribeUpdateTransactionInfo.toObject(message.transactions[j], options);
            }
            if (message.parentSlot != null && message.hasOwnProperty("parentSlot"))
                if (typeof message.parentSlot === "number")
                    object.parentSlot = options.longs === String ? String(message.parentSlot) : message.parentSlot;
                else
                    object.parentSlot = options.longs === String ? $util.Long.prototype.toString.call(message.parentSlot) : options.longs === Number ? new $util.LongBits(message.parentSlot.low >>> 0, message.parentSlot.high >>> 0).toNumber(true) : message.parentSlot;
            if (message.parentBlockhash != null && message.hasOwnProperty("parentBlockhash"))
                object.parentBlockhash = message.parentBlockhash;
            if (message.executedTransactionCount != null && message.hasOwnProperty("executedTransactionCount"))
                if (typeof message.executedTransactionCount === "number")
                    object.executedTransactionCount = options.longs === String ? String(message.executedTransactionCount) : message.executedTransactionCount;
                else
                    object.executedTransactionCount = options.longs === String ? $util.Long.prototype.toString.call(message.executedTransactionCount) : options.longs === Number ? new $util.LongBits(message.executedTransactionCount.low >>> 0, message.executedTransactionCount.high >>> 0).toNumber(true) : message.executedTransactionCount;
            if (message.updatedAccountCount != null && message.hasOwnProperty("updatedAccountCount"))
                if (typeof message.updatedAccountCount === "number")
                    object.updatedAccountCount = options.longs === String ? String(message.updatedAccountCount) : message.updatedAccountCount;
                else
                    object.updatedAccountCount = options.longs === String ? $util.Long.prototype.toString.call(message.updatedAccountCount) : options.longs === Number ? new $util.LongBits(message.updatedAccountCount.low >>> 0, message.updatedAccountCount.high >>> 0).toNumber(true) : message.updatedAccountCount;
            if (message.accounts && message.accounts.length) {
                object.accounts = [];
                for (var j = 0; j < message.accounts.length; ++j)
                    object.accounts[j] = $root.geyser.SubscribeUpdateAccountInfo.toObject(message.accounts[j], options);
            }
            if (message.entriesCount != null && message.hasOwnProperty("entriesCount"))
                if (typeof message.entriesCount === "number")
                    object.entriesCount = options.longs === String ? String(message.entriesCount) : message.entriesCount;
                else
                    object.entriesCount = options.longs === String ? $util.Long.prototype.toString.call(message.entriesCount) : options.longs === Number ? new $util.LongBits(message.entriesCount.low >>> 0, message.entriesCount.high >>> 0).toNumber(true) : message.entriesCount;
            if (message.entries && message.entries.length) {
                object.entries = [];
                for (var j = 0; j < message.entries.length; ++j)
                    object.entries[j] = $root.geyser.SubscribeUpdateEntry.toObject(message.entries[j], options);
            }
            return object;
        };

        /**
         * Converts this SubscribeUpdateBlock to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeUpdateBlock
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeUpdateBlock.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeUpdateBlock
         * @function getTypeUrl
         * @memberof geyser.SubscribeUpdateBlock
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeUpdateBlock.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeUpdateBlock";
        };

        return SubscribeUpdateBlock;
    })();

    geyser.SubscribeUpdateBlockMeta = (function() {

        /**
         * Properties of a SubscribeUpdateBlockMeta.
         * @memberof geyser
         * @interface ISubscribeUpdateBlockMeta
         * @property {number|Long|null} [slot] SubscribeUpdateBlockMeta slot
         * @property {string|null} [blockhash] SubscribeUpdateBlockMeta blockhash
         * @property {solana.storage.ConfirmedBlock.IRewards|null} [rewards] SubscribeUpdateBlockMeta rewards
         * @property {solana.storage.ConfirmedBlock.IUnixTimestamp|null} [blockTime] SubscribeUpdateBlockMeta blockTime
         * @property {solana.storage.ConfirmedBlock.IBlockHeight|null} [blockHeight] SubscribeUpdateBlockMeta blockHeight
         * @property {number|Long|null} [parentSlot] SubscribeUpdateBlockMeta parentSlot
         * @property {string|null} [parentBlockhash] SubscribeUpdateBlockMeta parentBlockhash
         * @property {number|Long|null} [executedTransactionCount] SubscribeUpdateBlockMeta executedTransactionCount
         * @property {number|Long|null} [entriesCount] SubscribeUpdateBlockMeta entriesCount
         */

        /**
         * Constructs a new SubscribeUpdateBlockMeta.
         * @memberof geyser
         * @classdesc Represents a SubscribeUpdateBlockMeta.
         * @implements ISubscribeUpdateBlockMeta
         * @constructor
         * @param {geyser.ISubscribeUpdateBlockMeta=} [properties] Properties to set
         */
        function SubscribeUpdateBlockMeta(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeUpdateBlockMeta slot.
         * @member {number|Long} slot
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @instance
         */
        SubscribeUpdateBlockMeta.prototype.slot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateBlockMeta blockhash.
         * @member {string} blockhash
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @instance
         */
        SubscribeUpdateBlockMeta.prototype.blockhash = "";

        /**
         * SubscribeUpdateBlockMeta rewards.
         * @member {solana.storage.ConfirmedBlock.IRewards|null|undefined} rewards
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @instance
         */
        SubscribeUpdateBlockMeta.prototype.rewards = null;

        /**
         * SubscribeUpdateBlockMeta blockTime.
         * @member {solana.storage.ConfirmedBlock.IUnixTimestamp|null|undefined} blockTime
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @instance
         */
        SubscribeUpdateBlockMeta.prototype.blockTime = null;

        /**
         * SubscribeUpdateBlockMeta blockHeight.
         * @member {solana.storage.ConfirmedBlock.IBlockHeight|null|undefined} blockHeight
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @instance
         */
        SubscribeUpdateBlockMeta.prototype.blockHeight = null;

        /**
         * SubscribeUpdateBlockMeta parentSlot.
         * @member {number|Long} parentSlot
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @instance
         */
        SubscribeUpdateBlockMeta.prototype.parentSlot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateBlockMeta parentBlockhash.
         * @member {string} parentBlockhash
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @instance
         */
        SubscribeUpdateBlockMeta.prototype.parentBlockhash = "";

        /**
         * SubscribeUpdateBlockMeta executedTransactionCount.
         * @member {number|Long} executedTransactionCount
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @instance
         */
        SubscribeUpdateBlockMeta.prototype.executedTransactionCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateBlockMeta entriesCount.
         * @member {number|Long} entriesCount
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @instance
         */
        SubscribeUpdateBlockMeta.prototype.entriesCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SubscribeUpdateBlockMeta instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @static
         * @param {geyser.ISubscribeUpdateBlockMeta=} [properties] Properties to set
         * @returns {geyser.SubscribeUpdateBlockMeta} SubscribeUpdateBlockMeta instance
         */
        SubscribeUpdateBlockMeta.create = function create(properties) {
            return new SubscribeUpdateBlockMeta(properties);
        };

        /**
         * Encodes the specified SubscribeUpdateBlockMeta message. Does not implicitly {@link geyser.SubscribeUpdateBlockMeta.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @static
         * @param {geyser.ISubscribeUpdateBlockMeta} message SubscribeUpdateBlockMeta message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateBlockMeta.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.slot);
            if (message.blockhash != null && Object.hasOwnProperty.call(message, "blockhash"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockhash);
            if (message.rewards != null && Object.hasOwnProperty.call(message, "rewards"))
                $root.solana.storage.ConfirmedBlock.Rewards.encode(message.rewards, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.blockTime != null && Object.hasOwnProperty.call(message, "blockTime"))
                $root.solana.storage.ConfirmedBlock.UnixTimestamp.encode(message.blockTime, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
                $root.solana.storage.ConfirmedBlock.BlockHeight.encode(message.blockHeight, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.parentSlot != null && Object.hasOwnProperty.call(message, "parentSlot"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.parentSlot);
            if (message.parentBlockhash != null && Object.hasOwnProperty.call(message, "parentBlockhash"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.parentBlockhash);
            if (message.executedTransactionCount != null && Object.hasOwnProperty.call(message, "executedTransactionCount"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.executedTransactionCount);
            if (message.entriesCount != null && Object.hasOwnProperty.call(message, "entriesCount"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.entriesCount);
            return writer;
        };

        /**
         * Encodes the specified SubscribeUpdateBlockMeta message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateBlockMeta.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @static
         * @param {geyser.ISubscribeUpdateBlockMeta} message SubscribeUpdateBlockMeta message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateBlockMeta.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeUpdateBlockMeta message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeUpdateBlockMeta} SubscribeUpdateBlockMeta
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateBlockMeta.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeUpdateBlockMeta();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.slot = reader.uint64();
                        break;
                    }
                case 2: {
                        message.blockhash = reader.string();
                        break;
                    }
                case 3: {
                        message.rewards = $root.solana.storage.ConfirmedBlock.Rewards.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.blockTime = $root.solana.storage.ConfirmedBlock.UnixTimestamp.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.blockHeight = $root.solana.storage.ConfirmedBlock.BlockHeight.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.parentSlot = reader.uint64();
                        break;
                    }
                case 7: {
                        message.parentBlockhash = reader.string();
                        break;
                    }
                case 8: {
                        message.executedTransactionCount = reader.uint64();
                        break;
                    }
                case 9: {
                        message.entriesCount = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeUpdateBlockMeta message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeUpdateBlockMeta} SubscribeUpdateBlockMeta
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateBlockMeta.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeUpdateBlockMeta message.
         * @function verify
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeUpdateBlockMeta.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot) && !(message.slot && $util.isInteger(message.slot.low) && $util.isInteger(message.slot.high)))
                    return "slot: integer|Long expected";
            if (message.blockhash != null && message.hasOwnProperty("blockhash"))
                if (!$util.isString(message.blockhash))
                    return "blockhash: string expected";
            if (message.rewards != null && message.hasOwnProperty("rewards")) {
                var error = $root.solana.storage.ConfirmedBlock.Rewards.verify(message.rewards);
                if (error)
                    return "rewards." + error;
            }
            if (message.blockTime != null && message.hasOwnProperty("blockTime")) {
                var error = $root.solana.storage.ConfirmedBlock.UnixTimestamp.verify(message.blockTime);
                if (error)
                    return "blockTime." + error;
            }
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight")) {
                var error = $root.solana.storage.ConfirmedBlock.BlockHeight.verify(message.blockHeight);
                if (error)
                    return "blockHeight." + error;
            }
            if (message.parentSlot != null && message.hasOwnProperty("parentSlot"))
                if (!$util.isInteger(message.parentSlot) && !(message.parentSlot && $util.isInteger(message.parentSlot.low) && $util.isInteger(message.parentSlot.high)))
                    return "parentSlot: integer|Long expected";
            if (message.parentBlockhash != null && message.hasOwnProperty("parentBlockhash"))
                if (!$util.isString(message.parentBlockhash))
                    return "parentBlockhash: string expected";
            if (message.executedTransactionCount != null && message.hasOwnProperty("executedTransactionCount"))
                if (!$util.isInteger(message.executedTransactionCount) && !(message.executedTransactionCount && $util.isInteger(message.executedTransactionCount.low) && $util.isInteger(message.executedTransactionCount.high)))
                    return "executedTransactionCount: integer|Long expected";
            if (message.entriesCount != null && message.hasOwnProperty("entriesCount"))
                if (!$util.isInteger(message.entriesCount) && !(message.entriesCount && $util.isInteger(message.entriesCount.low) && $util.isInteger(message.entriesCount.high)))
                    return "entriesCount: integer|Long expected";
            return null;
        };

        /**
         * Creates a SubscribeUpdateBlockMeta message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeUpdateBlockMeta} SubscribeUpdateBlockMeta
         */
        SubscribeUpdateBlockMeta.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeUpdateBlockMeta)
                return object;
            var message = new $root.geyser.SubscribeUpdateBlockMeta();
            if (object.slot != null)
                if ($util.Long)
                    (message.slot = $util.Long.fromValue(object.slot)).unsigned = true;
                else if (typeof object.slot === "string")
                    message.slot = parseInt(object.slot, 10);
                else if (typeof object.slot === "number")
                    message.slot = object.slot;
                else if (typeof object.slot === "object")
                    message.slot = new $util.LongBits(object.slot.low >>> 0, object.slot.high >>> 0).toNumber(true);
            if (object.blockhash != null)
                message.blockhash = String(object.blockhash);
            if (object.rewards != null) {
                if (typeof object.rewards !== "object")
                    throw TypeError(".geyser.SubscribeUpdateBlockMeta.rewards: object expected");
                message.rewards = $root.solana.storage.ConfirmedBlock.Rewards.fromObject(object.rewards);
            }
            if (object.blockTime != null) {
                if (typeof object.blockTime !== "object")
                    throw TypeError(".geyser.SubscribeUpdateBlockMeta.blockTime: object expected");
                message.blockTime = $root.solana.storage.ConfirmedBlock.UnixTimestamp.fromObject(object.blockTime);
            }
            if (object.blockHeight != null) {
                if (typeof object.blockHeight !== "object")
                    throw TypeError(".geyser.SubscribeUpdateBlockMeta.blockHeight: object expected");
                message.blockHeight = $root.solana.storage.ConfirmedBlock.BlockHeight.fromObject(object.blockHeight);
            }
            if (object.parentSlot != null)
                if ($util.Long)
                    (message.parentSlot = $util.Long.fromValue(object.parentSlot)).unsigned = true;
                else if (typeof object.parentSlot === "string")
                    message.parentSlot = parseInt(object.parentSlot, 10);
                else if (typeof object.parentSlot === "number")
                    message.parentSlot = object.parentSlot;
                else if (typeof object.parentSlot === "object")
                    message.parentSlot = new $util.LongBits(object.parentSlot.low >>> 0, object.parentSlot.high >>> 0).toNumber(true);
            if (object.parentBlockhash != null)
                message.parentBlockhash = String(object.parentBlockhash);
            if (object.executedTransactionCount != null)
                if ($util.Long)
                    (message.executedTransactionCount = $util.Long.fromValue(object.executedTransactionCount)).unsigned = true;
                else if (typeof object.executedTransactionCount === "string")
                    message.executedTransactionCount = parseInt(object.executedTransactionCount, 10);
                else if (typeof object.executedTransactionCount === "number")
                    message.executedTransactionCount = object.executedTransactionCount;
                else if (typeof object.executedTransactionCount === "object")
                    message.executedTransactionCount = new $util.LongBits(object.executedTransactionCount.low >>> 0, object.executedTransactionCount.high >>> 0).toNumber(true);
            if (object.entriesCount != null)
                if ($util.Long)
                    (message.entriesCount = $util.Long.fromValue(object.entriesCount)).unsigned = true;
                else if (typeof object.entriesCount === "string")
                    message.entriesCount = parseInt(object.entriesCount, 10);
                else if (typeof object.entriesCount === "number")
                    message.entriesCount = object.entriesCount;
                else if (typeof object.entriesCount === "object")
                    message.entriesCount = new $util.LongBits(object.entriesCount.low >>> 0, object.entriesCount.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeUpdateBlockMeta message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @static
         * @param {geyser.SubscribeUpdateBlockMeta} message SubscribeUpdateBlockMeta
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeUpdateBlockMeta.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.slot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.slot = options.longs === String ? "0" : 0;
                object.blockhash = "";
                object.rewards = null;
                object.blockTime = null;
                object.blockHeight = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.parentSlot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.parentSlot = options.longs === String ? "0" : 0;
                object.parentBlockhash = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.executedTransactionCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.executedTransactionCount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.entriesCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.entriesCount = options.longs === String ? "0" : 0;
            }
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (typeof message.slot === "number")
                    object.slot = options.longs === String ? String(message.slot) : message.slot;
                else
                    object.slot = options.longs === String ? $util.Long.prototype.toString.call(message.slot) : options.longs === Number ? new $util.LongBits(message.slot.low >>> 0, message.slot.high >>> 0).toNumber(true) : message.slot;
            if (message.blockhash != null && message.hasOwnProperty("blockhash"))
                object.blockhash = message.blockhash;
            if (message.rewards != null && message.hasOwnProperty("rewards"))
                object.rewards = $root.solana.storage.ConfirmedBlock.Rewards.toObject(message.rewards, options);
            if (message.blockTime != null && message.hasOwnProperty("blockTime"))
                object.blockTime = $root.solana.storage.ConfirmedBlock.UnixTimestamp.toObject(message.blockTime, options);
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                object.blockHeight = $root.solana.storage.ConfirmedBlock.BlockHeight.toObject(message.blockHeight, options);
            if (message.parentSlot != null && message.hasOwnProperty("parentSlot"))
                if (typeof message.parentSlot === "number")
                    object.parentSlot = options.longs === String ? String(message.parentSlot) : message.parentSlot;
                else
                    object.parentSlot = options.longs === String ? $util.Long.prototype.toString.call(message.parentSlot) : options.longs === Number ? new $util.LongBits(message.parentSlot.low >>> 0, message.parentSlot.high >>> 0).toNumber(true) : message.parentSlot;
            if (message.parentBlockhash != null && message.hasOwnProperty("parentBlockhash"))
                object.parentBlockhash = message.parentBlockhash;
            if (message.executedTransactionCount != null && message.hasOwnProperty("executedTransactionCount"))
                if (typeof message.executedTransactionCount === "number")
                    object.executedTransactionCount = options.longs === String ? String(message.executedTransactionCount) : message.executedTransactionCount;
                else
                    object.executedTransactionCount = options.longs === String ? $util.Long.prototype.toString.call(message.executedTransactionCount) : options.longs === Number ? new $util.LongBits(message.executedTransactionCount.low >>> 0, message.executedTransactionCount.high >>> 0).toNumber(true) : message.executedTransactionCount;
            if (message.entriesCount != null && message.hasOwnProperty("entriesCount"))
                if (typeof message.entriesCount === "number")
                    object.entriesCount = options.longs === String ? String(message.entriesCount) : message.entriesCount;
                else
                    object.entriesCount = options.longs === String ? $util.Long.prototype.toString.call(message.entriesCount) : options.longs === Number ? new $util.LongBits(message.entriesCount.low >>> 0, message.entriesCount.high >>> 0).toNumber(true) : message.entriesCount;
            return object;
        };

        /**
         * Converts this SubscribeUpdateBlockMeta to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeUpdateBlockMeta.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeUpdateBlockMeta
         * @function getTypeUrl
         * @memberof geyser.SubscribeUpdateBlockMeta
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeUpdateBlockMeta.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeUpdateBlockMeta";
        };

        return SubscribeUpdateBlockMeta;
    })();

    geyser.SubscribeUpdateEntry = (function() {

        /**
         * Properties of a SubscribeUpdateEntry.
         * @memberof geyser
         * @interface ISubscribeUpdateEntry
         * @property {number|Long|null} [slot] SubscribeUpdateEntry slot
         * @property {number|Long|null} [index] SubscribeUpdateEntry index
         * @property {number|Long|null} [numHashes] SubscribeUpdateEntry numHashes
         * @property {Uint8Array|null} [hash] SubscribeUpdateEntry hash
         * @property {number|Long|null} [executedTransactionCount] SubscribeUpdateEntry executedTransactionCount
         * @property {number|Long|null} [startingTransactionIndex] SubscribeUpdateEntry startingTransactionIndex
         */

        /**
         * Constructs a new SubscribeUpdateEntry.
         * @memberof geyser
         * @classdesc Represents a SubscribeUpdateEntry.
         * @implements ISubscribeUpdateEntry
         * @constructor
         * @param {geyser.ISubscribeUpdateEntry=} [properties] Properties to set
         */
        function SubscribeUpdateEntry(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeUpdateEntry slot.
         * @member {number|Long} slot
         * @memberof geyser.SubscribeUpdateEntry
         * @instance
         */
        SubscribeUpdateEntry.prototype.slot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateEntry index.
         * @member {number|Long} index
         * @memberof geyser.SubscribeUpdateEntry
         * @instance
         */
        SubscribeUpdateEntry.prototype.index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateEntry numHashes.
         * @member {number|Long} numHashes
         * @memberof geyser.SubscribeUpdateEntry
         * @instance
         */
        SubscribeUpdateEntry.prototype.numHashes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateEntry hash.
         * @member {Uint8Array} hash
         * @memberof geyser.SubscribeUpdateEntry
         * @instance
         */
        SubscribeUpdateEntry.prototype.hash = $util.newBuffer([]);

        /**
         * SubscribeUpdateEntry executedTransactionCount.
         * @member {number|Long} executedTransactionCount
         * @memberof geyser.SubscribeUpdateEntry
         * @instance
         */
        SubscribeUpdateEntry.prototype.executedTransactionCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeUpdateEntry startingTransactionIndex.
         * @member {number|Long} startingTransactionIndex
         * @memberof geyser.SubscribeUpdateEntry
         * @instance
         */
        SubscribeUpdateEntry.prototype.startingTransactionIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SubscribeUpdateEntry instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeUpdateEntry
         * @static
         * @param {geyser.ISubscribeUpdateEntry=} [properties] Properties to set
         * @returns {geyser.SubscribeUpdateEntry} SubscribeUpdateEntry instance
         */
        SubscribeUpdateEntry.create = function create(properties) {
            return new SubscribeUpdateEntry(properties);
        };

        /**
         * Encodes the specified SubscribeUpdateEntry message. Does not implicitly {@link geyser.SubscribeUpdateEntry.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeUpdateEntry
         * @static
         * @param {geyser.ISubscribeUpdateEntry} message SubscribeUpdateEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.slot);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.index);
            if (message.numHashes != null && Object.hasOwnProperty.call(message, "numHashes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.numHashes);
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.hash);
            if (message.executedTransactionCount != null && Object.hasOwnProperty.call(message, "executedTransactionCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.executedTransactionCount);
            if (message.startingTransactionIndex != null && Object.hasOwnProperty.call(message, "startingTransactionIndex"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.startingTransactionIndex);
            return writer;
        };

        /**
         * Encodes the specified SubscribeUpdateEntry message, length delimited. Does not implicitly {@link geyser.SubscribeUpdateEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeUpdateEntry
         * @static
         * @param {geyser.ISubscribeUpdateEntry} message SubscribeUpdateEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdateEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeUpdateEntry message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeUpdateEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeUpdateEntry} SubscribeUpdateEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateEntry.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeUpdateEntry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.slot = reader.uint64();
                        break;
                    }
                case 2: {
                        message.index = reader.uint64();
                        break;
                    }
                case 3: {
                        message.numHashes = reader.uint64();
                        break;
                    }
                case 4: {
                        message.hash = reader.bytes();
                        break;
                    }
                case 5: {
                        message.executedTransactionCount = reader.uint64();
                        break;
                    }
                case 6: {
                        message.startingTransactionIndex = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeUpdateEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeUpdateEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeUpdateEntry} SubscribeUpdateEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdateEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeUpdateEntry message.
         * @function verify
         * @memberof geyser.SubscribeUpdateEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeUpdateEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot) && !(message.slot && $util.isInteger(message.slot.low) && $util.isInteger(message.slot.high)))
                    return "slot: integer|Long expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                    return "index: integer|Long expected";
            if (message.numHashes != null && message.hasOwnProperty("numHashes"))
                if (!$util.isInteger(message.numHashes) && !(message.numHashes && $util.isInteger(message.numHashes.low) && $util.isInteger(message.numHashes.high)))
                    return "numHashes: integer|Long expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            if (message.executedTransactionCount != null && message.hasOwnProperty("executedTransactionCount"))
                if (!$util.isInteger(message.executedTransactionCount) && !(message.executedTransactionCount && $util.isInteger(message.executedTransactionCount.low) && $util.isInteger(message.executedTransactionCount.high)))
                    return "executedTransactionCount: integer|Long expected";
            if (message.startingTransactionIndex != null && message.hasOwnProperty("startingTransactionIndex"))
                if (!$util.isInteger(message.startingTransactionIndex) && !(message.startingTransactionIndex && $util.isInteger(message.startingTransactionIndex.low) && $util.isInteger(message.startingTransactionIndex.high)))
                    return "startingTransactionIndex: integer|Long expected";
            return null;
        };

        /**
         * Creates a SubscribeUpdateEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeUpdateEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeUpdateEntry} SubscribeUpdateEntry
         */
        SubscribeUpdateEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeUpdateEntry)
                return object;
            var message = new $root.geyser.SubscribeUpdateEntry();
            if (object.slot != null)
                if ($util.Long)
                    (message.slot = $util.Long.fromValue(object.slot)).unsigned = true;
                else if (typeof object.slot === "string")
                    message.slot = parseInt(object.slot, 10);
                else if (typeof object.slot === "number")
                    message.slot = object.slot;
                else if (typeof object.slot === "object")
                    message.slot = new $util.LongBits(object.slot.low >>> 0, object.slot.high >>> 0).toNumber(true);
            if (object.index != null)
                if ($util.Long)
                    (message.index = $util.Long.fromValue(object.index)).unsigned = true;
                else if (typeof object.index === "string")
                    message.index = parseInt(object.index, 10);
                else if (typeof object.index === "number")
                    message.index = object.index;
                else if (typeof object.index === "object")
                    message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber(true);
            if (object.numHashes != null)
                if ($util.Long)
                    (message.numHashes = $util.Long.fromValue(object.numHashes)).unsigned = true;
                else if (typeof object.numHashes === "string")
                    message.numHashes = parseInt(object.numHashes, 10);
                else if (typeof object.numHashes === "number")
                    message.numHashes = object.numHashes;
                else if (typeof object.numHashes === "object")
                    message.numHashes = new $util.LongBits(object.numHashes.low >>> 0, object.numHashes.high >>> 0).toNumber(true);
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length >= 0)
                    message.hash = object.hash;
            if (object.executedTransactionCount != null)
                if ($util.Long)
                    (message.executedTransactionCount = $util.Long.fromValue(object.executedTransactionCount)).unsigned = true;
                else if (typeof object.executedTransactionCount === "string")
                    message.executedTransactionCount = parseInt(object.executedTransactionCount, 10);
                else if (typeof object.executedTransactionCount === "number")
                    message.executedTransactionCount = object.executedTransactionCount;
                else if (typeof object.executedTransactionCount === "object")
                    message.executedTransactionCount = new $util.LongBits(object.executedTransactionCount.low >>> 0, object.executedTransactionCount.high >>> 0).toNumber(true);
            if (object.startingTransactionIndex != null)
                if ($util.Long)
                    (message.startingTransactionIndex = $util.Long.fromValue(object.startingTransactionIndex)).unsigned = true;
                else if (typeof object.startingTransactionIndex === "string")
                    message.startingTransactionIndex = parseInt(object.startingTransactionIndex, 10);
                else if (typeof object.startingTransactionIndex === "number")
                    message.startingTransactionIndex = object.startingTransactionIndex;
                else if (typeof object.startingTransactionIndex === "object")
                    message.startingTransactionIndex = new $util.LongBits(object.startingTransactionIndex.low >>> 0, object.startingTransactionIndex.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeUpdateEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeUpdateEntry
         * @static
         * @param {geyser.SubscribeUpdateEntry} message SubscribeUpdateEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeUpdateEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.slot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.slot = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.index = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.numHashes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numHashes = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.executedTransactionCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.executedTransactionCount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.startingTransactionIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startingTransactionIndex = options.longs === String ? "0" : 0;
            }
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (typeof message.slot === "number")
                    object.slot = options.longs === String ? String(message.slot) : message.slot;
                else
                    object.slot = options.longs === String ? $util.Long.prototype.toString.call(message.slot) : options.longs === Number ? new $util.LongBits(message.slot.low >>> 0, message.slot.high >>> 0).toNumber(true) : message.slot;
            if (message.index != null && message.hasOwnProperty("index"))
                if (typeof message.index === "number")
                    object.index = options.longs === String ? String(message.index) : message.index;
                else
                    object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber(true) : message.index;
            if (message.numHashes != null && message.hasOwnProperty("numHashes"))
                if (typeof message.numHashes === "number")
                    object.numHashes = options.longs === String ? String(message.numHashes) : message.numHashes;
                else
                    object.numHashes = options.longs === String ? $util.Long.prototype.toString.call(message.numHashes) : options.longs === Number ? new $util.LongBits(message.numHashes.low >>> 0, message.numHashes.high >>> 0).toNumber(true) : message.numHashes;
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            if (message.executedTransactionCount != null && message.hasOwnProperty("executedTransactionCount"))
                if (typeof message.executedTransactionCount === "number")
                    object.executedTransactionCount = options.longs === String ? String(message.executedTransactionCount) : message.executedTransactionCount;
                else
                    object.executedTransactionCount = options.longs === String ? $util.Long.prototype.toString.call(message.executedTransactionCount) : options.longs === Number ? new $util.LongBits(message.executedTransactionCount.low >>> 0, message.executedTransactionCount.high >>> 0).toNumber(true) : message.executedTransactionCount;
            if (message.startingTransactionIndex != null && message.hasOwnProperty("startingTransactionIndex"))
                if (typeof message.startingTransactionIndex === "number")
                    object.startingTransactionIndex = options.longs === String ? String(message.startingTransactionIndex) : message.startingTransactionIndex;
                else
                    object.startingTransactionIndex = options.longs === String ? $util.Long.prototype.toString.call(message.startingTransactionIndex) : options.longs === Number ? new $util.LongBits(message.startingTransactionIndex.low >>> 0, message.startingTransactionIndex.high >>> 0).toNumber(true) : message.startingTransactionIndex;
            return object;
        };

        /**
         * Converts this SubscribeUpdateEntry to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeUpdateEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeUpdateEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeUpdateEntry
         * @function getTypeUrl
         * @memberof geyser.SubscribeUpdateEntry
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeUpdateEntry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeUpdateEntry";
        };

        return SubscribeUpdateEntry;
    })();

    geyser.SubscribeUpdatePing = (function() {

        /**
         * Properties of a SubscribeUpdatePing.
         * @memberof geyser
         * @interface ISubscribeUpdatePing
         */

        /**
         * Constructs a new SubscribeUpdatePing.
         * @memberof geyser
         * @classdesc Represents a SubscribeUpdatePing.
         * @implements ISubscribeUpdatePing
         * @constructor
         * @param {geyser.ISubscribeUpdatePing=} [properties] Properties to set
         */
        function SubscribeUpdatePing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SubscribeUpdatePing instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeUpdatePing
         * @static
         * @param {geyser.ISubscribeUpdatePing=} [properties] Properties to set
         * @returns {geyser.SubscribeUpdatePing} SubscribeUpdatePing instance
         */
        SubscribeUpdatePing.create = function create(properties) {
            return new SubscribeUpdatePing(properties);
        };

        /**
         * Encodes the specified SubscribeUpdatePing message. Does not implicitly {@link geyser.SubscribeUpdatePing.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeUpdatePing
         * @static
         * @param {geyser.ISubscribeUpdatePing} message SubscribeUpdatePing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdatePing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SubscribeUpdatePing message, length delimited. Does not implicitly {@link geyser.SubscribeUpdatePing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeUpdatePing
         * @static
         * @param {geyser.ISubscribeUpdatePing} message SubscribeUpdatePing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdatePing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeUpdatePing message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeUpdatePing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeUpdatePing} SubscribeUpdatePing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdatePing.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeUpdatePing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeUpdatePing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeUpdatePing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeUpdatePing} SubscribeUpdatePing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdatePing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeUpdatePing message.
         * @function verify
         * @memberof geyser.SubscribeUpdatePing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeUpdatePing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SubscribeUpdatePing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeUpdatePing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeUpdatePing} SubscribeUpdatePing
         */
        SubscribeUpdatePing.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeUpdatePing)
                return object;
            return new $root.geyser.SubscribeUpdatePing();
        };

        /**
         * Creates a plain object from a SubscribeUpdatePing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeUpdatePing
         * @static
         * @param {geyser.SubscribeUpdatePing} message SubscribeUpdatePing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeUpdatePing.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SubscribeUpdatePing to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeUpdatePing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeUpdatePing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeUpdatePing
         * @function getTypeUrl
         * @memberof geyser.SubscribeUpdatePing
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeUpdatePing.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeUpdatePing";
        };

        return SubscribeUpdatePing;
    })();

    geyser.SubscribeUpdatePong = (function() {

        /**
         * Properties of a SubscribeUpdatePong.
         * @memberof geyser
         * @interface ISubscribeUpdatePong
         * @property {number|null} [id] SubscribeUpdatePong id
         */

        /**
         * Constructs a new SubscribeUpdatePong.
         * @memberof geyser
         * @classdesc Represents a SubscribeUpdatePong.
         * @implements ISubscribeUpdatePong
         * @constructor
         * @param {geyser.ISubscribeUpdatePong=} [properties] Properties to set
         */
        function SubscribeUpdatePong(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeUpdatePong id.
         * @member {number} id
         * @memberof geyser.SubscribeUpdatePong
         * @instance
         */
        SubscribeUpdatePong.prototype.id = 0;

        /**
         * Creates a new SubscribeUpdatePong instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeUpdatePong
         * @static
         * @param {geyser.ISubscribeUpdatePong=} [properties] Properties to set
         * @returns {geyser.SubscribeUpdatePong} SubscribeUpdatePong instance
         */
        SubscribeUpdatePong.create = function create(properties) {
            return new SubscribeUpdatePong(properties);
        };

        /**
         * Encodes the specified SubscribeUpdatePong message. Does not implicitly {@link geyser.SubscribeUpdatePong.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeUpdatePong
         * @static
         * @param {geyser.ISubscribeUpdatePong} message SubscribeUpdatePong message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdatePong.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            return writer;
        };

        /**
         * Encodes the specified SubscribeUpdatePong message, length delimited. Does not implicitly {@link geyser.SubscribeUpdatePong.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeUpdatePong
         * @static
         * @param {geyser.ISubscribeUpdatePong} message SubscribeUpdatePong message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeUpdatePong.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeUpdatePong message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeUpdatePong
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeUpdatePong} SubscribeUpdatePong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdatePong.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeUpdatePong();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeUpdatePong message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeUpdatePong
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeUpdatePong} SubscribeUpdatePong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeUpdatePong.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeUpdatePong message.
         * @function verify
         * @memberof geyser.SubscribeUpdatePong
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeUpdatePong.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        /**
         * Creates a SubscribeUpdatePong message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeUpdatePong
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeUpdatePong} SubscribeUpdatePong
         */
        SubscribeUpdatePong.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeUpdatePong)
                return object;
            var message = new $root.geyser.SubscribeUpdatePong();
            if (object.id != null)
                message.id = object.id | 0;
            return message;
        };

        /**
         * Creates a plain object from a SubscribeUpdatePong message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeUpdatePong
         * @static
         * @param {geyser.SubscribeUpdatePong} message SubscribeUpdatePong
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeUpdatePong.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this SubscribeUpdatePong to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeUpdatePong
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeUpdatePong.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeUpdatePong
         * @function getTypeUrl
         * @memberof geyser.SubscribeUpdatePong
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeUpdatePong.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeUpdatePong";
        };

        return SubscribeUpdatePong;
    })();

    geyser.SubscribeReplayInfoRequest = (function() {

        /**
         * Properties of a SubscribeReplayInfoRequest.
         * @memberof geyser
         * @interface ISubscribeReplayInfoRequest
         */

        /**
         * Constructs a new SubscribeReplayInfoRequest.
         * @memberof geyser
         * @classdesc Represents a SubscribeReplayInfoRequest.
         * @implements ISubscribeReplayInfoRequest
         * @constructor
         * @param {geyser.ISubscribeReplayInfoRequest=} [properties] Properties to set
         */
        function SubscribeReplayInfoRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SubscribeReplayInfoRequest instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeReplayInfoRequest
         * @static
         * @param {geyser.ISubscribeReplayInfoRequest=} [properties] Properties to set
         * @returns {geyser.SubscribeReplayInfoRequest} SubscribeReplayInfoRequest instance
         */
        SubscribeReplayInfoRequest.create = function create(properties) {
            return new SubscribeReplayInfoRequest(properties);
        };

        /**
         * Encodes the specified SubscribeReplayInfoRequest message. Does not implicitly {@link geyser.SubscribeReplayInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeReplayInfoRequest
         * @static
         * @param {geyser.ISubscribeReplayInfoRequest} message SubscribeReplayInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeReplayInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SubscribeReplayInfoRequest message, length delimited. Does not implicitly {@link geyser.SubscribeReplayInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeReplayInfoRequest
         * @static
         * @param {geyser.ISubscribeReplayInfoRequest} message SubscribeReplayInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeReplayInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeReplayInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeReplayInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeReplayInfoRequest} SubscribeReplayInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeReplayInfoRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeReplayInfoRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeReplayInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeReplayInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeReplayInfoRequest} SubscribeReplayInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeReplayInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeReplayInfoRequest message.
         * @function verify
         * @memberof geyser.SubscribeReplayInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeReplayInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SubscribeReplayInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeReplayInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeReplayInfoRequest} SubscribeReplayInfoRequest
         */
        SubscribeReplayInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeReplayInfoRequest)
                return object;
            return new $root.geyser.SubscribeReplayInfoRequest();
        };

        /**
         * Creates a plain object from a SubscribeReplayInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeReplayInfoRequest
         * @static
         * @param {geyser.SubscribeReplayInfoRequest} message SubscribeReplayInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeReplayInfoRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SubscribeReplayInfoRequest to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeReplayInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeReplayInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeReplayInfoRequest
         * @function getTypeUrl
         * @memberof geyser.SubscribeReplayInfoRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeReplayInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeReplayInfoRequest";
        };

        return SubscribeReplayInfoRequest;
    })();

    geyser.SubscribeReplayInfoResponse = (function() {

        /**
         * Properties of a SubscribeReplayInfoResponse.
         * @memberof geyser
         * @interface ISubscribeReplayInfoResponse
         * @property {number|Long|null} [firstAvailable] SubscribeReplayInfoResponse firstAvailable
         */

        /**
         * Constructs a new SubscribeReplayInfoResponse.
         * @memberof geyser
         * @classdesc Represents a SubscribeReplayInfoResponse.
         * @implements ISubscribeReplayInfoResponse
         * @constructor
         * @param {geyser.ISubscribeReplayInfoResponse=} [properties] Properties to set
         */
        function SubscribeReplayInfoResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeReplayInfoResponse firstAvailable.
         * @member {number|Long|null|undefined} firstAvailable
         * @memberof geyser.SubscribeReplayInfoResponse
         * @instance
         */
        SubscribeReplayInfoResponse.prototype.firstAvailable = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SubscribeReplayInfoResponse _firstAvailable.
         * @member {"firstAvailable"|undefined} _firstAvailable
         * @memberof geyser.SubscribeReplayInfoResponse
         * @instance
         */
        Object.defineProperty(SubscribeReplayInfoResponse.prototype, "_firstAvailable", {
            get: $util.oneOfGetter($oneOfFields = ["firstAvailable"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SubscribeReplayInfoResponse instance using the specified properties.
         * @function create
         * @memberof geyser.SubscribeReplayInfoResponse
         * @static
         * @param {geyser.ISubscribeReplayInfoResponse=} [properties] Properties to set
         * @returns {geyser.SubscribeReplayInfoResponse} SubscribeReplayInfoResponse instance
         */
        SubscribeReplayInfoResponse.create = function create(properties) {
            return new SubscribeReplayInfoResponse(properties);
        };

        /**
         * Encodes the specified SubscribeReplayInfoResponse message. Does not implicitly {@link geyser.SubscribeReplayInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof geyser.SubscribeReplayInfoResponse
         * @static
         * @param {geyser.ISubscribeReplayInfoResponse} message SubscribeReplayInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeReplayInfoResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.firstAvailable != null && Object.hasOwnProperty.call(message, "firstAvailable"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.firstAvailable);
            return writer;
        };

        /**
         * Encodes the specified SubscribeReplayInfoResponse message, length delimited. Does not implicitly {@link geyser.SubscribeReplayInfoResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.SubscribeReplayInfoResponse
         * @static
         * @param {geyser.ISubscribeReplayInfoResponse} message SubscribeReplayInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeReplayInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeReplayInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.SubscribeReplayInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.SubscribeReplayInfoResponse} SubscribeReplayInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeReplayInfoResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.SubscribeReplayInfoResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.firstAvailable = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeReplayInfoResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.SubscribeReplayInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.SubscribeReplayInfoResponse} SubscribeReplayInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeReplayInfoResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeReplayInfoResponse message.
         * @function verify
         * @memberof geyser.SubscribeReplayInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeReplayInfoResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.firstAvailable != null && message.hasOwnProperty("firstAvailable")) {
                properties._firstAvailable = 1;
                if (!$util.isInteger(message.firstAvailable) && !(message.firstAvailable && $util.isInteger(message.firstAvailable.low) && $util.isInteger(message.firstAvailable.high)))
                    return "firstAvailable: integer|Long expected";
            }
            return null;
        };

        /**
         * Creates a SubscribeReplayInfoResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.SubscribeReplayInfoResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.SubscribeReplayInfoResponse} SubscribeReplayInfoResponse
         */
        SubscribeReplayInfoResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.SubscribeReplayInfoResponse)
                return object;
            var message = new $root.geyser.SubscribeReplayInfoResponse();
            if (object.firstAvailable != null)
                if ($util.Long)
                    (message.firstAvailable = $util.Long.fromValue(object.firstAvailable)).unsigned = true;
                else if (typeof object.firstAvailable === "string")
                    message.firstAvailable = parseInt(object.firstAvailable, 10);
                else if (typeof object.firstAvailable === "number")
                    message.firstAvailable = object.firstAvailable;
                else if (typeof object.firstAvailable === "object")
                    message.firstAvailable = new $util.LongBits(object.firstAvailable.low >>> 0, object.firstAvailable.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeReplayInfoResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.SubscribeReplayInfoResponse
         * @static
         * @param {geyser.SubscribeReplayInfoResponse} message SubscribeReplayInfoResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeReplayInfoResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.firstAvailable != null && message.hasOwnProperty("firstAvailable")) {
                if (typeof message.firstAvailable === "number")
                    object.firstAvailable = options.longs === String ? String(message.firstAvailable) : message.firstAvailable;
                else
                    object.firstAvailable = options.longs === String ? $util.Long.prototype.toString.call(message.firstAvailable) : options.longs === Number ? new $util.LongBits(message.firstAvailable.low >>> 0, message.firstAvailable.high >>> 0).toNumber(true) : message.firstAvailable;
                if (options.oneofs)
                    object._firstAvailable = "firstAvailable";
            }
            return object;
        };

        /**
         * Converts this SubscribeReplayInfoResponse to JSON.
         * @function toJSON
         * @memberof geyser.SubscribeReplayInfoResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeReplayInfoResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeReplayInfoResponse
         * @function getTypeUrl
         * @memberof geyser.SubscribeReplayInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeReplayInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.SubscribeReplayInfoResponse";
        };

        return SubscribeReplayInfoResponse;
    })();

    geyser.PingRequest = (function() {

        /**
         * Properties of a PingRequest.
         * @memberof geyser
         * @interface IPingRequest
         * @property {number|null} [count] PingRequest count
         */

        /**
         * Constructs a new PingRequest.
         * @memberof geyser
         * @classdesc Represents a PingRequest.
         * @implements IPingRequest
         * @constructor
         * @param {geyser.IPingRequest=} [properties] Properties to set
         */
        function PingRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PingRequest count.
         * @member {number} count
         * @memberof geyser.PingRequest
         * @instance
         */
        PingRequest.prototype.count = 0;

        /**
         * Creates a new PingRequest instance using the specified properties.
         * @function create
         * @memberof geyser.PingRequest
         * @static
         * @param {geyser.IPingRequest=} [properties] Properties to set
         * @returns {geyser.PingRequest} PingRequest instance
         */
        PingRequest.create = function create(properties) {
            return new PingRequest(properties);
        };

        /**
         * Encodes the specified PingRequest message. Does not implicitly {@link geyser.PingRequest.verify|verify} messages.
         * @function encode
         * @memberof geyser.PingRequest
         * @static
         * @param {geyser.IPingRequest} message PingRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified PingRequest message, length delimited. Does not implicitly {@link geyser.PingRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.PingRequest
         * @static
         * @param {geyser.IPingRequest} message PingRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PingRequest message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.PingRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.PingRequest} PingRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.PingRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.count = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PingRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.PingRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.PingRequest} PingRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PingRequest message.
         * @function verify
         * @memberof geyser.PingRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PingRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a PingRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.PingRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.PingRequest} PingRequest
         */
        PingRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.PingRequest)
                return object;
            var message = new $root.geyser.PingRequest();
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };

        /**
         * Creates a plain object from a PingRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.PingRequest
         * @static
         * @param {geyser.PingRequest} message PingRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PingRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.count = 0;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this PingRequest to JSON.
         * @function toJSON
         * @memberof geyser.PingRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PingRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PingRequest
         * @function getTypeUrl
         * @memberof geyser.PingRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PingRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.PingRequest";
        };

        return PingRequest;
    })();

    geyser.PongResponse = (function() {

        /**
         * Properties of a PongResponse.
         * @memberof geyser
         * @interface IPongResponse
         * @property {number|null} [count] PongResponse count
         */

        /**
         * Constructs a new PongResponse.
         * @memberof geyser
         * @classdesc Represents a PongResponse.
         * @implements IPongResponse
         * @constructor
         * @param {geyser.IPongResponse=} [properties] Properties to set
         */
        function PongResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PongResponse count.
         * @member {number} count
         * @memberof geyser.PongResponse
         * @instance
         */
        PongResponse.prototype.count = 0;

        /**
         * Creates a new PongResponse instance using the specified properties.
         * @function create
         * @memberof geyser.PongResponse
         * @static
         * @param {geyser.IPongResponse=} [properties] Properties to set
         * @returns {geyser.PongResponse} PongResponse instance
         */
        PongResponse.create = function create(properties) {
            return new PongResponse(properties);
        };

        /**
         * Encodes the specified PongResponse message. Does not implicitly {@link geyser.PongResponse.verify|verify} messages.
         * @function encode
         * @memberof geyser.PongResponse
         * @static
         * @param {geyser.IPongResponse} message PongResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PongResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified PongResponse message, length delimited. Does not implicitly {@link geyser.PongResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.PongResponse
         * @static
         * @param {geyser.IPongResponse} message PongResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PongResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PongResponse message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.PongResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.PongResponse} PongResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PongResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.PongResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.count = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PongResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.PongResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.PongResponse} PongResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PongResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PongResponse message.
         * @function verify
         * @memberof geyser.PongResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PongResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a PongResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.PongResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.PongResponse} PongResponse
         */
        PongResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.PongResponse)
                return object;
            var message = new $root.geyser.PongResponse();
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };

        /**
         * Creates a plain object from a PongResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.PongResponse
         * @static
         * @param {geyser.PongResponse} message PongResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PongResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.count = 0;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this PongResponse to JSON.
         * @function toJSON
         * @memberof geyser.PongResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PongResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PongResponse
         * @function getTypeUrl
         * @memberof geyser.PongResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PongResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.PongResponse";
        };

        return PongResponse;
    })();

    geyser.GetLatestBlockhashRequest = (function() {

        /**
         * Properties of a GetLatestBlockhashRequest.
         * @memberof geyser
         * @interface IGetLatestBlockhashRequest
         * @property {geyser.CommitmentLevel|null} [commitment] GetLatestBlockhashRequest commitment
         */

        /**
         * Constructs a new GetLatestBlockhashRequest.
         * @memberof geyser
         * @classdesc Represents a GetLatestBlockhashRequest.
         * @implements IGetLatestBlockhashRequest
         * @constructor
         * @param {geyser.IGetLatestBlockhashRequest=} [properties] Properties to set
         */
        function GetLatestBlockhashRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetLatestBlockhashRequest commitment.
         * @member {geyser.CommitmentLevel|null|undefined} commitment
         * @memberof geyser.GetLatestBlockhashRequest
         * @instance
         */
        GetLatestBlockhashRequest.prototype.commitment = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * GetLatestBlockhashRequest _commitment.
         * @member {"commitment"|undefined} _commitment
         * @memberof geyser.GetLatestBlockhashRequest
         * @instance
         */
        Object.defineProperty(GetLatestBlockhashRequest.prototype, "_commitment", {
            get: $util.oneOfGetter($oneOfFields = ["commitment"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new GetLatestBlockhashRequest instance using the specified properties.
         * @function create
         * @memberof geyser.GetLatestBlockhashRequest
         * @static
         * @param {geyser.IGetLatestBlockhashRequest=} [properties] Properties to set
         * @returns {geyser.GetLatestBlockhashRequest} GetLatestBlockhashRequest instance
         */
        GetLatestBlockhashRequest.create = function create(properties) {
            return new GetLatestBlockhashRequest(properties);
        };

        /**
         * Encodes the specified GetLatestBlockhashRequest message. Does not implicitly {@link geyser.GetLatestBlockhashRequest.verify|verify} messages.
         * @function encode
         * @memberof geyser.GetLatestBlockhashRequest
         * @static
         * @param {geyser.IGetLatestBlockhashRequest} message GetLatestBlockhashRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLatestBlockhashRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.commitment != null && Object.hasOwnProperty.call(message, "commitment"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.commitment);
            return writer;
        };

        /**
         * Encodes the specified GetLatestBlockhashRequest message, length delimited. Does not implicitly {@link geyser.GetLatestBlockhashRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.GetLatestBlockhashRequest
         * @static
         * @param {geyser.IGetLatestBlockhashRequest} message GetLatestBlockhashRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLatestBlockhashRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetLatestBlockhashRequest message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.GetLatestBlockhashRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.GetLatestBlockhashRequest} GetLatestBlockhashRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLatestBlockhashRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.GetLatestBlockhashRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.commitment = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetLatestBlockhashRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.GetLatestBlockhashRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.GetLatestBlockhashRequest} GetLatestBlockhashRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLatestBlockhashRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetLatestBlockhashRequest message.
         * @function verify
         * @memberof geyser.GetLatestBlockhashRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetLatestBlockhashRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.commitment != null && message.hasOwnProperty("commitment")) {
                properties._commitment = 1;
                switch (message.commitment) {
                default:
                    return "commitment: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            }
            return null;
        };

        /**
         * Creates a GetLatestBlockhashRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.GetLatestBlockhashRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.GetLatestBlockhashRequest} GetLatestBlockhashRequest
         */
        GetLatestBlockhashRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.GetLatestBlockhashRequest)
                return object;
            var message = new $root.geyser.GetLatestBlockhashRequest();
            switch (object.commitment) {
            default:
                if (typeof object.commitment === "number") {
                    message.commitment = object.commitment;
                    break;
                }
                break;
            case "PROCESSED":
            case 0:
                message.commitment = 0;
                break;
            case "CONFIRMED":
            case 1:
                message.commitment = 1;
                break;
            case "FINALIZED":
            case 2:
                message.commitment = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetLatestBlockhashRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.GetLatestBlockhashRequest
         * @static
         * @param {geyser.GetLatestBlockhashRequest} message GetLatestBlockhashRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetLatestBlockhashRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.commitment != null && message.hasOwnProperty("commitment")) {
                object.commitment = options.enums === String ? $root.geyser.CommitmentLevel[message.commitment] === undefined ? message.commitment : $root.geyser.CommitmentLevel[message.commitment] : message.commitment;
                if (options.oneofs)
                    object._commitment = "commitment";
            }
            return object;
        };

        /**
         * Converts this GetLatestBlockhashRequest to JSON.
         * @function toJSON
         * @memberof geyser.GetLatestBlockhashRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetLatestBlockhashRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetLatestBlockhashRequest
         * @function getTypeUrl
         * @memberof geyser.GetLatestBlockhashRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetLatestBlockhashRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.GetLatestBlockhashRequest";
        };

        return GetLatestBlockhashRequest;
    })();

    geyser.GetLatestBlockhashResponse = (function() {

        /**
         * Properties of a GetLatestBlockhashResponse.
         * @memberof geyser
         * @interface IGetLatestBlockhashResponse
         * @property {number|Long|null} [slot] GetLatestBlockhashResponse slot
         * @property {string|null} [blockhash] GetLatestBlockhashResponse blockhash
         * @property {number|Long|null} [lastValidBlockHeight] GetLatestBlockhashResponse lastValidBlockHeight
         */

        /**
         * Constructs a new GetLatestBlockhashResponse.
         * @memberof geyser
         * @classdesc Represents a GetLatestBlockhashResponse.
         * @implements IGetLatestBlockhashResponse
         * @constructor
         * @param {geyser.IGetLatestBlockhashResponse=} [properties] Properties to set
         */
        function GetLatestBlockhashResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetLatestBlockhashResponse slot.
         * @member {number|Long} slot
         * @memberof geyser.GetLatestBlockhashResponse
         * @instance
         */
        GetLatestBlockhashResponse.prototype.slot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GetLatestBlockhashResponse blockhash.
         * @member {string} blockhash
         * @memberof geyser.GetLatestBlockhashResponse
         * @instance
         */
        GetLatestBlockhashResponse.prototype.blockhash = "";

        /**
         * GetLatestBlockhashResponse lastValidBlockHeight.
         * @member {number|Long} lastValidBlockHeight
         * @memberof geyser.GetLatestBlockhashResponse
         * @instance
         */
        GetLatestBlockhashResponse.prototype.lastValidBlockHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new GetLatestBlockhashResponse instance using the specified properties.
         * @function create
         * @memberof geyser.GetLatestBlockhashResponse
         * @static
         * @param {geyser.IGetLatestBlockhashResponse=} [properties] Properties to set
         * @returns {geyser.GetLatestBlockhashResponse} GetLatestBlockhashResponse instance
         */
        GetLatestBlockhashResponse.create = function create(properties) {
            return new GetLatestBlockhashResponse(properties);
        };

        /**
         * Encodes the specified GetLatestBlockhashResponse message. Does not implicitly {@link geyser.GetLatestBlockhashResponse.verify|verify} messages.
         * @function encode
         * @memberof geyser.GetLatestBlockhashResponse
         * @static
         * @param {geyser.IGetLatestBlockhashResponse} message GetLatestBlockhashResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLatestBlockhashResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.slot);
            if (message.blockhash != null && Object.hasOwnProperty.call(message, "blockhash"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockhash);
            if (message.lastValidBlockHeight != null && Object.hasOwnProperty.call(message, "lastValidBlockHeight"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.lastValidBlockHeight);
            return writer;
        };

        /**
         * Encodes the specified GetLatestBlockhashResponse message, length delimited. Does not implicitly {@link geyser.GetLatestBlockhashResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.GetLatestBlockhashResponse
         * @static
         * @param {geyser.IGetLatestBlockhashResponse} message GetLatestBlockhashResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLatestBlockhashResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetLatestBlockhashResponse message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.GetLatestBlockhashResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.GetLatestBlockhashResponse} GetLatestBlockhashResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLatestBlockhashResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.GetLatestBlockhashResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.slot = reader.uint64();
                        break;
                    }
                case 2: {
                        message.blockhash = reader.string();
                        break;
                    }
                case 3: {
                        message.lastValidBlockHeight = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetLatestBlockhashResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.GetLatestBlockhashResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.GetLatestBlockhashResponse} GetLatestBlockhashResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLatestBlockhashResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetLatestBlockhashResponse message.
         * @function verify
         * @memberof geyser.GetLatestBlockhashResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetLatestBlockhashResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot) && !(message.slot && $util.isInteger(message.slot.low) && $util.isInteger(message.slot.high)))
                    return "slot: integer|Long expected";
            if (message.blockhash != null && message.hasOwnProperty("blockhash"))
                if (!$util.isString(message.blockhash))
                    return "blockhash: string expected";
            if (message.lastValidBlockHeight != null && message.hasOwnProperty("lastValidBlockHeight"))
                if (!$util.isInteger(message.lastValidBlockHeight) && !(message.lastValidBlockHeight && $util.isInteger(message.lastValidBlockHeight.low) && $util.isInteger(message.lastValidBlockHeight.high)))
                    return "lastValidBlockHeight: integer|Long expected";
            return null;
        };

        /**
         * Creates a GetLatestBlockhashResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.GetLatestBlockhashResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.GetLatestBlockhashResponse} GetLatestBlockhashResponse
         */
        GetLatestBlockhashResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.GetLatestBlockhashResponse)
                return object;
            var message = new $root.geyser.GetLatestBlockhashResponse();
            if (object.slot != null)
                if ($util.Long)
                    (message.slot = $util.Long.fromValue(object.slot)).unsigned = true;
                else if (typeof object.slot === "string")
                    message.slot = parseInt(object.slot, 10);
                else if (typeof object.slot === "number")
                    message.slot = object.slot;
                else if (typeof object.slot === "object")
                    message.slot = new $util.LongBits(object.slot.low >>> 0, object.slot.high >>> 0).toNumber(true);
            if (object.blockhash != null)
                message.blockhash = String(object.blockhash);
            if (object.lastValidBlockHeight != null)
                if ($util.Long)
                    (message.lastValidBlockHeight = $util.Long.fromValue(object.lastValidBlockHeight)).unsigned = true;
                else if (typeof object.lastValidBlockHeight === "string")
                    message.lastValidBlockHeight = parseInt(object.lastValidBlockHeight, 10);
                else if (typeof object.lastValidBlockHeight === "number")
                    message.lastValidBlockHeight = object.lastValidBlockHeight;
                else if (typeof object.lastValidBlockHeight === "object")
                    message.lastValidBlockHeight = new $util.LongBits(object.lastValidBlockHeight.low >>> 0, object.lastValidBlockHeight.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a GetLatestBlockhashResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.GetLatestBlockhashResponse
         * @static
         * @param {geyser.GetLatestBlockhashResponse} message GetLatestBlockhashResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetLatestBlockhashResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.slot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.slot = options.longs === String ? "0" : 0;
                object.blockhash = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.lastValidBlockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastValidBlockHeight = options.longs === String ? "0" : 0;
            }
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (typeof message.slot === "number")
                    object.slot = options.longs === String ? String(message.slot) : message.slot;
                else
                    object.slot = options.longs === String ? $util.Long.prototype.toString.call(message.slot) : options.longs === Number ? new $util.LongBits(message.slot.low >>> 0, message.slot.high >>> 0).toNumber(true) : message.slot;
            if (message.blockhash != null && message.hasOwnProperty("blockhash"))
                object.blockhash = message.blockhash;
            if (message.lastValidBlockHeight != null && message.hasOwnProperty("lastValidBlockHeight"))
                if (typeof message.lastValidBlockHeight === "number")
                    object.lastValidBlockHeight = options.longs === String ? String(message.lastValidBlockHeight) : message.lastValidBlockHeight;
                else
                    object.lastValidBlockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.lastValidBlockHeight) : options.longs === Number ? new $util.LongBits(message.lastValidBlockHeight.low >>> 0, message.lastValidBlockHeight.high >>> 0).toNumber(true) : message.lastValidBlockHeight;
            return object;
        };

        /**
         * Converts this GetLatestBlockhashResponse to JSON.
         * @function toJSON
         * @memberof geyser.GetLatestBlockhashResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetLatestBlockhashResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetLatestBlockhashResponse
         * @function getTypeUrl
         * @memberof geyser.GetLatestBlockhashResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetLatestBlockhashResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.GetLatestBlockhashResponse";
        };

        return GetLatestBlockhashResponse;
    })();

    geyser.GetBlockHeightRequest = (function() {

        /**
         * Properties of a GetBlockHeightRequest.
         * @memberof geyser
         * @interface IGetBlockHeightRequest
         * @property {geyser.CommitmentLevel|null} [commitment] GetBlockHeightRequest commitment
         */

        /**
         * Constructs a new GetBlockHeightRequest.
         * @memberof geyser
         * @classdesc Represents a GetBlockHeightRequest.
         * @implements IGetBlockHeightRequest
         * @constructor
         * @param {geyser.IGetBlockHeightRequest=} [properties] Properties to set
         */
        function GetBlockHeightRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetBlockHeightRequest commitment.
         * @member {geyser.CommitmentLevel|null|undefined} commitment
         * @memberof geyser.GetBlockHeightRequest
         * @instance
         */
        GetBlockHeightRequest.prototype.commitment = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * GetBlockHeightRequest _commitment.
         * @member {"commitment"|undefined} _commitment
         * @memberof geyser.GetBlockHeightRequest
         * @instance
         */
        Object.defineProperty(GetBlockHeightRequest.prototype, "_commitment", {
            get: $util.oneOfGetter($oneOfFields = ["commitment"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new GetBlockHeightRequest instance using the specified properties.
         * @function create
         * @memberof geyser.GetBlockHeightRequest
         * @static
         * @param {geyser.IGetBlockHeightRequest=} [properties] Properties to set
         * @returns {geyser.GetBlockHeightRequest} GetBlockHeightRequest instance
         */
        GetBlockHeightRequest.create = function create(properties) {
            return new GetBlockHeightRequest(properties);
        };

        /**
         * Encodes the specified GetBlockHeightRequest message. Does not implicitly {@link geyser.GetBlockHeightRequest.verify|verify} messages.
         * @function encode
         * @memberof geyser.GetBlockHeightRequest
         * @static
         * @param {geyser.IGetBlockHeightRequest} message GetBlockHeightRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBlockHeightRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.commitment != null && Object.hasOwnProperty.call(message, "commitment"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.commitment);
            return writer;
        };

        /**
         * Encodes the specified GetBlockHeightRequest message, length delimited. Does not implicitly {@link geyser.GetBlockHeightRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.GetBlockHeightRequest
         * @static
         * @param {geyser.IGetBlockHeightRequest} message GetBlockHeightRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBlockHeightRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetBlockHeightRequest message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.GetBlockHeightRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.GetBlockHeightRequest} GetBlockHeightRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBlockHeightRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.GetBlockHeightRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.commitment = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetBlockHeightRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.GetBlockHeightRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.GetBlockHeightRequest} GetBlockHeightRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBlockHeightRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetBlockHeightRequest message.
         * @function verify
         * @memberof geyser.GetBlockHeightRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetBlockHeightRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.commitment != null && message.hasOwnProperty("commitment")) {
                properties._commitment = 1;
                switch (message.commitment) {
                default:
                    return "commitment: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            }
            return null;
        };

        /**
         * Creates a GetBlockHeightRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.GetBlockHeightRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.GetBlockHeightRequest} GetBlockHeightRequest
         */
        GetBlockHeightRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.GetBlockHeightRequest)
                return object;
            var message = new $root.geyser.GetBlockHeightRequest();
            switch (object.commitment) {
            default:
                if (typeof object.commitment === "number") {
                    message.commitment = object.commitment;
                    break;
                }
                break;
            case "PROCESSED":
            case 0:
                message.commitment = 0;
                break;
            case "CONFIRMED":
            case 1:
                message.commitment = 1;
                break;
            case "FINALIZED":
            case 2:
                message.commitment = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetBlockHeightRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.GetBlockHeightRequest
         * @static
         * @param {geyser.GetBlockHeightRequest} message GetBlockHeightRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetBlockHeightRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.commitment != null && message.hasOwnProperty("commitment")) {
                object.commitment = options.enums === String ? $root.geyser.CommitmentLevel[message.commitment] === undefined ? message.commitment : $root.geyser.CommitmentLevel[message.commitment] : message.commitment;
                if (options.oneofs)
                    object._commitment = "commitment";
            }
            return object;
        };

        /**
         * Converts this GetBlockHeightRequest to JSON.
         * @function toJSON
         * @memberof geyser.GetBlockHeightRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetBlockHeightRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetBlockHeightRequest
         * @function getTypeUrl
         * @memberof geyser.GetBlockHeightRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetBlockHeightRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.GetBlockHeightRequest";
        };

        return GetBlockHeightRequest;
    })();

    geyser.GetBlockHeightResponse = (function() {

        /**
         * Properties of a GetBlockHeightResponse.
         * @memberof geyser
         * @interface IGetBlockHeightResponse
         * @property {number|Long|null} [blockHeight] GetBlockHeightResponse blockHeight
         */

        /**
         * Constructs a new GetBlockHeightResponse.
         * @memberof geyser
         * @classdesc Represents a GetBlockHeightResponse.
         * @implements IGetBlockHeightResponse
         * @constructor
         * @param {geyser.IGetBlockHeightResponse=} [properties] Properties to set
         */
        function GetBlockHeightResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetBlockHeightResponse blockHeight.
         * @member {number|Long} blockHeight
         * @memberof geyser.GetBlockHeightResponse
         * @instance
         */
        GetBlockHeightResponse.prototype.blockHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new GetBlockHeightResponse instance using the specified properties.
         * @function create
         * @memberof geyser.GetBlockHeightResponse
         * @static
         * @param {geyser.IGetBlockHeightResponse=} [properties] Properties to set
         * @returns {geyser.GetBlockHeightResponse} GetBlockHeightResponse instance
         */
        GetBlockHeightResponse.create = function create(properties) {
            return new GetBlockHeightResponse(properties);
        };

        /**
         * Encodes the specified GetBlockHeightResponse message. Does not implicitly {@link geyser.GetBlockHeightResponse.verify|verify} messages.
         * @function encode
         * @memberof geyser.GetBlockHeightResponse
         * @static
         * @param {geyser.IGetBlockHeightResponse} message GetBlockHeightResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBlockHeightResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.blockHeight);
            return writer;
        };

        /**
         * Encodes the specified GetBlockHeightResponse message, length delimited. Does not implicitly {@link geyser.GetBlockHeightResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.GetBlockHeightResponse
         * @static
         * @param {geyser.IGetBlockHeightResponse} message GetBlockHeightResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBlockHeightResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetBlockHeightResponse message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.GetBlockHeightResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.GetBlockHeightResponse} GetBlockHeightResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBlockHeightResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.GetBlockHeightResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.blockHeight = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetBlockHeightResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.GetBlockHeightResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.GetBlockHeightResponse} GetBlockHeightResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBlockHeightResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetBlockHeightResponse message.
         * @function verify
         * @memberof geyser.GetBlockHeightResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetBlockHeightResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                if (!$util.isInteger(message.blockHeight) && !(message.blockHeight && $util.isInteger(message.blockHeight.low) && $util.isInteger(message.blockHeight.high)))
                    return "blockHeight: integer|Long expected";
            return null;
        };

        /**
         * Creates a GetBlockHeightResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.GetBlockHeightResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.GetBlockHeightResponse} GetBlockHeightResponse
         */
        GetBlockHeightResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.GetBlockHeightResponse)
                return object;
            var message = new $root.geyser.GetBlockHeightResponse();
            if (object.blockHeight != null)
                if ($util.Long)
                    (message.blockHeight = $util.Long.fromValue(object.blockHeight)).unsigned = true;
                else if (typeof object.blockHeight === "string")
                    message.blockHeight = parseInt(object.blockHeight, 10);
                else if (typeof object.blockHeight === "number")
                    message.blockHeight = object.blockHeight;
                else if (typeof object.blockHeight === "object")
                    message.blockHeight = new $util.LongBits(object.blockHeight.low >>> 0, object.blockHeight.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a GetBlockHeightResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.GetBlockHeightResponse
         * @static
         * @param {geyser.GetBlockHeightResponse} message GetBlockHeightResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetBlockHeightResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.blockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.blockHeight = options.longs === String ? "0" : 0;
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                if (typeof message.blockHeight === "number")
                    object.blockHeight = options.longs === String ? String(message.blockHeight) : message.blockHeight;
                else
                    object.blockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.blockHeight) : options.longs === Number ? new $util.LongBits(message.blockHeight.low >>> 0, message.blockHeight.high >>> 0).toNumber(true) : message.blockHeight;
            return object;
        };

        /**
         * Converts this GetBlockHeightResponse to JSON.
         * @function toJSON
         * @memberof geyser.GetBlockHeightResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetBlockHeightResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetBlockHeightResponse
         * @function getTypeUrl
         * @memberof geyser.GetBlockHeightResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetBlockHeightResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.GetBlockHeightResponse";
        };

        return GetBlockHeightResponse;
    })();

    geyser.GetSlotRequest = (function() {

        /**
         * Properties of a GetSlotRequest.
         * @memberof geyser
         * @interface IGetSlotRequest
         * @property {geyser.CommitmentLevel|null} [commitment] GetSlotRequest commitment
         */

        /**
         * Constructs a new GetSlotRequest.
         * @memberof geyser
         * @classdesc Represents a GetSlotRequest.
         * @implements IGetSlotRequest
         * @constructor
         * @param {geyser.IGetSlotRequest=} [properties] Properties to set
         */
        function GetSlotRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSlotRequest commitment.
         * @member {geyser.CommitmentLevel|null|undefined} commitment
         * @memberof geyser.GetSlotRequest
         * @instance
         */
        GetSlotRequest.prototype.commitment = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * GetSlotRequest _commitment.
         * @member {"commitment"|undefined} _commitment
         * @memberof geyser.GetSlotRequest
         * @instance
         */
        Object.defineProperty(GetSlotRequest.prototype, "_commitment", {
            get: $util.oneOfGetter($oneOfFields = ["commitment"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new GetSlotRequest instance using the specified properties.
         * @function create
         * @memberof geyser.GetSlotRequest
         * @static
         * @param {geyser.IGetSlotRequest=} [properties] Properties to set
         * @returns {geyser.GetSlotRequest} GetSlotRequest instance
         */
        GetSlotRequest.create = function create(properties) {
            return new GetSlotRequest(properties);
        };

        /**
         * Encodes the specified GetSlotRequest message. Does not implicitly {@link geyser.GetSlotRequest.verify|verify} messages.
         * @function encode
         * @memberof geyser.GetSlotRequest
         * @static
         * @param {geyser.IGetSlotRequest} message GetSlotRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSlotRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.commitment != null && Object.hasOwnProperty.call(message, "commitment"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.commitment);
            return writer;
        };

        /**
         * Encodes the specified GetSlotRequest message, length delimited. Does not implicitly {@link geyser.GetSlotRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.GetSlotRequest
         * @static
         * @param {geyser.IGetSlotRequest} message GetSlotRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSlotRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSlotRequest message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.GetSlotRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.GetSlotRequest} GetSlotRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSlotRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.GetSlotRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.commitment = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSlotRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.GetSlotRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.GetSlotRequest} GetSlotRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSlotRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSlotRequest message.
         * @function verify
         * @memberof geyser.GetSlotRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSlotRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.commitment != null && message.hasOwnProperty("commitment")) {
                properties._commitment = 1;
                switch (message.commitment) {
                default:
                    return "commitment: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            }
            return null;
        };

        /**
         * Creates a GetSlotRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.GetSlotRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.GetSlotRequest} GetSlotRequest
         */
        GetSlotRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.GetSlotRequest)
                return object;
            var message = new $root.geyser.GetSlotRequest();
            switch (object.commitment) {
            default:
                if (typeof object.commitment === "number") {
                    message.commitment = object.commitment;
                    break;
                }
                break;
            case "PROCESSED":
            case 0:
                message.commitment = 0;
                break;
            case "CONFIRMED":
            case 1:
                message.commitment = 1;
                break;
            case "FINALIZED":
            case 2:
                message.commitment = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSlotRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.GetSlotRequest
         * @static
         * @param {geyser.GetSlotRequest} message GetSlotRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSlotRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.commitment != null && message.hasOwnProperty("commitment")) {
                object.commitment = options.enums === String ? $root.geyser.CommitmentLevel[message.commitment] === undefined ? message.commitment : $root.geyser.CommitmentLevel[message.commitment] : message.commitment;
                if (options.oneofs)
                    object._commitment = "commitment";
            }
            return object;
        };

        /**
         * Converts this GetSlotRequest to JSON.
         * @function toJSON
         * @memberof geyser.GetSlotRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSlotRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSlotRequest
         * @function getTypeUrl
         * @memberof geyser.GetSlotRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSlotRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.GetSlotRequest";
        };

        return GetSlotRequest;
    })();

    geyser.GetSlotResponse = (function() {

        /**
         * Properties of a GetSlotResponse.
         * @memberof geyser
         * @interface IGetSlotResponse
         * @property {number|Long|null} [slot] GetSlotResponse slot
         */

        /**
         * Constructs a new GetSlotResponse.
         * @memberof geyser
         * @classdesc Represents a GetSlotResponse.
         * @implements IGetSlotResponse
         * @constructor
         * @param {geyser.IGetSlotResponse=} [properties] Properties to set
         */
        function GetSlotResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSlotResponse slot.
         * @member {number|Long} slot
         * @memberof geyser.GetSlotResponse
         * @instance
         */
        GetSlotResponse.prototype.slot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new GetSlotResponse instance using the specified properties.
         * @function create
         * @memberof geyser.GetSlotResponse
         * @static
         * @param {geyser.IGetSlotResponse=} [properties] Properties to set
         * @returns {geyser.GetSlotResponse} GetSlotResponse instance
         */
        GetSlotResponse.create = function create(properties) {
            return new GetSlotResponse(properties);
        };

        /**
         * Encodes the specified GetSlotResponse message. Does not implicitly {@link geyser.GetSlotResponse.verify|verify} messages.
         * @function encode
         * @memberof geyser.GetSlotResponse
         * @static
         * @param {geyser.IGetSlotResponse} message GetSlotResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSlotResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.slot);
            return writer;
        };

        /**
         * Encodes the specified GetSlotResponse message, length delimited. Does not implicitly {@link geyser.GetSlotResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.GetSlotResponse
         * @static
         * @param {geyser.IGetSlotResponse} message GetSlotResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSlotResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSlotResponse message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.GetSlotResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.GetSlotResponse} GetSlotResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSlotResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.GetSlotResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.slot = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSlotResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.GetSlotResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.GetSlotResponse} GetSlotResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSlotResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSlotResponse message.
         * @function verify
         * @memberof geyser.GetSlotResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSlotResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot) && !(message.slot && $util.isInteger(message.slot.low) && $util.isInteger(message.slot.high)))
                    return "slot: integer|Long expected";
            return null;
        };

        /**
         * Creates a GetSlotResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.GetSlotResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.GetSlotResponse} GetSlotResponse
         */
        GetSlotResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.GetSlotResponse)
                return object;
            var message = new $root.geyser.GetSlotResponse();
            if (object.slot != null)
                if ($util.Long)
                    (message.slot = $util.Long.fromValue(object.slot)).unsigned = true;
                else if (typeof object.slot === "string")
                    message.slot = parseInt(object.slot, 10);
                else if (typeof object.slot === "number")
                    message.slot = object.slot;
                else if (typeof object.slot === "object")
                    message.slot = new $util.LongBits(object.slot.low >>> 0, object.slot.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a GetSlotResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.GetSlotResponse
         * @static
         * @param {geyser.GetSlotResponse} message GetSlotResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSlotResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.slot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.slot = options.longs === String ? "0" : 0;
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (typeof message.slot === "number")
                    object.slot = options.longs === String ? String(message.slot) : message.slot;
                else
                    object.slot = options.longs === String ? $util.Long.prototype.toString.call(message.slot) : options.longs === Number ? new $util.LongBits(message.slot.low >>> 0, message.slot.high >>> 0).toNumber(true) : message.slot;
            return object;
        };

        /**
         * Converts this GetSlotResponse to JSON.
         * @function toJSON
         * @memberof geyser.GetSlotResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSlotResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetSlotResponse
         * @function getTypeUrl
         * @memberof geyser.GetSlotResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetSlotResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.GetSlotResponse";
        };

        return GetSlotResponse;
    })();

    geyser.GetVersionRequest = (function() {

        /**
         * Properties of a GetVersionRequest.
         * @memberof geyser
         * @interface IGetVersionRequest
         */

        /**
         * Constructs a new GetVersionRequest.
         * @memberof geyser
         * @classdesc Represents a GetVersionRequest.
         * @implements IGetVersionRequest
         * @constructor
         * @param {geyser.IGetVersionRequest=} [properties] Properties to set
         */
        function GetVersionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetVersionRequest instance using the specified properties.
         * @function create
         * @memberof geyser.GetVersionRequest
         * @static
         * @param {geyser.IGetVersionRequest=} [properties] Properties to set
         * @returns {geyser.GetVersionRequest} GetVersionRequest instance
         */
        GetVersionRequest.create = function create(properties) {
            return new GetVersionRequest(properties);
        };

        /**
         * Encodes the specified GetVersionRequest message. Does not implicitly {@link geyser.GetVersionRequest.verify|verify} messages.
         * @function encode
         * @memberof geyser.GetVersionRequest
         * @static
         * @param {geyser.IGetVersionRequest} message GetVersionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVersionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetVersionRequest message, length delimited. Does not implicitly {@link geyser.GetVersionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.GetVersionRequest
         * @static
         * @param {geyser.IGetVersionRequest} message GetVersionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVersionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetVersionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.GetVersionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.GetVersionRequest} GetVersionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVersionRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.GetVersionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetVersionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.GetVersionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.GetVersionRequest} GetVersionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVersionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetVersionRequest message.
         * @function verify
         * @memberof geyser.GetVersionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetVersionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetVersionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.GetVersionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.GetVersionRequest} GetVersionRequest
         */
        GetVersionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.GetVersionRequest)
                return object;
            return new $root.geyser.GetVersionRequest();
        };

        /**
         * Creates a plain object from a GetVersionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.GetVersionRequest
         * @static
         * @param {geyser.GetVersionRequest} message GetVersionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetVersionRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetVersionRequest to JSON.
         * @function toJSON
         * @memberof geyser.GetVersionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetVersionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetVersionRequest
         * @function getTypeUrl
         * @memberof geyser.GetVersionRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetVersionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.GetVersionRequest";
        };

        return GetVersionRequest;
    })();

    geyser.GetVersionResponse = (function() {

        /**
         * Properties of a GetVersionResponse.
         * @memberof geyser
         * @interface IGetVersionResponse
         * @property {string|null} [version] GetVersionResponse version
         */

        /**
         * Constructs a new GetVersionResponse.
         * @memberof geyser
         * @classdesc Represents a GetVersionResponse.
         * @implements IGetVersionResponse
         * @constructor
         * @param {geyser.IGetVersionResponse=} [properties] Properties to set
         */
        function GetVersionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetVersionResponse version.
         * @member {string} version
         * @memberof geyser.GetVersionResponse
         * @instance
         */
        GetVersionResponse.prototype.version = "";

        /**
         * Creates a new GetVersionResponse instance using the specified properties.
         * @function create
         * @memberof geyser.GetVersionResponse
         * @static
         * @param {geyser.IGetVersionResponse=} [properties] Properties to set
         * @returns {geyser.GetVersionResponse} GetVersionResponse instance
         */
        GetVersionResponse.create = function create(properties) {
            return new GetVersionResponse(properties);
        };

        /**
         * Encodes the specified GetVersionResponse message. Does not implicitly {@link geyser.GetVersionResponse.verify|verify} messages.
         * @function encode
         * @memberof geyser.GetVersionResponse
         * @static
         * @param {geyser.IGetVersionResponse} message GetVersionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVersionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
            return writer;
        };

        /**
         * Encodes the specified GetVersionResponse message, length delimited. Does not implicitly {@link geyser.GetVersionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.GetVersionResponse
         * @static
         * @param {geyser.IGetVersionResponse} message GetVersionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVersionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetVersionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.GetVersionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.GetVersionResponse} GetVersionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVersionResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.GetVersionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.version = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetVersionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.GetVersionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.GetVersionResponse} GetVersionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVersionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetVersionResponse message.
         * @function verify
         * @memberof geyser.GetVersionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetVersionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            return null;
        };

        /**
         * Creates a GetVersionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.GetVersionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.GetVersionResponse} GetVersionResponse
         */
        GetVersionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.GetVersionResponse)
                return object;
            var message = new $root.geyser.GetVersionResponse();
            if (object.version != null)
                message.version = String(object.version);
            return message;
        };

        /**
         * Creates a plain object from a GetVersionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.GetVersionResponse
         * @static
         * @param {geyser.GetVersionResponse} message GetVersionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetVersionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.version = "";
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this GetVersionResponse to JSON.
         * @function toJSON
         * @memberof geyser.GetVersionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetVersionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GetVersionResponse
         * @function getTypeUrl
         * @memberof geyser.GetVersionResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GetVersionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.GetVersionResponse";
        };

        return GetVersionResponse;
    })();

    geyser.IsBlockhashValidRequest = (function() {

        /**
         * Properties of an IsBlockhashValidRequest.
         * @memberof geyser
         * @interface IIsBlockhashValidRequest
         * @property {string|null} [blockhash] IsBlockhashValidRequest blockhash
         * @property {geyser.CommitmentLevel|null} [commitment] IsBlockhashValidRequest commitment
         */

        /**
         * Constructs a new IsBlockhashValidRequest.
         * @memberof geyser
         * @classdesc Represents an IsBlockhashValidRequest.
         * @implements IIsBlockhashValidRequest
         * @constructor
         * @param {geyser.IIsBlockhashValidRequest=} [properties] Properties to set
         */
        function IsBlockhashValidRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IsBlockhashValidRequest blockhash.
         * @member {string} blockhash
         * @memberof geyser.IsBlockhashValidRequest
         * @instance
         */
        IsBlockhashValidRequest.prototype.blockhash = "";

        /**
         * IsBlockhashValidRequest commitment.
         * @member {geyser.CommitmentLevel|null|undefined} commitment
         * @memberof geyser.IsBlockhashValidRequest
         * @instance
         */
        IsBlockhashValidRequest.prototype.commitment = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * IsBlockhashValidRequest _commitment.
         * @member {"commitment"|undefined} _commitment
         * @memberof geyser.IsBlockhashValidRequest
         * @instance
         */
        Object.defineProperty(IsBlockhashValidRequest.prototype, "_commitment", {
            get: $util.oneOfGetter($oneOfFields = ["commitment"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new IsBlockhashValidRequest instance using the specified properties.
         * @function create
         * @memberof geyser.IsBlockhashValidRequest
         * @static
         * @param {geyser.IIsBlockhashValidRequest=} [properties] Properties to set
         * @returns {geyser.IsBlockhashValidRequest} IsBlockhashValidRequest instance
         */
        IsBlockhashValidRequest.create = function create(properties) {
            return new IsBlockhashValidRequest(properties);
        };

        /**
         * Encodes the specified IsBlockhashValidRequest message. Does not implicitly {@link geyser.IsBlockhashValidRequest.verify|verify} messages.
         * @function encode
         * @memberof geyser.IsBlockhashValidRequest
         * @static
         * @param {geyser.IIsBlockhashValidRequest} message IsBlockhashValidRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IsBlockhashValidRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockhash != null && Object.hasOwnProperty.call(message, "blockhash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.blockhash);
            if (message.commitment != null && Object.hasOwnProperty.call(message, "commitment"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.commitment);
            return writer;
        };

        /**
         * Encodes the specified IsBlockhashValidRequest message, length delimited. Does not implicitly {@link geyser.IsBlockhashValidRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.IsBlockhashValidRequest
         * @static
         * @param {geyser.IIsBlockhashValidRequest} message IsBlockhashValidRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IsBlockhashValidRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IsBlockhashValidRequest message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.IsBlockhashValidRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.IsBlockhashValidRequest} IsBlockhashValidRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IsBlockhashValidRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.IsBlockhashValidRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.blockhash = reader.string();
                        break;
                    }
                case 2: {
                        message.commitment = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IsBlockhashValidRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.IsBlockhashValidRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.IsBlockhashValidRequest} IsBlockhashValidRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IsBlockhashValidRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IsBlockhashValidRequest message.
         * @function verify
         * @memberof geyser.IsBlockhashValidRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IsBlockhashValidRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.blockhash != null && message.hasOwnProperty("blockhash"))
                if (!$util.isString(message.blockhash))
                    return "blockhash: string expected";
            if (message.commitment != null && message.hasOwnProperty("commitment")) {
                properties._commitment = 1;
                switch (message.commitment) {
                default:
                    return "commitment: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            }
            return null;
        };

        /**
         * Creates an IsBlockhashValidRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.IsBlockhashValidRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.IsBlockhashValidRequest} IsBlockhashValidRequest
         */
        IsBlockhashValidRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.IsBlockhashValidRequest)
                return object;
            var message = new $root.geyser.IsBlockhashValidRequest();
            if (object.blockhash != null)
                message.blockhash = String(object.blockhash);
            switch (object.commitment) {
            default:
                if (typeof object.commitment === "number") {
                    message.commitment = object.commitment;
                    break;
                }
                break;
            case "PROCESSED":
            case 0:
                message.commitment = 0;
                break;
            case "CONFIRMED":
            case 1:
                message.commitment = 1;
                break;
            case "FINALIZED":
            case 2:
                message.commitment = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an IsBlockhashValidRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.IsBlockhashValidRequest
         * @static
         * @param {geyser.IsBlockhashValidRequest} message IsBlockhashValidRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IsBlockhashValidRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.blockhash = "";
            if (message.blockhash != null && message.hasOwnProperty("blockhash"))
                object.blockhash = message.blockhash;
            if (message.commitment != null && message.hasOwnProperty("commitment")) {
                object.commitment = options.enums === String ? $root.geyser.CommitmentLevel[message.commitment] === undefined ? message.commitment : $root.geyser.CommitmentLevel[message.commitment] : message.commitment;
                if (options.oneofs)
                    object._commitment = "commitment";
            }
            return object;
        };

        /**
         * Converts this IsBlockhashValidRequest to JSON.
         * @function toJSON
         * @memberof geyser.IsBlockhashValidRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IsBlockhashValidRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for IsBlockhashValidRequest
         * @function getTypeUrl
         * @memberof geyser.IsBlockhashValidRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        IsBlockhashValidRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.IsBlockhashValidRequest";
        };

        return IsBlockhashValidRequest;
    })();

    geyser.IsBlockhashValidResponse = (function() {

        /**
         * Properties of an IsBlockhashValidResponse.
         * @memberof geyser
         * @interface IIsBlockhashValidResponse
         * @property {number|Long|null} [slot] IsBlockhashValidResponse slot
         * @property {boolean|null} [valid] IsBlockhashValidResponse valid
         */

        /**
         * Constructs a new IsBlockhashValidResponse.
         * @memberof geyser
         * @classdesc Represents an IsBlockhashValidResponse.
         * @implements IIsBlockhashValidResponse
         * @constructor
         * @param {geyser.IIsBlockhashValidResponse=} [properties] Properties to set
         */
        function IsBlockhashValidResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IsBlockhashValidResponse slot.
         * @member {number|Long} slot
         * @memberof geyser.IsBlockhashValidResponse
         * @instance
         */
        IsBlockhashValidResponse.prototype.slot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * IsBlockhashValidResponse valid.
         * @member {boolean} valid
         * @memberof geyser.IsBlockhashValidResponse
         * @instance
         */
        IsBlockhashValidResponse.prototype.valid = false;

        /**
         * Creates a new IsBlockhashValidResponse instance using the specified properties.
         * @function create
         * @memberof geyser.IsBlockhashValidResponse
         * @static
         * @param {geyser.IIsBlockhashValidResponse=} [properties] Properties to set
         * @returns {geyser.IsBlockhashValidResponse} IsBlockhashValidResponse instance
         */
        IsBlockhashValidResponse.create = function create(properties) {
            return new IsBlockhashValidResponse(properties);
        };

        /**
         * Encodes the specified IsBlockhashValidResponse message. Does not implicitly {@link geyser.IsBlockhashValidResponse.verify|verify} messages.
         * @function encode
         * @memberof geyser.IsBlockhashValidResponse
         * @static
         * @param {geyser.IIsBlockhashValidResponse} message IsBlockhashValidResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IsBlockhashValidResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && Object.hasOwnProperty.call(message, "slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.slot);
            if (message.valid != null && Object.hasOwnProperty.call(message, "valid"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.valid);
            return writer;
        };

        /**
         * Encodes the specified IsBlockhashValidResponse message, length delimited. Does not implicitly {@link geyser.IsBlockhashValidResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof geyser.IsBlockhashValidResponse
         * @static
         * @param {geyser.IIsBlockhashValidResponse} message IsBlockhashValidResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IsBlockhashValidResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IsBlockhashValidResponse message from the specified reader or buffer.
         * @function decode
         * @memberof geyser.IsBlockhashValidResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {geyser.IsBlockhashValidResponse} IsBlockhashValidResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IsBlockhashValidResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.geyser.IsBlockhashValidResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.slot = reader.uint64();
                        break;
                    }
                case 2: {
                        message.valid = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IsBlockhashValidResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof geyser.IsBlockhashValidResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {geyser.IsBlockhashValidResponse} IsBlockhashValidResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IsBlockhashValidResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IsBlockhashValidResponse message.
         * @function verify
         * @memberof geyser.IsBlockhashValidResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IsBlockhashValidResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot) && !(message.slot && $util.isInteger(message.slot.low) && $util.isInteger(message.slot.high)))
                    return "slot: integer|Long expected";
            if (message.valid != null && message.hasOwnProperty("valid"))
                if (typeof message.valid !== "boolean")
                    return "valid: boolean expected";
            return null;
        };

        /**
         * Creates an IsBlockhashValidResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof geyser.IsBlockhashValidResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {geyser.IsBlockhashValidResponse} IsBlockhashValidResponse
         */
        IsBlockhashValidResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.geyser.IsBlockhashValidResponse)
                return object;
            var message = new $root.geyser.IsBlockhashValidResponse();
            if (object.slot != null)
                if ($util.Long)
                    (message.slot = $util.Long.fromValue(object.slot)).unsigned = true;
                else if (typeof object.slot === "string")
                    message.slot = parseInt(object.slot, 10);
                else if (typeof object.slot === "number")
                    message.slot = object.slot;
                else if (typeof object.slot === "object")
                    message.slot = new $util.LongBits(object.slot.low >>> 0, object.slot.high >>> 0).toNumber(true);
            if (object.valid != null)
                message.valid = Boolean(object.valid);
            return message;
        };

        /**
         * Creates a plain object from an IsBlockhashValidResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof geyser.IsBlockhashValidResponse
         * @static
         * @param {geyser.IsBlockhashValidResponse} message IsBlockhashValidResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IsBlockhashValidResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.slot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.slot = options.longs === String ? "0" : 0;
                object.valid = false;
            }
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (typeof message.slot === "number")
                    object.slot = options.longs === String ? String(message.slot) : message.slot;
                else
                    object.slot = options.longs === String ? $util.Long.prototype.toString.call(message.slot) : options.longs === Number ? new $util.LongBits(message.slot.low >>> 0, message.slot.high >>> 0).toNumber(true) : message.slot;
            if (message.valid != null && message.hasOwnProperty("valid"))
                object.valid = message.valid;
            return object;
        };

        /**
         * Converts this IsBlockhashValidResponse to JSON.
         * @function toJSON
         * @memberof geyser.IsBlockhashValidResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IsBlockhashValidResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for IsBlockhashValidResponse
         * @function getTypeUrl
         * @memberof geyser.IsBlockhashValidResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        IsBlockhashValidResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/geyser.IsBlockhashValidResponse";
        };

        return IsBlockhashValidResponse;
    })();

    return geyser;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @memberof google.protobuf
             * @interface ITimestamp
             * @property {number|Long|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */

            /**
             * Constructs a new Timestamp.
             * @memberof google.protobuf
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             * @returns {google.protobuf.Timestamp} Timestamp instance
             */
            Timestamp.create = function create(properties) {
                return new Timestamp(properties);
            };

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.seconds = reader.int64();
                            break;
                        }
                    case 2: {
                            message.nanos = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Timestamp message.
             * @function verify
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp)
                    return object;
                var message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Timestamp to JSON.
             * @function toJSON
             * @memberof google.protobuf.Timestamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Timestamp
             * @function getTypeUrl
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Timestamp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Timestamp";
            };

            return Timestamp;
        })();

        return protobuf;
    })();

    return google;
})();

$root.solana = (function() {

    /**
     * Namespace solana.
     * @exports solana
     * @namespace
     */
    var solana = {};

    solana.storage = (function() {

        /**
         * Namespace storage.
         * @memberof solana
         * @namespace
         */
        var storage = {};

        storage.ConfirmedBlock = (function() {

            /**
             * Namespace ConfirmedBlock.
             * @memberof solana.storage
             * @namespace
             */
            var ConfirmedBlock = {};

            ConfirmedBlock.ConfirmedBlock = (function() {

                /**
                 * Properties of a ConfirmedBlock.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface IConfirmedBlock
                 * @property {string|null} [previousBlockhash] ConfirmedBlock previousBlockhash
                 * @property {string|null} [blockhash] ConfirmedBlock blockhash
                 * @property {number|Long|null} [parentSlot] ConfirmedBlock parentSlot
                 * @property {Array.<solana.storage.ConfirmedBlock.IConfirmedTransaction>|null} [transactions] ConfirmedBlock transactions
                 * @property {Array.<solana.storage.ConfirmedBlock.IReward>|null} [rewards] ConfirmedBlock rewards
                 * @property {solana.storage.ConfirmedBlock.IUnixTimestamp|null} [blockTime] ConfirmedBlock blockTime
                 * @property {solana.storage.ConfirmedBlock.IBlockHeight|null} [blockHeight] ConfirmedBlock blockHeight
                 * @property {solana.storage.ConfirmedBlock.INumPartitions|null} [numPartitions] ConfirmedBlock numPartitions
                 */

                /**
                 * Constructs a new ConfirmedBlock.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a ConfirmedBlock.
                 * @implements IConfirmedBlock
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.IConfirmedBlock=} [properties] Properties to set
                 */
                function ConfirmedBlock(properties) {
                    this.transactions = [];
                    this.rewards = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ConfirmedBlock previousBlockhash.
                 * @member {string} previousBlockhash
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @instance
                 */
                ConfirmedBlock.prototype.previousBlockhash = "";

                /**
                 * ConfirmedBlock blockhash.
                 * @member {string} blockhash
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @instance
                 */
                ConfirmedBlock.prototype.blockhash = "";

                /**
                 * ConfirmedBlock parentSlot.
                 * @member {number|Long} parentSlot
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @instance
                 */
                ConfirmedBlock.prototype.parentSlot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ConfirmedBlock transactions.
                 * @member {Array.<solana.storage.ConfirmedBlock.IConfirmedTransaction>} transactions
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @instance
                 */
                ConfirmedBlock.prototype.transactions = $util.emptyArray;

                /**
                 * ConfirmedBlock rewards.
                 * @member {Array.<solana.storage.ConfirmedBlock.IReward>} rewards
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @instance
                 */
                ConfirmedBlock.prototype.rewards = $util.emptyArray;

                /**
                 * ConfirmedBlock blockTime.
                 * @member {solana.storage.ConfirmedBlock.IUnixTimestamp|null|undefined} blockTime
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @instance
                 */
                ConfirmedBlock.prototype.blockTime = null;

                /**
                 * ConfirmedBlock blockHeight.
                 * @member {solana.storage.ConfirmedBlock.IBlockHeight|null|undefined} blockHeight
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @instance
                 */
                ConfirmedBlock.prototype.blockHeight = null;

                /**
                 * ConfirmedBlock numPartitions.
                 * @member {solana.storage.ConfirmedBlock.INumPartitions|null|undefined} numPartitions
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @instance
                 */
                ConfirmedBlock.prototype.numPartitions = null;

                /**
                 * Creates a new ConfirmedBlock instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IConfirmedBlock=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.ConfirmedBlock} ConfirmedBlock instance
                 */
                ConfirmedBlock.create = function create(properties) {
                    return new ConfirmedBlock(properties);
                };

                /**
                 * Encodes the specified ConfirmedBlock message. Does not implicitly {@link solana.storage.ConfirmedBlock.ConfirmedBlock.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IConfirmedBlock} message ConfirmedBlock message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConfirmedBlock.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.previousBlockhash != null && Object.hasOwnProperty.call(message, "previousBlockhash"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.previousBlockhash);
                    if (message.blockhash != null && Object.hasOwnProperty.call(message, "blockhash"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockhash);
                    if (message.parentSlot != null && Object.hasOwnProperty.call(message, "parentSlot"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.parentSlot);
                    if (message.transactions != null && message.transactions.length)
                        for (var i = 0; i < message.transactions.length; ++i)
                            $root.solana.storage.ConfirmedBlock.ConfirmedTransaction.encode(message.transactions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.rewards != null && message.rewards.length)
                        for (var i = 0; i < message.rewards.length; ++i)
                            $root.solana.storage.ConfirmedBlock.Reward.encode(message.rewards[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.blockTime != null && Object.hasOwnProperty.call(message, "blockTime"))
                        $root.solana.storage.ConfirmedBlock.UnixTimestamp.encode(message.blockTime, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
                        $root.solana.storage.ConfirmedBlock.BlockHeight.encode(message.blockHeight, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.numPartitions != null && Object.hasOwnProperty.call(message, "numPartitions"))
                        $root.solana.storage.ConfirmedBlock.NumPartitions.encode(message.numPartitions, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ConfirmedBlock message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.ConfirmedBlock.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IConfirmedBlock} message ConfirmedBlock message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConfirmedBlock.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ConfirmedBlock message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.ConfirmedBlock} ConfirmedBlock
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConfirmedBlock.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.ConfirmedBlock();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.previousBlockhash = reader.string();
                                break;
                            }
                        case 2: {
                                message.blockhash = reader.string();
                                break;
                            }
                        case 3: {
                                message.parentSlot = reader.uint64();
                                break;
                            }
                        case 4: {
                                if (!(message.transactions && message.transactions.length))
                                    message.transactions = [];
                                message.transactions.push($root.solana.storage.ConfirmedBlock.ConfirmedTransaction.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                if (!(message.rewards && message.rewards.length))
                                    message.rewards = [];
                                message.rewards.push($root.solana.storage.ConfirmedBlock.Reward.decode(reader, reader.uint32()));
                                break;
                            }
                        case 6: {
                                message.blockTime = $root.solana.storage.ConfirmedBlock.UnixTimestamp.decode(reader, reader.uint32());
                                break;
                            }
                        case 7: {
                                message.blockHeight = $root.solana.storage.ConfirmedBlock.BlockHeight.decode(reader, reader.uint32());
                                break;
                            }
                        case 8: {
                                message.numPartitions = $root.solana.storage.ConfirmedBlock.NumPartitions.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ConfirmedBlock message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.ConfirmedBlock} ConfirmedBlock
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConfirmedBlock.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ConfirmedBlock message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConfirmedBlock.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.previousBlockhash != null && message.hasOwnProperty("previousBlockhash"))
                        if (!$util.isString(message.previousBlockhash))
                            return "previousBlockhash: string expected";
                    if (message.blockhash != null && message.hasOwnProperty("blockhash"))
                        if (!$util.isString(message.blockhash))
                            return "blockhash: string expected";
                    if (message.parentSlot != null && message.hasOwnProperty("parentSlot"))
                        if (!$util.isInteger(message.parentSlot) && !(message.parentSlot && $util.isInteger(message.parentSlot.low) && $util.isInteger(message.parentSlot.high)))
                            return "parentSlot: integer|Long expected";
                    if (message.transactions != null && message.hasOwnProperty("transactions")) {
                        if (!Array.isArray(message.transactions))
                            return "transactions: array expected";
                        for (var i = 0; i < message.transactions.length; ++i) {
                            var error = $root.solana.storage.ConfirmedBlock.ConfirmedTransaction.verify(message.transactions[i]);
                            if (error)
                                return "transactions." + error;
                        }
                    }
                    if (message.rewards != null && message.hasOwnProperty("rewards")) {
                        if (!Array.isArray(message.rewards))
                            return "rewards: array expected";
                        for (var i = 0; i < message.rewards.length; ++i) {
                            var error = $root.solana.storage.ConfirmedBlock.Reward.verify(message.rewards[i]);
                            if (error)
                                return "rewards." + error;
                        }
                    }
                    if (message.blockTime != null && message.hasOwnProperty("blockTime")) {
                        var error = $root.solana.storage.ConfirmedBlock.UnixTimestamp.verify(message.blockTime);
                        if (error)
                            return "blockTime." + error;
                    }
                    if (message.blockHeight != null && message.hasOwnProperty("blockHeight")) {
                        var error = $root.solana.storage.ConfirmedBlock.BlockHeight.verify(message.blockHeight);
                        if (error)
                            return "blockHeight." + error;
                    }
                    if (message.numPartitions != null && message.hasOwnProperty("numPartitions")) {
                        var error = $root.solana.storage.ConfirmedBlock.NumPartitions.verify(message.numPartitions);
                        if (error)
                            return "numPartitions." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ConfirmedBlock message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.ConfirmedBlock} ConfirmedBlock
                 */
                ConfirmedBlock.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.ConfirmedBlock)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.ConfirmedBlock();
                    if (object.previousBlockhash != null)
                        message.previousBlockhash = String(object.previousBlockhash);
                    if (object.blockhash != null)
                        message.blockhash = String(object.blockhash);
                    if (object.parentSlot != null)
                        if ($util.Long)
                            (message.parentSlot = $util.Long.fromValue(object.parentSlot)).unsigned = true;
                        else if (typeof object.parentSlot === "string")
                            message.parentSlot = parseInt(object.parentSlot, 10);
                        else if (typeof object.parentSlot === "number")
                            message.parentSlot = object.parentSlot;
                        else if (typeof object.parentSlot === "object")
                            message.parentSlot = new $util.LongBits(object.parentSlot.low >>> 0, object.parentSlot.high >>> 0).toNumber(true);
                    if (object.transactions) {
                        if (!Array.isArray(object.transactions))
                            throw TypeError(".solana.storage.ConfirmedBlock.ConfirmedBlock.transactions: array expected");
                        message.transactions = [];
                        for (var i = 0; i < object.transactions.length; ++i) {
                            if (typeof object.transactions[i] !== "object")
                                throw TypeError(".solana.storage.ConfirmedBlock.ConfirmedBlock.transactions: object expected");
                            message.transactions[i] = $root.solana.storage.ConfirmedBlock.ConfirmedTransaction.fromObject(object.transactions[i]);
                        }
                    }
                    if (object.rewards) {
                        if (!Array.isArray(object.rewards))
                            throw TypeError(".solana.storage.ConfirmedBlock.ConfirmedBlock.rewards: array expected");
                        message.rewards = [];
                        for (var i = 0; i < object.rewards.length; ++i) {
                            if (typeof object.rewards[i] !== "object")
                                throw TypeError(".solana.storage.ConfirmedBlock.ConfirmedBlock.rewards: object expected");
                            message.rewards[i] = $root.solana.storage.ConfirmedBlock.Reward.fromObject(object.rewards[i]);
                        }
                    }
                    if (object.blockTime != null) {
                        if (typeof object.blockTime !== "object")
                            throw TypeError(".solana.storage.ConfirmedBlock.ConfirmedBlock.blockTime: object expected");
                        message.blockTime = $root.solana.storage.ConfirmedBlock.UnixTimestamp.fromObject(object.blockTime);
                    }
                    if (object.blockHeight != null) {
                        if (typeof object.blockHeight !== "object")
                            throw TypeError(".solana.storage.ConfirmedBlock.ConfirmedBlock.blockHeight: object expected");
                        message.blockHeight = $root.solana.storage.ConfirmedBlock.BlockHeight.fromObject(object.blockHeight);
                    }
                    if (object.numPartitions != null) {
                        if (typeof object.numPartitions !== "object")
                            throw TypeError(".solana.storage.ConfirmedBlock.ConfirmedBlock.numPartitions: object expected");
                        message.numPartitions = $root.solana.storage.ConfirmedBlock.NumPartitions.fromObject(object.numPartitions);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ConfirmedBlock message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ConfirmedBlock} message ConfirmedBlock
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConfirmedBlock.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.transactions = [];
                        object.rewards = [];
                    }
                    if (options.defaults) {
                        object.previousBlockhash = "";
                        object.blockhash = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.parentSlot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.parentSlot = options.longs === String ? "0" : 0;
                        object.blockTime = null;
                        object.blockHeight = null;
                        object.numPartitions = null;
                    }
                    if (message.previousBlockhash != null && message.hasOwnProperty("previousBlockhash"))
                        object.previousBlockhash = message.previousBlockhash;
                    if (message.blockhash != null && message.hasOwnProperty("blockhash"))
                        object.blockhash = message.blockhash;
                    if (message.parentSlot != null && message.hasOwnProperty("parentSlot"))
                        if (typeof message.parentSlot === "number")
                            object.parentSlot = options.longs === String ? String(message.parentSlot) : message.parentSlot;
                        else
                            object.parentSlot = options.longs === String ? $util.Long.prototype.toString.call(message.parentSlot) : options.longs === Number ? new $util.LongBits(message.parentSlot.low >>> 0, message.parentSlot.high >>> 0).toNumber(true) : message.parentSlot;
                    if (message.transactions && message.transactions.length) {
                        object.transactions = [];
                        for (var j = 0; j < message.transactions.length; ++j)
                            object.transactions[j] = $root.solana.storage.ConfirmedBlock.ConfirmedTransaction.toObject(message.transactions[j], options);
                    }
                    if (message.rewards && message.rewards.length) {
                        object.rewards = [];
                        for (var j = 0; j < message.rewards.length; ++j)
                            object.rewards[j] = $root.solana.storage.ConfirmedBlock.Reward.toObject(message.rewards[j], options);
                    }
                    if (message.blockTime != null && message.hasOwnProperty("blockTime"))
                        object.blockTime = $root.solana.storage.ConfirmedBlock.UnixTimestamp.toObject(message.blockTime, options);
                    if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                        object.blockHeight = $root.solana.storage.ConfirmedBlock.BlockHeight.toObject(message.blockHeight, options);
                    if (message.numPartitions != null && message.hasOwnProperty("numPartitions"))
                        object.numPartitions = $root.solana.storage.ConfirmedBlock.NumPartitions.toObject(message.numPartitions, options);
                    return object;
                };

                /**
                 * Converts this ConfirmedBlock to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConfirmedBlock.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ConfirmedBlock
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedBlock
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ConfirmedBlock.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.ConfirmedBlock";
                };

                return ConfirmedBlock;
            })();

            ConfirmedBlock.ConfirmedTransaction = (function() {

                /**
                 * Properties of a ConfirmedTransaction.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface IConfirmedTransaction
                 * @property {solana.storage.ConfirmedBlock.ITransaction|null} [transaction] ConfirmedTransaction transaction
                 * @property {solana.storage.ConfirmedBlock.ITransactionStatusMeta|null} [meta] ConfirmedTransaction meta
                 */

                /**
                 * Constructs a new ConfirmedTransaction.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a ConfirmedTransaction.
                 * @implements IConfirmedTransaction
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.IConfirmedTransaction=} [properties] Properties to set
                 */
                function ConfirmedTransaction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ConfirmedTransaction transaction.
                 * @member {solana.storage.ConfirmedBlock.ITransaction|null|undefined} transaction
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedTransaction
                 * @instance
                 */
                ConfirmedTransaction.prototype.transaction = null;

                /**
                 * ConfirmedTransaction meta.
                 * @member {solana.storage.ConfirmedBlock.ITransactionStatusMeta|null|undefined} meta
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedTransaction
                 * @instance
                 */
                ConfirmedTransaction.prototype.meta = null;

                /**
                 * Creates a new ConfirmedTransaction instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedTransaction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IConfirmedTransaction=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.ConfirmedTransaction} ConfirmedTransaction instance
                 */
                ConfirmedTransaction.create = function create(properties) {
                    return new ConfirmedTransaction(properties);
                };

                /**
                 * Encodes the specified ConfirmedTransaction message. Does not implicitly {@link solana.storage.ConfirmedBlock.ConfirmedTransaction.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedTransaction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IConfirmedTransaction} message ConfirmedTransaction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConfirmedTransaction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                        $root.solana.storage.ConfirmedBlock.Transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.meta != null && Object.hasOwnProperty.call(message, "meta"))
                        $root.solana.storage.ConfirmedBlock.TransactionStatusMeta.encode(message.meta, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ConfirmedTransaction message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.ConfirmedTransaction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedTransaction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IConfirmedTransaction} message ConfirmedTransaction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConfirmedTransaction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ConfirmedTransaction message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedTransaction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.ConfirmedTransaction} ConfirmedTransaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConfirmedTransaction.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.ConfirmedTransaction();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.transaction = $root.solana.storage.ConfirmedBlock.Transaction.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.meta = $root.solana.storage.ConfirmedBlock.TransactionStatusMeta.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ConfirmedTransaction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedTransaction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.ConfirmedTransaction} ConfirmedTransaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConfirmedTransaction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ConfirmedTransaction message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedTransaction
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConfirmedTransaction.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.transaction != null && message.hasOwnProperty("transaction")) {
                        var error = $root.solana.storage.ConfirmedBlock.Transaction.verify(message.transaction);
                        if (error)
                            return "transaction." + error;
                    }
                    if (message.meta != null && message.hasOwnProperty("meta")) {
                        var error = $root.solana.storage.ConfirmedBlock.TransactionStatusMeta.verify(message.meta);
                        if (error)
                            return "meta." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ConfirmedTransaction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedTransaction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.ConfirmedTransaction} ConfirmedTransaction
                 */
                ConfirmedTransaction.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.ConfirmedTransaction)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.ConfirmedTransaction();
                    if (object.transaction != null) {
                        if (typeof object.transaction !== "object")
                            throw TypeError(".solana.storage.ConfirmedBlock.ConfirmedTransaction.transaction: object expected");
                        message.transaction = $root.solana.storage.ConfirmedBlock.Transaction.fromObject(object.transaction);
                    }
                    if (object.meta != null) {
                        if (typeof object.meta !== "object")
                            throw TypeError(".solana.storage.ConfirmedBlock.ConfirmedTransaction.meta: object expected");
                        message.meta = $root.solana.storage.ConfirmedBlock.TransactionStatusMeta.fromObject(object.meta);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ConfirmedTransaction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedTransaction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ConfirmedTransaction} message ConfirmedTransaction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConfirmedTransaction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.transaction = null;
                        object.meta = null;
                    }
                    if (message.transaction != null && message.hasOwnProperty("transaction"))
                        object.transaction = $root.solana.storage.ConfirmedBlock.Transaction.toObject(message.transaction, options);
                    if (message.meta != null && message.hasOwnProperty("meta"))
                        object.meta = $root.solana.storage.ConfirmedBlock.TransactionStatusMeta.toObject(message.meta, options);
                    return object;
                };

                /**
                 * Converts this ConfirmedTransaction to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedTransaction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConfirmedTransaction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ConfirmedTransaction
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.ConfirmedTransaction
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ConfirmedTransaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.ConfirmedTransaction";
                };

                return ConfirmedTransaction;
            })();

            ConfirmedBlock.Transaction = (function() {

                /**
                 * Properties of a Transaction.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface ITransaction
                 * @property {Array.<Uint8Array>|null} [signatures] Transaction signatures
                 * @property {solana.storage.ConfirmedBlock.IMessage|null} [message] Transaction message
                 */

                /**
                 * Constructs a new Transaction.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a Transaction.
                 * @implements ITransaction
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.ITransaction=} [properties] Properties to set
                 */
                function Transaction(properties) {
                    this.signatures = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Transaction signatures.
                 * @member {Array.<Uint8Array>} signatures
                 * @memberof solana.storage.ConfirmedBlock.Transaction
                 * @instance
                 */
                Transaction.prototype.signatures = $util.emptyArray;

                /**
                 * Transaction message.
                 * @member {solana.storage.ConfirmedBlock.IMessage|null|undefined} message
                 * @memberof solana.storage.ConfirmedBlock.Transaction
                 * @instance
                 */
                Transaction.prototype.message = null;

                /**
                 * Creates a new Transaction instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.Transaction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ITransaction=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.Transaction} Transaction instance
                 */
                Transaction.create = function create(properties) {
                    return new Transaction(properties);
                };

                /**
                 * Encodes the specified Transaction message. Does not implicitly {@link solana.storage.ConfirmedBlock.Transaction.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.Transaction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ITransaction} message Transaction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Transaction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.signatures != null && message.signatures.length)
                        for (var i = 0; i < message.signatures.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signatures[i]);
                    if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                        $root.solana.storage.ConfirmedBlock.Message.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Transaction message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.Transaction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.Transaction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ITransaction} message Transaction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Transaction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Transaction message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.Transaction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.Transaction} Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Transaction.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.Transaction();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.signatures && message.signatures.length))
                                    message.signatures = [];
                                message.signatures.push(reader.bytes());
                                break;
                            }
                        case 2: {
                                message.message = $root.solana.storage.ConfirmedBlock.Message.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Transaction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.Transaction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.Transaction} Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Transaction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Transaction message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.Transaction
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Transaction.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.signatures != null && message.hasOwnProperty("signatures")) {
                        if (!Array.isArray(message.signatures))
                            return "signatures: array expected";
                        for (var i = 0; i < message.signatures.length; ++i)
                            if (!(message.signatures[i] && typeof message.signatures[i].length === "number" || $util.isString(message.signatures[i])))
                                return "signatures: buffer[] expected";
                    }
                    if (message.message != null && message.hasOwnProperty("message")) {
                        var error = $root.solana.storage.ConfirmedBlock.Message.verify(message.message);
                        if (error)
                            return "message." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.Transaction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.Transaction} Transaction
                 */
                Transaction.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.Transaction)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.Transaction();
                    if (object.signatures) {
                        if (!Array.isArray(object.signatures))
                            throw TypeError(".solana.storage.ConfirmedBlock.Transaction.signatures: array expected");
                        message.signatures = [];
                        for (var i = 0; i < object.signatures.length; ++i)
                            if (typeof object.signatures[i] === "string")
                                $util.base64.decode(object.signatures[i], message.signatures[i] = $util.newBuffer($util.base64.length(object.signatures[i])), 0);
                            else if (object.signatures[i].length >= 0)
                                message.signatures[i] = object.signatures[i];
                    }
                    if (object.message != null) {
                        if (typeof object.message !== "object")
                            throw TypeError(".solana.storage.ConfirmedBlock.Transaction.message: object expected");
                        message.message = $root.solana.storage.ConfirmedBlock.Message.fromObject(object.message);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.Transaction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.Transaction} message Transaction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Transaction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.signatures = [];
                    if (options.defaults)
                        object.message = null;
                    if (message.signatures && message.signatures.length) {
                        object.signatures = [];
                        for (var j = 0; j < message.signatures.length; ++j)
                            object.signatures[j] = options.bytes === String ? $util.base64.encode(message.signatures[j], 0, message.signatures[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.signatures[j]) : message.signatures[j];
                    }
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = $root.solana.storage.ConfirmedBlock.Message.toObject(message.message, options);
                    return object;
                };

                /**
                 * Converts this Transaction to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.Transaction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Transaction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Transaction
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.Transaction
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Transaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.Transaction";
                };

                return Transaction;
            })();

            ConfirmedBlock.Message = (function() {

                /**
                 * Properties of a Message.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface IMessage
                 * @property {solana.storage.ConfirmedBlock.IMessageHeader|null} [header] Message header
                 * @property {Array.<Uint8Array>|null} [accountKeys] Message accountKeys
                 * @property {Uint8Array|null} [recentBlockhash] Message recentBlockhash
                 * @property {Array.<solana.storage.ConfirmedBlock.ICompiledInstruction>|null} [instructions] Message instructions
                 * @property {boolean|null} [versioned] Message versioned
                 * @property {Array.<solana.storage.ConfirmedBlock.IMessageAddressTableLookup>|null} [addressTableLookups] Message addressTableLookups
                 */

                /**
                 * Constructs a new Message.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a Message.
                 * @implements IMessage
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.IMessage=} [properties] Properties to set
                 */
                function Message(properties) {
                    this.accountKeys = [];
                    this.instructions = [];
                    this.addressTableLookups = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Message header.
                 * @member {solana.storage.ConfirmedBlock.IMessageHeader|null|undefined} header
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @instance
                 */
                Message.prototype.header = null;

                /**
                 * Message accountKeys.
                 * @member {Array.<Uint8Array>} accountKeys
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @instance
                 */
                Message.prototype.accountKeys = $util.emptyArray;

                /**
                 * Message recentBlockhash.
                 * @member {Uint8Array} recentBlockhash
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @instance
                 */
                Message.prototype.recentBlockhash = $util.newBuffer([]);

                /**
                 * Message instructions.
                 * @member {Array.<solana.storage.ConfirmedBlock.ICompiledInstruction>} instructions
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @instance
                 */
                Message.prototype.instructions = $util.emptyArray;

                /**
                 * Message versioned.
                 * @member {boolean} versioned
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @instance
                 */
                Message.prototype.versioned = false;

                /**
                 * Message addressTableLookups.
                 * @member {Array.<solana.storage.ConfirmedBlock.IMessageAddressTableLookup>} addressTableLookups
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @instance
                 */
                Message.prototype.addressTableLookups = $util.emptyArray;

                /**
                 * Creates a new Message instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IMessage=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.Message} Message instance
                 */
                Message.create = function create(properties) {
                    return new Message(properties);
                };

                /**
                 * Encodes the specified Message message. Does not implicitly {@link solana.storage.ConfirmedBlock.Message.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                        $root.solana.storage.ConfirmedBlock.MessageHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.accountKeys != null && message.accountKeys.length)
                        for (var i = 0; i < message.accountKeys.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.accountKeys[i]);
                    if (message.recentBlockhash != null && Object.hasOwnProperty.call(message, "recentBlockhash"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.recentBlockhash);
                    if (message.instructions != null && message.instructions.length)
                        for (var i = 0; i < message.instructions.length; ++i)
                            $root.solana.storage.ConfirmedBlock.CompiledInstruction.encode(message.instructions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.versioned != null && Object.hasOwnProperty.call(message, "versioned"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.versioned);
                    if (message.addressTableLookups != null && message.addressTableLookups.length)
                        for (var i = 0; i < message.addressTableLookups.length; ++i)
                            $root.solana.storage.ConfirmedBlock.MessageAddressTableLookup.encode(message.addressTableLookups[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Message message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.Message.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Message message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.Message();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.header = $root.solana.storage.ConfirmedBlock.MessageHeader.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                if (!(message.accountKeys && message.accountKeys.length))
                                    message.accountKeys = [];
                                message.accountKeys.push(reader.bytes());
                                break;
                            }
                        case 3: {
                                message.recentBlockhash = reader.bytes();
                                break;
                            }
                        case 4: {
                                if (!(message.instructions && message.instructions.length))
                                    message.instructions = [];
                                message.instructions.push($root.solana.storage.ConfirmedBlock.CompiledInstruction.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                message.versioned = reader.bool();
                                break;
                            }
                        case 6: {
                                if (!(message.addressTableLookups && message.addressTableLookups.length))
                                    message.addressTableLookups = [];
                                message.addressTableLookups.push($root.solana.storage.ConfirmedBlock.MessageAddressTableLookup.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Message message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Message message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Message.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.header != null && message.hasOwnProperty("header")) {
                        var error = $root.solana.storage.ConfirmedBlock.MessageHeader.verify(message.header);
                        if (error)
                            return "header." + error;
                    }
                    if (message.accountKeys != null && message.hasOwnProperty("accountKeys")) {
                        if (!Array.isArray(message.accountKeys))
                            return "accountKeys: array expected";
                        for (var i = 0; i < message.accountKeys.length; ++i)
                            if (!(message.accountKeys[i] && typeof message.accountKeys[i].length === "number" || $util.isString(message.accountKeys[i])))
                                return "accountKeys: buffer[] expected";
                    }
                    if (message.recentBlockhash != null && message.hasOwnProperty("recentBlockhash"))
                        if (!(message.recentBlockhash && typeof message.recentBlockhash.length === "number" || $util.isString(message.recentBlockhash)))
                            return "recentBlockhash: buffer expected";
                    if (message.instructions != null && message.hasOwnProperty("instructions")) {
                        if (!Array.isArray(message.instructions))
                            return "instructions: array expected";
                        for (var i = 0; i < message.instructions.length; ++i) {
                            var error = $root.solana.storage.ConfirmedBlock.CompiledInstruction.verify(message.instructions[i]);
                            if (error)
                                return "instructions." + error;
                        }
                    }
                    if (message.versioned != null && message.hasOwnProperty("versioned"))
                        if (typeof message.versioned !== "boolean")
                            return "versioned: boolean expected";
                    if (message.addressTableLookups != null && message.hasOwnProperty("addressTableLookups")) {
                        if (!Array.isArray(message.addressTableLookups))
                            return "addressTableLookups: array expected";
                        for (var i = 0; i < message.addressTableLookups.length; ++i) {
                            var error = $root.solana.storage.ConfirmedBlock.MessageAddressTableLookup.verify(message.addressTableLookups[i]);
                            if (error)
                                return "addressTableLookups." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Message message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.Message} Message
                 */
                Message.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.Message)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.Message();
                    if (object.header != null) {
                        if (typeof object.header !== "object")
                            throw TypeError(".solana.storage.ConfirmedBlock.Message.header: object expected");
                        message.header = $root.solana.storage.ConfirmedBlock.MessageHeader.fromObject(object.header);
                    }
                    if (object.accountKeys) {
                        if (!Array.isArray(object.accountKeys))
                            throw TypeError(".solana.storage.ConfirmedBlock.Message.accountKeys: array expected");
                        message.accountKeys = [];
                        for (var i = 0; i < object.accountKeys.length; ++i)
                            if (typeof object.accountKeys[i] === "string")
                                $util.base64.decode(object.accountKeys[i], message.accountKeys[i] = $util.newBuffer($util.base64.length(object.accountKeys[i])), 0);
                            else if (object.accountKeys[i].length >= 0)
                                message.accountKeys[i] = object.accountKeys[i];
                    }
                    if (object.recentBlockhash != null)
                        if (typeof object.recentBlockhash === "string")
                            $util.base64.decode(object.recentBlockhash, message.recentBlockhash = $util.newBuffer($util.base64.length(object.recentBlockhash)), 0);
                        else if (object.recentBlockhash.length >= 0)
                            message.recentBlockhash = object.recentBlockhash;
                    if (object.instructions) {
                        if (!Array.isArray(object.instructions))
                            throw TypeError(".solana.storage.ConfirmedBlock.Message.instructions: array expected");
                        message.instructions = [];
                        for (var i = 0; i < object.instructions.length; ++i) {
                            if (typeof object.instructions[i] !== "object")
                                throw TypeError(".solana.storage.ConfirmedBlock.Message.instructions: object expected");
                            message.instructions[i] = $root.solana.storage.ConfirmedBlock.CompiledInstruction.fromObject(object.instructions[i]);
                        }
                    }
                    if (object.versioned != null)
                        message.versioned = Boolean(object.versioned);
                    if (object.addressTableLookups) {
                        if (!Array.isArray(object.addressTableLookups))
                            throw TypeError(".solana.storage.ConfirmedBlock.Message.addressTableLookups: array expected");
                        message.addressTableLookups = [];
                        for (var i = 0; i < object.addressTableLookups.length; ++i) {
                            if (typeof object.addressTableLookups[i] !== "object")
                                throw TypeError(".solana.storage.ConfirmedBlock.Message.addressTableLookups: object expected");
                            message.addressTableLookups[i] = $root.solana.storage.ConfirmedBlock.MessageAddressTableLookup.fromObject(object.addressTableLookups[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Message message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @static
                 * @param {solana.storage.ConfirmedBlock.Message} message Message
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Message.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.accountKeys = [];
                        object.instructions = [];
                        object.addressTableLookups = [];
                    }
                    if (options.defaults) {
                        object.header = null;
                        if (options.bytes === String)
                            object.recentBlockhash = "";
                        else {
                            object.recentBlockhash = [];
                            if (options.bytes !== Array)
                                object.recentBlockhash = $util.newBuffer(object.recentBlockhash);
                        }
                        object.versioned = false;
                    }
                    if (message.header != null && message.hasOwnProperty("header"))
                        object.header = $root.solana.storage.ConfirmedBlock.MessageHeader.toObject(message.header, options);
                    if (message.accountKeys && message.accountKeys.length) {
                        object.accountKeys = [];
                        for (var j = 0; j < message.accountKeys.length; ++j)
                            object.accountKeys[j] = options.bytes === String ? $util.base64.encode(message.accountKeys[j], 0, message.accountKeys[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.accountKeys[j]) : message.accountKeys[j];
                    }
                    if (message.recentBlockhash != null && message.hasOwnProperty("recentBlockhash"))
                        object.recentBlockhash = options.bytes === String ? $util.base64.encode(message.recentBlockhash, 0, message.recentBlockhash.length) : options.bytes === Array ? Array.prototype.slice.call(message.recentBlockhash) : message.recentBlockhash;
                    if (message.instructions && message.instructions.length) {
                        object.instructions = [];
                        for (var j = 0; j < message.instructions.length; ++j)
                            object.instructions[j] = $root.solana.storage.ConfirmedBlock.CompiledInstruction.toObject(message.instructions[j], options);
                    }
                    if (message.versioned != null && message.hasOwnProperty("versioned"))
                        object.versioned = message.versioned;
                    if (message.addressTableLookups && message.addressTableLookups.length) {
                        object.addressTableLookups = [];
                        for (var j = 0; j < message.addressTableLookups.length; ++j)
                            object.addressTableLookups[j] = $root.solana.storage.ConfirmedBlock.MessageAddressTableLookup.toObject(message.addressTableLookups[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Message to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Message.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Message
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.Message
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Message.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.Message";
                };

                return Message;
            })();

            ConfirmedBlock.MessageHeader = (function() {

                /**
                 * Properties of a MessageHeader.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface IMessageHeader
                 * @property {number|null} [numRequiredSignatures] MessageHeader numRequiredSignatures
                 * @property {number|null} [numReadonlySignedAccounts] MessageHeader numReadonlySignedAccounts
                 * @property {number|null} [numReadonlyUnsignedAccounts] MessageHeader numReadonlyUnsignedAccounts
                 */

                /**
                 * Constructs a new MessageHeader.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a MessageHeader.
                 * @implements IMessageHeader
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.IMessageHeader=} [properties] Properties to set
                 */
                function MessageHeader(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageHeader numRequiredSignatures.
                 * @member {number} numRequiredSignatures
                 * @memberof solana.storage.ConfirmedBlock.MessageHeader
                 * @instance
                 */
                MessageHeader.prototype.numRequiredSignatures = 0;

                /**
                 * MessageHeader numReadonlySignedAccounts.
                 * @member {number} numReadonlySignedAccounts
                 * @memberof solana.storage.ConfirmedBlock.MessageHeader
                 * @instance
                 */
                MessageHeader.prototype.numReadonlySignedAccounts = 0;

                /**
                 * MessageHeader numReadonlyUnsignedAccounts.
                 * @member {number} numReadonlyUnsignedAccounts
                 * @memberof solana.storage.ConfirmedBlock.MessageHeader
                 * @instance
                 */
                MessageHeader.prototype.numReadonlyUnsignedAccounts = 0;

                /**
                 * Creates a new MessageHeader instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.MessageHeader
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IMessageHeader=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.MessageHeader} MessageHeader instance
                 */
                MessageHeader.create = function create(properties) {
                    return new MessageHeader(properties);
                };

                /**
                 * Encodes the specified MessageHeader message. Does not implicitly {@link solana.storage.ConfirmedBlock.MessageHeader.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.MessageHeader
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IMessageHeader} message MessageHeader message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageHeader.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.numRequiredSignatures != null && Object.hasOwnProperty.call(message, "numRequiredSignatures"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.numRequiredSignatures);
                    if (message.numReadonlySignedAccounts != null && Object.hasOwnProperty.call(message, "numReadonlySignedAccounts"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.numReadonlySignedAccounts);
                    if (message.numReadonlyUnsignedAccounts != null && Object.hasOwnProperty.call(message, "numReadonlyUnsignedAccounts"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.numReadonlyUnsignedAccounts);
                    return writer;
                };

                /**
                 * Encodes the specified MessageHeader message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.MessageHeader.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.MessageHeader
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IMessageHeader} message MessageHeader message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageHeader.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageHeader message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.MessageHeader
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.MessageHeader} MessageHeader
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageHeader.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.MessageHeader();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.numRequiredSignatures = reader.uint32();
                                break;
                            }
                        case 2: {
                                message.numReadonlySignedAccounts = reader.uint32();
                                break;
                            }
                        case 3: {
                                message.numReadonlyUnsignedAccounts = reader.uint32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageHeader message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.MessageHeader
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.MessageHeader} MessageHeader
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageHeader.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageHeader message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.MessageHeader
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageHeader.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.numRequiredSignatures != null && message.hasOwnProperty("numRequiredSignatures"))
                        if (!$util.isInteger(message.numRequiredSignatures))
                            return "numRequiredSignatures: integer expected";
                    if (message.numReadonlySignedAccounts != null && message.hasOwnProperty("numReadonlySignedAccounts"))
                        if (!$util.isInteger(message.numReadonlySignedAccounts))
                            return "numReadonlySignedAccounts: integer expected";
                    if (message.numReadonlyUnsignedAccounts != null && message.hasOwnProperty("numReadonlyUnsignedAccounts"))
                        if (!$util.isInteger(message.numReadonlyUnsignedAccounts))
                            return "numReadonlyUnsignedAccounts: integer expected";
                    return null;
                };

                /**
                 * Creates a MessageHeader message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.MessageHeader
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.MessageHeader} MessageHeader
                 */
                MessageHeader.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.MessageHeader)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.MessageHeader();
                    if (object.numRequiredSignatures != null)
                        message.numRequiredSignatures = object.numRequiredSignatures >>> 0;
                    if (object.numReadonlySignedAccounts != null)
                        message.numReadonlySignedAccounts = object.numReadonlySignedAccounts >>> 0;
                    if (object.numReadonlyUnsignedAccounts != null)
                        message.numReadonlyUnsignedAccounts = object.numReadonlyUnsignedAccounts >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a MessageHeader message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.MessageHeader
                 * @static
                 * @param {solana.storage.ConfirmedBlock.MessageHeader} message MessageHeader
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageHeader.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.numRequiredSignatures = 0;
                        object.numReadonlySignedAccounts = 0;
                        object.numReadonlyUnsignedAccounts = 0;
                    }
                    if (message.numRequiredSignatures != null && message.hasOwnProperty("numRequiredSignatures"))
                        object.numRequiredSignatures = message.numRequiredSignatures;
                    if (message.numReadonlySignedAccounts != null && message.hasOwnProperty("numReadonlySignedAccounts"))
                        object.numReadonlySignedAccounts = message.numReadonlySignedAccounts;
                    if (message.numReadonlyUnsignedAccounts != null && message.hasOwnProperty("numReadonlyUnsignedAccounts"))
                        object.numReadonlyUnsignedAccounts = message.numReadonlyUnsignedAccounts;
                    return object;
                };

                /**
                 * Converts this MessageHeader to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.MessageHeader
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageHeader.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageHeader
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.MessageHeader
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageHeader.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.MessageHeader";
                };

                return MessageHeader;
            })();

            ConfirmedBlock.MessageAddressTableLookup = (function() {

                /**
                 * Properties of a MessageAddressTableLookup.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface IMessageAddressTableLookup
                 * @property {Uint8Array|null} [accountKey] MessageAddressTableLookup accountKey
                 * @property {Uint8Array|null} [writableIndexes] MessageAddressTableLookup writableIndexes
                 * @property {Uint8Array|null} [readonlyIndexes] MessageAddressTableLookup readonlyIndexes
                 */

                /**
                 * Constructs a new MessageAddressTableLookup.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a MessageAddressTableLookup.
                 * @implements IMessageAddressTableLookup
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.IMessageAddressTableLookup=} [properties] Properties to set
                 */
                function MessageAddressTableLookup(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageAddressTableLookup accountKey.
                 * @member {Uint8Array} accountKey
                 * @memberof solana.storage.ConfirmedBlock.MessageAddressTableLookup
                 * @instance
                 */
                MessageAddressTableLookup.prototype.accountKey = $util.newBuffer([]);

                /**
                 * MessageAddressTableLookup writableIndexes.
                 * @member {Uint8Array} writableIndexes
                 * @memberof solana.storage.ConfirmedBlock.MessageAddressTableLookup
                 * @instance
                 */
                MessageAddressTableLookup.prototype.writableIndexes = $util.newBuffer([]);

                /**
                 * MessageAddressTableLookup readonlyIndexes.
                 * @member {Uint8Array} readonlyIndexes
                 * @memberof solana.storage.ConfirmedBlock.MessageAddressTableLookup
                 * @instance
                 */
                MessageAddressTableLookup.prototype.readonlyIndexes = $util.newBuffer([]);

                /**
                 * Creates a new MessageAddressTableLookup instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.MessageAddressTableLookup
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IMessageAddressTableLookup=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.MessageAddressTableLookup} MessageAddressTableLookup instance
                 */
                MessageAddressTableLookup.create = function create(properties) {
                    return new MessageAddressTableLookup(properties);
                };

                /**
                 * Encodes the specified MessageAddressTableLookup message. Does not implicitly {@link solana.storage.ConfirmedBlock.MessageAddressTableLookup.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.MessageAddressTableLookup
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IMessageAddressTableLookup} message MessageAddressTableLookup message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageAddressTableLookup.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.accountKey != null && Object.hasOwnProperty.call(message, "accountKey"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accountKey);
                    if (message.writableIndexes != null && Object.hasOwnProperty.call(message, "writableIndexes"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.writableIndexes);
                    if (message.readonlyIndexes != null && Object.hasOwnProperty.call(message, "readonlyIndexes"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.readonlyIndexes);
                    return writer;
                };

                /**
                 * Encodes the specified MessageAddressTableLookup message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.MessageAddressTableLookup.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.MessageAddressTableLookup
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IMessageAddressTableLookup} message MessageAddressTableLookup message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageAddressTableLookup.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageAddressTableLookup message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.MessageAddressTableLookup
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.MessageAddressTableLookup} MessageAddressTableLookup
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageAddressTableLookup.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.MessageAddressTableLookup();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.accountKey = reader.bytes();
                                break;
                            }
                        case 2: {
                                message.writableIndexes = reader.bytes();
                                break;
                            }
                        case 3: {
                                message.readonlyIndexes = reader.bytes();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageAddressTableLookup message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.MessageAddressTableLookup
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.MessageAddressTableLookup} MessageAddressTableLookup
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageAddressTableLookup.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageAddressTableLookup message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.MessageAddressTableLookup
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageAddressTableLookup.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.accountKey != null && message.hasOwnProperty("accountKey"))
                        if (!(message.accountKey && typeof message.accountKey.length === "number" || $util.isString(message.accountKey)))
                            return "accountKey: buffer expected";
                    if (message.writableIndexes != null && message.hasOwnProperty("writableIndexes"))
                        if (!(message.writableIndexes && typeof message.writableIndexes.length === "number" || $util.isString(message.writableIndexes)))
                            return "writableIndexes: buffer expected";
                    if (message.readonlyIndexes != null && message.hasOwnProperty("readonlyIndexes"))
                        if (!(message.readonlyIndexes && typeof message.readonlyIndexes.length === "number" || $util.isString(message.readonlyIndexes)))
                            return "readonlyIndexes: buffer expected";
                    return null;
                };

                /**
                 * Creates a MessageAddressTableLookup message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.MessageAddressTableLookup
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.MessageAddressTableLookup} MessageAddressTableLookup
                 */
                MessageAddressTableLookup.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.MessageAddressTableLookup)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.MessageAddressTableLookup();
                    if (object.accountKey != null)
                        if (typeof object.accountKey === "string")
                            $util.base64.decode(object.accountKey, message.accountKey = $util.newBuffer($util.base64.length(object.accountKey)), 0);
                        else if (object.accountKey.length >= 0)
                            message.accountKey = object.accountKey;
                    if (object.writableIndexes != null)
                        if (typeof object.writableIndexes === "string")
                            $util.base64.decode(object.writableIndexes, message.writableIndexes = $util.newBuffer($util.base64.length(object.writableIndexes)), 0);
                        else if (object.writableIndexes.length >= 0)
                            message.writableIndexes = object.writableIndexes;
                    if (object.readonlyIndexes != null)
                        if (typeof object.readonlyIndexes === "string")
                            $util.base64.decode(object.readonlyIndexes, message.readonlyIndexes = $util.newBuffer($util.base64.length(object.readonlyIndexes)), 0);
                        else if (object.readonlyIndexes.length >= 0)
                            message.readonlyIndexes = object.readonlyIndexes;
                    return message;
                };

                /**
                 * Creates a plain object from a MessageAddressTableLookup message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.MessageAddressTableLookup
                 * @static
                 * @param {solana.storage.ConfirmedBlock.MessageAddressTableLookup} message MessageAddressTableLookup
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageAddressTableLookup.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.accountKey = "";
                        else {
                            object.accountKey = [];
                            if (options.bytes !== Array)
                                object.accountKey = $util.newBuffer(object.accountKey);
                        }
                        if (options.bytes === String)
                            object.writableIndexes = "";
                        else {
                            object.writableIndexes = [];
                            if (options.bytes !== Array)
                                object.writableIndexes = $util.newBuffer(object.writableIndexes);
                        }
                        if (options.bytes === String)
                            object.readonlyIndexes = "";
                        else {
                            object.readonlyIndexes = [];
                            if (options.bytes !== Array)
                                object.readonlyIndexes = $util.newBuffer(object.readonlyIndexes);
                        }
                    }
                    if (message.accountKey != null && message.hasOwnProperty("accountKey"))
                        object.accountKey = options.bytes === String ? $util.base64.encode(message.accountKey, 0, message.accountKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountKey) : message.accountKey;
                    if (message.writableIndexes != null && message.hasOwnProperty("writableIndexes"))
                        object.writableIndexes = options.bytes === String ? $util.base64.encode(message.writableIndexes, 0, message.writableIndexes.length) : options.bytes === Array ? Array.prototype.slice.call(message.writableIndexes) : message.writableIndexes;
                    if (message.readonlyIndexes != null && message.hasOwnProperty("readonlyIndexes"))
                        object.readonlyIndexes = options.bytes === String ? $util.base64.encode(message.readonlyIndexes, 0, message.readonlyIndexes.length) : options.bytes === Array ? Array.prototype.slice.call(message.readonlyIndexes) : message.readonlyIndexes;
                    return object;
                };

                /**
                 * Converts this MessageAddressTableLookup to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.MessageAddressTableLookup
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageAddressTableLookup.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for MessageAddressTableLookup
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.MessageAddressTableLookup
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                MessageAddressTableLookup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.MessageAddressTableLookup";
                };

                return MessageAddressTableLookup;
            })();

            ConfirmedBlock.TransactionStatusMeta = (function() {

                /**
                 * Properties of a TransactionStatusMeta.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface ITransactionStatusMeta
                 * @property {solana.storage.ConfirmedBlock.ITransactionError|null} [err] TransactionStatusMeta err
                 * @property {number|Long|null} [fee] TransactionStatusMeta fee
                 * @property {Array.<number|Long>|null} [preBalances] TransactionStatusMeta preBalances
                 * @property {Array.<number|Long>|null} [postBalances] TransactionStatusMeta postBalances
                 * @property {Array.<solana.storage.ConfirmedBlock.IInnerInstructions>|null} [innerInstructions] TransactionStatusMeta innerInstructions
                 * @property {boolean|null} [innerInstructionsNone] TransactionStatusMeta innerInstructionsNone
                 * @property {Array.<string>|null} [logMessages] TransactionStatusMeta logMessages
                 * @property {boolean|null} [logMessagesNone] TransactionStatusMeta logMessagesNone
                 * @property {Array.<solana.storage.ConfirmedBlock.ITokenBalance>|null} [preTokenBalances] TransactionStatusMeta preTokenBalances
                 * @property {Array.<solana.storage.ConfirmedBlock.ITokenBalance>|null} [postTokenBalances] TransactionStatusMeta postTokenBalances
                 * @property {Array.<solana.storage.ConfirmedBlock.IReward>|null} [rewards] TransactionStatusMeta rewards
                 * @property {Array.<Uint8Array>|null} [loadedWritableAddresses] TransactionStatusMeta loadedWritableAddresses
                 * @property {Array.<Uint8Array>|null} [loadedReadonlyAddresses] TransactionStatusMeta loadedReadonlyAddresses
                 * @property {solana.storage.ConfirmedBlock.IReturnData|null} [returnData] TransactionStatusMeta returnData
                 * @property {boolean|null} [returnDataNone] TransactionStatusMeta returnDataNone
                 * @property {number|Long|null} [computeUnitsConsumed] TransactionStatusMeta computeUnitsConsumed
                 * @property {number|Long|null} [costUnits] TransactionStatusMeta costUnits
                 */

                /**
                 * Constructs a new TransactionStatusMeta.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a TransactionStatusMeta.
                 * @implements ITransactionStatusMeta
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.ITransactionStatusMeta=} [properties] Properties to set
                 */
                function TransactionStatusMeta(properties) {
                    this.preBalances = [];
                    this.postBalances = [];
                    this.innerInstructions = [];
                    this.logMessages = [];
                    this.preTokenBalances = [];
                    this.postTokenBalances = [];
                    this.rewards = [];
                    this.loadedWritableAddresses = [];
                    this.loadedReadonlyAddresses = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TransactionStatusMeta err.
                 * @member {solana.storage.ConfirmedBlock.ITransactionError|null|undefined} err
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.err = null;

                /**
                 * TransactionStatusMeta fee.
                 * @member {number|Long} fee
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * TransactionStatusMeta preBalances.
                 * @member {Array.<number|Long>} preBalances
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.preBalances = $util.emptyArray;

                /**
                 * TransactionStatusMeta postBalances.
                 * @member {Array.<number|Long>} postBalances
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.postBalances = $util.emptyArray;

                /**
                 * TransactionStatusMeta innerInstructions.
                 * @member {Array.<solana.storage.ConfirmedBlock.IInnerInstructions>} innerInstructions
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.innerInstructions = $util.emptyArray;

                /**
                 * TransactionStatusMeta innerInstructionsNone.
                 * @member {boolean} innerInstructionsNone
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.innerInstructionsNone = false;

                /**
                 * TransactionStatusMeta logMessages.
                 * @member {Array.<string>} logMessages
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.logMessages = $util.emptyArray;

                /**
                 * TransactionStatusMeta logMessagesNone.
                 * @member {boolean} logMessagesNone
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.logMessagesNone = false;

                /**
                 * TransactionStatusMeta preTokenBalances.
                 * @member {Array.<solana.storage.ConfirmedBlock.ITokenBalance>} preTokenBalances
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.preTokenBalances = $util.emptyArray;

                /**
                 * TransactionStatusMeta postTokenBalances.
                 * @member {Array.<solana.storage.ConfirmedBlock.ITokenBalance>} postTokenBalances
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.postTokenBalances = $util.emptyArray;

                /**
                 * TransactionStatusMeta rewards.
                 * @member {Array.<solana.storage.ConfirmedBlock.IReward>} rewards
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.rewards = $util.emptyArray;

                /**
                 * TransactionStatusMeta loadedWritableAddresses.
                 * @member {Array.<Uint8Array>} loadedWritableAddresses
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.loadedWritableAddresses = $util.emptyArray;

                /**
                 * TransactionStatusMeta loadedReadonlyAddresses.
                 * @member {Array.<Uint8Array>} loadedReadonlyAddresses
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.loadedReadonlyAddresses = $util.emptyArray;

                /**
                 * TransactionStatusMeta returnData.
                 * @member {solana.storage.ConfirmedBlock.IReturnData|null|undefined} returnData
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.returnData = null;

                /**
                 * TransactionStatusMeta returnDataNone.
                 * @member {boolean} returnDataNone
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.returnDataNone = false;

                /**
                 * TransactionStatusMeta computeUnitsConsumed.
                 * @member {number|Long|null|undefined} computeUnitsConsumed
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.computeUnitsConsumed = null;

                /**
                 * TransactionStatusMeta costUnits.
                 * @member {number|Long|null|undefined} costUnits
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                TransactionStatusMeta.prototype.costUnits = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * TransactionStatusMeta _computeUnitsConsumed.
                 * @member {"computeUnitsConsumed"|undefined} _computeUnitsConsumed
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                Object.defineProperty(TransactionStatusMeta.prototype, "_computeUnitsConsumed", {
                    get: $util.oneOfGetter($oneOfFields = ["computeUnitsConsumed"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * TransactionStatusMeta _costUnits.
                 * @member {"costUnits"|undefined} _costUnits
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 */
                Object.defineProperty(TransactionStatusMeta.prototype, "_costUnits", {
                    get: $util.oneOfGetter($oneOfFields = ["costUnits"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new TransactionStatusMeta instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ITransactionStatusMeta=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.TransactionStatusMeta} TransactionStatusMeta instance
                 */
                TransactionStatusMeta.create = function create(properties) {
                    return new TransactionStatusMeta(properties);
                };

                /**
                 * Encodes the specified TransactionStatusMeta message. Does not implicitly {@link solana.storage.ConfirmedBlock.TransactionStatusMeta.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ITransactionStatusMeta} message TransactionStatusMeta message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionStatusMeta.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                        $root.solana.storage.ConfirmedBlock.TransactionError.encode(message.err, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.fee);
                    if (message.preBalances != null && message.preBalances.length) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork();
                        for (var i = 0; i < message.preBalances.length; ++i)
                            writer.uint64(message.preBalances[i]);
                        writer.ldelim();
                    }
                    if (message.postBalances != null && message.postBalances.length) {
                        writer.uint32(/* id 4, wireType 2 =*/34).fork();
                        for (var i = 0; i < message.postBalances.length; ++i)
                            writer.uint64(message.postBalances[i]);
                        writer.ldelim();
                    }
                    if (message.innerInstructions != null && message.innerInstructions.length)
                        for (var i = 0; i < message.innerInstructions.length; ++i)
                            $root.solana.storage.ConfirmedBlock.InnerInstructions.encode(message.innerInstructions[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.logMessages != null && message.logMessages.length)
                        for (var i = 0; i < message.logMessages.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.logMessages[i]);
                    if (message.preTokenBalances != null && message.preTokenBalances.length)
                        for (var i = 0; i < message.preTokenBalances.length; ++i)
                            $root.solana.storage.ConfirmedBlock.TokenBalance.encode(message.preTokenBalances[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.postTokenBalances != null && message.postTokenBalances.length)
                        for (var i = 0; i < message.postTokenBalances.length; ++i)
                            $root.solana.storage.ConfirmedBlock.TokenBalance.encode(message.postTokenBalances[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.rewards != null && message.rewards.length)
                        for (var i = 0; i < message.rewards.length; ++i)
                            $root.solana.storage.ConfirmedBlock.Reward.encode(message.rewards[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.innerInstructionsNone != null && Object.hasOwnProperty.call(message, "innerInstructionsNone"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.innerInstructionsNone);
                    if (message.logMessagesNone != null && Object.hasOwnProperty.call(message, "logMessagesNone"))
                        writer.uint32(/* id 11, wireType 0 =*/88).bool(message.logMessagesNone);
                    if (message.loadedWritableAddresses != null && message.loadedWritableAddresses.length)
                        for (var i = 0; i < message.loadedWritableAddresses.length; ++i)
                            writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.loadedWritableAddresses[i]);
                    if (message.loadedReadonlyAddresses != null && message.loadedReadonlyAddresses.length)
                        for (var i = 0; i < message.loadedReadonlyAddresses.length; ++i)
                            writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.loadedReadonlyAddresses[i]);
                    if (message.returnData != null && Object.hasOwnProperty.call(message, "returnData"))
                        $root.solana.storage.ConfirmedBlock.ReturnData.encode(message.returnData, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.returnDataNone != null && Object.hasOwnProperty.call(message, "returnDataNone"))
                        writer.uint32(/* id 15, wireType 0 =*/120).bool(message.returnDataNone);
                    if (message.computeUnitsConsumed != null && Object.hasOwnProperty.call(message, "computeUnitsConsumed"))
                        writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.computeUnitsConsumed);
                    if (message.costUnits != null && Object.hasOwnProperty.call(message, "costUnits"))
                        writer.uint32(/* id 17, wireType 0 =*/136).uint64(message.costUnits);
                    return writer;
                };

                /**
                 * Encodes the specified TransactionStatusMeta message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.TransactionStatusMeta.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ITransactionStatusMeta} message TransactionStatusMeta message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionStatusMeta.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TransactionStatusMeta message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.TransactionStatusMeta} TransactionStatusMeta
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionStatusMeta.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.TransactionStatusMeta();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.err = $root.solana.storage.ConfirmedBlock.TransactionError.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.fee = reader.uint64();
                                break;
                            }
                        case 3: {
                                if (!(message.preBalances && message.preBalances.length))
                                    message.preBalances = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.preBalances.push(reader.uint64());
                                } else
                                    message.preBalances.push(reader.uint64());
                                break;
                            }
                        case 4: {
                                if (!(message.postBalances && message.postBalances.length))
                                    message.postBalances = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.postBalances.push(reader.uint64());
                                } else
                                    message.postBalances.push(reader.uint64());
                                break;
                            }
                        case 5: {
                                if (!(message.innerInstructions && message.innerInstructions.length))
                                    message.innerInstructions = [];
                                message.innerInstructions.push($root.solana.storage.ConfirmedBlock.InnerInstructions.decode(reader, reader.uint32()));
                                break;
                            }
                        case 10: {
                                message.innerInstructionsNone = reader.bool();
                                break;
                            }
                        case 6: {
                                if (!(message.logMessages && message.logMessages.length))
                                    message.logMessages = [];
                                message.logMessages.push(reader.string());
                                break;
                            }
                        case 11: {
                                message.logMessagesNone = reader.bool();
                                break;
                            }
                        case 7: {
                                if (!(message.preTokenBalances && message.preTokenBalances.length))
                                    message.preTokenBalances = [];
                                message.preTokenBalances.push($root.solana.storage.ConfirmedBlock.TokenBalance.decode(reader, reader.uint32()));
                                break;
                            }
                        case 8: {
                                if (!(message.postTokenBalances && message.postTokenBalances.length))
                                    message.postTokenBalances = [];
                                message.postTokenBalances.push($root.solana.storage.ConfirmedBlock.TokenBalance.decode(reader, reader.uint32()));
                                break;
                            }
                        case 9: {
                                if (!(message.rewards && message.rewards.length))
                                    message.rewards = [];
                                message.rewards.push($root.solana.storage.ConfirmedBlock.Reward.decode(reader, reader.uint32()));
                                break;
                            }
                        case 12: {
                                if (!(message.loadedWritableAddresses && message.loadedWritableAddresses.length))
                                    message.loadedWritableAddresses = [];
                                message.loadedWritableAddresses.push(reader.bytes());
                                break;
                            }
                        case 13: {
                                if (!(message.loadedReadonlyAddresses && message.loadedReadonlyAddresses.length))
                                    message.loadedReadonlyAddresses = [];
                                message.loadedReadonlyAddresses.push(reader.bytes());
                                break;
                            }
                        case 14: {
                                message.returnData = $root.solana.storage.ConfirmedBlock.ReturnData.decode(reader, reader.uint32());
                                break;
                            }
                        case 15: {
                                message.returnDataNone = reader.bool();
                                break;
                            }
                        case 16: {
                                message.computeUnitsConsumed = reader.uint64();
                                break;
                            }
                        case 17: {
                                message.costUnits = reader.uint64();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TransactionStatusMeta message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.TransactionStatusMeta} TransactionStatusMeta
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionStatusMeta.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TransactionStatusMeta message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TransactionStatusMeta.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.err != null && message.hasOwnProperty("err")) {
                        var error = $root.solana.storage.ConfirmedBlock.TransactionError.verify(message.err);
                        if (error)
                            return "err." + error;
                    }
                    if (message.fee != null && message.hasOwnProperty("fee"))
                        if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                            return "fee: integer|Long expected";
                    if (message.preBalances != null && message.hasOwnProperty("preBalances")) {
                        if (!Array.isArray(message.preBalances))
                            return "preBalances: array expected";
                        for (var i = 0; i < message.preBalances.length; ++i)
                            if (!$util.isInteger(message.preBalances[i]) && !(message.preBalances[i] && $util.isInteger(message.preBalances[i].low) && $util.isInteger(message.preBalances[i].high)))
                                return "preBalances: integer|Long[] expected";
                    }
                    if (message.postBalances != null && message.hasOwnProperty("postBalances")) {
                        if (!Array.isArray(message.postBalances))
                            return "postBalances: array expected";
                        for (var i = 0; i < message.postBalances.length; ++i)
                            if (!$util.isInteger(message.postBalances[i]) && !(message.postBalances[i] && $util.isInteger(message.postBalances[i].low) && $util.isInteger(message.postBalances[i].high)))
                                return "postBalances: integer|Long[] expected";
                    }
                    if (message.innerInstructions != null && message.hasOwnProperty("innerInstructions")) {
                        if (!Array.isArray(message.innerInstructions))
                            return "innerInstructions: array expected";
                        for (var i = 0; i < message.innerInstructions.length; ++i) {
                            var error = $root.solana.storage.ConfirmedBlock.InnerInstructions.verify(message.innerInstructions[i]);
                            if (error)
                                return "innerInstructions." + error;
                        }
                    }
                    if (message.innerInstructionsNone != null && message.hasOwnProperty("innerInstructionsNone"))
                        if (typeof message.innerInstructionsNone !== "boolean")
                            return "innerInstructionsNone: boolean expected";
                    if (message.logMessages != null && message.hasOwnProperty("logMessages")) {
                        if (!Array.isArray(message.logMessages))
                            return "logMessages: array expected";
                        for (var i = 0; i < message.logMessages.length; ++i)
                            if (!$util.isString(message.logMessages[i]))
                                return "logMessages: string[] expected";
                    }
                    if (message.logMessagesNone != null && message.hasOwnProperty("logMessagesNone"))
                        if (typeof message.logMessagesNone !== "boolean")
                            return "logMessagesNone: boolean expected";
                    if (message.preTokenBalances != null && message.hasOwnProperty("preTokenBalances")) {
                        if (!Array.isArray(message.preTokenBalances))
                            return "preTokenBalances: array expected";
                        for (var i = 0; i < message.preTokenBalances.length; ++i) {
                            var error = $root.solana.storage.ConfirmedBlock.TokenBalance.verify(message.preTokenBalances[i]);
                            if (error)
                                return "preTokenBalances." + error;
                        }
                    }
                    if (message.postTokenBalances != null && message.hasOwnProperty("postTokenBalances")) {
                        if (!Array.isArray(message.postTokenBalances))
                            return "postTokenBalances: array expected";
                        for (var i = 0; i < message.postTokenBalances.length; ++i) {
                            var error = $root.solana.storage.ConfirmedBlock.TokenBalance.verify(message.postTokenBalances[i]);
                            if (error)
                                return "postTokenBalances." + error;
                        }
                    }
                    if (message.rewards != null && message.hasOwnProperty("rewards")) {
                        if (!Array.isArray(message.rewards))
                            return "rewards: array expected";
                        for (var i = 0; i < message.rewards.length; ++i) {
                            var error = $root.solana.storage.ConfirmedBlock.Reward.verify(message.rewards[i]);
                            if (error)
                                return "rewards." + error;
                        }
                    }
                    if (message.loadedWritableAddresses != null && message.hasOwnProperty("loadedWritableAddresses")) {
                        if (!Array.isArray(message.loadedWritableAddresses))
                            return "loadedWritableAddresses: array expected";
                        for (var i = 0; i < message.loadedWritableAddresses.length; ++i)
                            if (!(message.loadedWritableAddresses[i] && typeof message.loadedWritableAddresses[i].length === "number" || $util.isString(message.loadedWritableAddresses[i])))
                                return "loadedWritableAddresses: buffer[] expected";
                    }
                    if (message.loadedReadonlyAddresses != null && message.hasOwnProperty("loadedReadonlyAddresses")) {
                        if (!Array.isArray(message.loadedReadonlyAddresses))
                            return "loadedReadonlyAddresses: array expected";
                        for (var i = 0; i < message.loadedReadonlyAddresses.length; ++i)
                            if (!(message.loadedReadonlyAddresses[i] && typeof message.loadedReadonlyAddresses[i].length === "number" || $util.isString(message.loadedReadonlyAddresses[i])))
                                return "loadedReadonlyAddresses: buffer[] expected";
                    }
                    if (message.returnData != null && message.hasOwnProperty("returnData")) {
                        var error = $root.solana.storage.ConfirmedBlock.ReturnData.verify(message.returnData);
                        if (error)
                            return "returnData." + error;
                    }
                    if (message.returnDataNone != null && message.hasOwnProperty("returnDataNone"))
                        if (typeof message.returnDataNone !== "boolean")
                            return "returnDataNone: boolean expected";
                    if (message.computeUnitsConsumed != null && message.hasOwnProperty("computeUnitsConsumed")) {
                        properties._computeUnitsConsumed = 1;
                        if (!$util.isInteger(message.computeUnitsConsumed) && !(message.computeUnitsConsumed && $util.isInteger(message.computeUnitsConsumed.low) && $util.isInteger(message.computeUnitsConsumed.high)))
                            return "computeUnitsConsumed: integer|Long expected";
                    }
                    if (message.costUnits != null && message.hasOwnProperty("costUnits")) {
                        properties._costUnits = 1;
                        if (!$util.isInteger(message.costUnits) && !(message.costUnits && $util.isInteger(message.costUnits.low) && $util.isInteger(message.costUnits.high)))
                            return "costUnits: integer|Long expected";
                    }
                    return null;
                };

                /**
                 * Creates a TransactionStatusMeta message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.TransactionStatusMeta} TransactionStatusMeta
                 */
                TransactionStatusMeta.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.TransactionStatusMeta)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.TransactionStatusMeta();
                    if (object.err != null) {
                        if (typeof object.err !== "object")
                            throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.err: object expected");
                        message.err = $root.solana.storage.ConfirmedBlock.TransactionError.fromObject(object.err);
                    }
                    if (object.fee != null)
                        if ($util.Long)
                            (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                        else if (typeof object.fee === "string")
                            message.fee = parseInt(object.fee, 10);
                        else if (typeof object.fee === "number")
                            message.fee = object.fee;
                        else if (typeof object.fee === "object")
                            message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
                    if (object.preBalances) {
                        if (!Array.isArray(object.preBalances))
                            throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.preBalances: array expected");
                        message.preBalances = [];
                        for (var i = 0; i < object.preBalances.length; ++i)
                            if ($util.Long)
                                (message.preBalances[i] = $util.Long.fromValue(object.preBalances[i])).unsigned = true;
                            else if (typeof object.preBalances[i] === "string")
                                message.preBalances[i] = parseInt(object.preBalances[i], 10);
                            else if (typeof object.preBalances[i] === "number")
                                message.preBalances[i] = object.preBalances[i];
                            else if (typeof object.preBalances[i] === "object")
                                message.preBalances[i] = new $util.LongBits(object.preBalances[i].low >>> 0, object.preBalances[i].high >>> 0).toNumber(true);
                    }
                    if (object.postBalances) {
                        if (!Array.isArray(object.postBalances))
                            throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.postBalances: array expected");
                        message.postBalances = [];
                        for (var i = 0; i < object.postBalances.length; ++i)
                            if ($util.Long)
                                (message.postBalances[i] = $util.Long.fromValue(object.postBalances[i])).unsigned = true;
                            else if (typeof object.postBalances[i] === "string")
                                message.postBalances[i] = parseInt(object.postBalances[i], 10);
                            else if (typeof object.postBalances[i] === "number")
                                message.postBalances[i] = object.postBalances[i];
                            else if (typeof object.postBalances[i] === "object")
                                message.postBalances[i] = new $util.LongBits(object.postBalances[i].low >>> 0, object.postBalances[i].high >>> 0).toNumber(true);
                    }
                    if (object.innerInstructions) {
                        if (!Array.isArray(object.innerInstructions))
                            throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.innerInstructions: array expected");
                        message.innerInstructions = [];
                        for (var i = 0; i < object.innerInstructions.length; ++i) {
                            if (typeof object.innerInstructions[i] !== "object")
                                throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.innerInstructions: object expected");
                            message.innerInstructions[i] = $root.solana.storage.ConfirmedBlock.InnerInstructions.fromObject(object.innerInstructions[i]);
                        }
                    }
                    if (object.innerInstructionsNone != null)
                        message.innerInstructionsNone = Boolean(object.innerInstructionsNone);
                    if (object.logMessages) {
                        if (!Array.isArray(object.logMessages))
                            throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.logMessages: array expected");
                        message.logMessages = [];
                        for (var i = 0; i < object.logMessages.length; ++i)
                            message.logMessages[i] = String(object.logMessages[i]);
                    }
                    if (object.logMessagesNone != null)
                        message.logMessagesNone = Boolean(object.logMessagesNone);
                    if (object.preTokenBalances) {
                        if (!Array.isArray(object.preTokenBalances))
                            throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.preTokenBalances: array expected");
                        message.preTokenBalances = [];
                        for (var i = 0; i < object.preTokenBalances.length; ++i) {
                            if (typeof object.preTokenBalances[i] !== "object")
                                throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.preTokenBalances: object expected");
                            message.preTokenBalances[i] = $root.solana.storage.ConfirmedBlock.TokenBalance.fromObject(object.preTokenBalances[i]);
                        }
                    }
                    if (object.postTokenBalances) {
                        if (!Array.isArray(object.postTokenBalances))
                            throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.postTokenBalances: array expected");
                        message.postTokenBalances = [];
                        for (var i = 0; i < object.postTokenBalances.length; ++i) {
                            if (typeof object.postTokenBalances[i] !== "object")
                                throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.postTokenBalances: object expected");
                            message.postTokenBalances[i] = $root.solana.storage.ConfirmedBlock.TokenBalance.fromObject(object.postTokenBalances[i]);
                        }
                    }
                    if (object.rewards) {
                        if (!Array.isArray(object.rewards))
                            throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.rewards: array expected");
                        message.rewards = [];
                        for (var i = 0; i < object.rewards.length; ++i) {
                            if (typeof object.rewards[i] !== "object")
                                throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.rewards: object expected");
                            message.rewards[i] = $root.solana.storage.ConfirmedBlock.Reward.fromObject(object.rewards[i]);
                        }
                    }
                    if (object.loadedWritableAddresses) {
                        if (!Array.isArray(object.loadedWritableAddresses))
                            throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.loadedWritableAddresses: array expected");
                        message.loadedWritableAddresses = [];
                        for (var i = 0; i < object.loadedWritableAddresses.length; ++i)
                            if (typeof object.loadedWritableAddresses[i] === "string")
                                $util.base64.decode(object.loadedWritableAddresses[i], message.loadedWritableAddresses[i] = $util.newBuffer($util.base64.length(object.loadedWritableAddresses[i])), 0);
                            else if (object.loadedWritableAddresses[i].length >= 0)
                                message.loadedWritableAddresses[i] = object.loadedWritableAddresses[i];
                    }
                    if (object.loadedReadonlyAddresses) {
                        if (!Array.isArray(object.loadedReadonlyAddresses))
                            throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.loadedReadonlyAddresses: array expected");
                        message.loadedReadonlyAddresses = [];
                        for (var i = 0; i < object.loadedReadonlyAddresses.length; ++i)
                            if (typeof object.loadedReadonlyAddresses[i] === "string")
                                $util.base64.decode(object.loadedReadonlyAddresses[i], message.loadedReadonlyAddresses[i] = $util.newBuffer($util.base64.length(object.loadedReadonlyAddresses[i])), 0);
                            else if (object.loadedReadonlyAddresses[i].length >= 0)
                                message.loadedReadonlyAddresses[i] = object.loadedReadonlyAddresses[i];
                    }
                    if (object.returnData != null) {
                        if (typeof object.returnData !== "object")
                            throw TypeError(".solana.storage.ConfirmedBlock.TransactionStatusMeta.returnData: object expected");
                        message.returnData = $root.solana.storage.ConfirmedBlock.ReturnData.fromObject(object.returnData);
                    }
                    if (object.returnDataNone != null)
                        message.returnDataNone = Boolean(object.returnDataNone);
                    if (object.computeUnitsConsumed != null)
                        if ($util.Long)
                            (message.computeUnitsConsumed = $util.Long.fromValue(object.computeUnitsConsumed)).unsigned = true;
                        else if (typeof object.computeUnitsConsumed === "string")
                            message.computeUnitsConsumed = parseInt(object.computeUnitsConsumed, 10);
                        else if (typeof object.computeUnitsConsumed === "number")
                            message.computeUnitsConsumed = object.computeUnitsConsumed;
                        else if (typeof object.computeUnitsConsumed === "object")
                            message.computeUnitsConsumed = new $util.LongBits(object.computeUnitsConsumed.low >>> 0, object.computeUnitsConsumed.high >>> 0).toNumber(true);
                    if (object.costUnits != null)
                        if ($util.Long)
                            (message.costUnits = $util.Long.fromValue(object.costUnits)).unsigned = true;
                        else if (typeof object.costUnits === "string")
                            message.costUnits = parseInt(object.costUnits, 10);
                        else if (typeof object.costUnits === "number")
                            message.costUnits = object.costUnits;
                        else if (typeof object.costUnits === "object")
                            message.costUnits = new $util.LongBits(object.costUnits.low >>> 0, object.costUnits.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a TransactionStatusMeta message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @static
                 * @param {solana.storage.ConfirmedBlock.TransactionStatusMeta} message TransactionStatusMeta
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TransactionStatusMeta.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.preBalances = [];
                        object.postBalances = [];
                        object.innerInstructions = [];
                        object.logMessages = [];
                        object.preTokenBalances = [];
                        object.postTokenBalances = [];
                        object.rewards = [];
                        object.loadedWritableAddresses = [];
                        object.loadedReadonlyAddresses = [];
                    }
                    if (options.defaults) {
                        object.err = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.fee = options.longs === String ? "0" : 0;
                        object.innerInstructionsNone = false;
                        object.logMessagesNone = false;
                        object.returnData = null;
                        object.returnDataNone = false;
                    }
                    if (message.err != null && message.hasOwnProperty("err"))
                        object.err = $root.solana.storage.ConfirmedBlock.TransactionError.toObject(message.err, options);
                    if (message.fee != null && message.hasOwnProperty("fee"))
                        if (typeof message.fee === "number")
                            object.fee = options.longs === String ? String(message.fee) : message.fee;
                        else
                            object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
                    if (message.preBalances && message.preBalances.length) {
                        object.preBalances = [];
                        for (var j = 0; j < message.preBalances.length; ++j)
                            if (typeof message.preBalances[j] === "number")
                                object.preBalances[j] = options.longs === String ? String(message.preBalances[j]) : message.preBalances[j];
                            else
                                object.preBalances[j] = options.longs === String ? $util.Long.prototype.toString.call(message.preBalances[j]) : options.longs === Number ? new $util.LongBits(message.preBalances[j].low >>> 0, message.preBalances[j].high >>> 0).toNumber(true) : message.preBalances[j];
                    }
                    if (message.postBalances && message.postBalances.length) {
                        object.postBalances = [];
                        for (var j = 0; j < message.postBalances.length; ++j)
                            if (typeof message.postBalances[j] === "number")
                                object.postBalances[j] = options.longs === String ? String(message.postBalances[j]) : message.postBalances[j];
                            else
                                object.postBalances[j] = options.longs === String ? $util.Long.prototype.toString.call(message.postBalances[j]) : options.longs === Number ? new $util.LongBits(message.postBalances[j].low >>> 0, message.postBalances[j].high >>> 0).toNumber(true) : message.postBalances[j];
                    }
                    if (message.innerInstructions && message.innerInstructions.length) {
                        object.innerInstructions = [];
                        for (var j = 0; j < message.innerInstructions.length; ++j)
                            object.innerInstructions[j] = $root.solana.storage.ConfirmedBlock.InnerInstructions.toObject(message.innerInstructions[j], options);
                    }
                    if (message.logMessages && message.logMessages.length) {
                        object.logMessages = [];
                        for (var j = 0; j < message.logMessages.length; ++j)
                            object.logMessages[j] = message.logMessages[j];
                    }
                    if (message.preTokenBalances && message.preTokenBalances.length) {
                        object.preTokenBalances = [];
                        for (var j = 0; j < message.preTokenBalances.length; ++j)
                            object.preTokenBalances[j] = $root.solana.storage.ConfirmedBlock.TokenBalance.toObject(message.preTokenBalances[j], options);
                    }
                    if (message.postTokenBalances && message.postTokenBalances.length) {
                        object.postTokenBalances = [];
                        for (var j = 0; j < message.postTokenBalances.length; ++j)
                            object.postTokenBalances[j] = $root.solana.storage.ConfirmedBlock.TokenBalance.toObject(message.postTokenBalances[j], options);
                    }
                    if (message.rewards && message.rewards.length) {
                        object.rewards = [];
                        for (var j = 0; j < message.rewards.length; ++j)
                            object.rewards[j] = $root.solana.storage.ConfirmedBlock.Reward.toObject(message.rewards[j], options);
                    }
                    if (message.innerInstructionsNone != null && message.hasOwnProperty("innerInstructionsNone"))
                        object.innerInstructionsNone = message.innerInstructionsNone;
                    if (message.logMessagesNone != null && message.hasOwnProperty("logMessagesNone"))
                        object.logMessagesNone = message.logMessagesNone;
                    if (message.loadedWritableAddresses && message.loadedWritableAddresses.length) {
                        object.loadedWritableAddresses = [];
                        for (var j = 0; j < message.loadedWritableAddresses.length; ++j)
                            object.loadedWritableAddresses[j] = options.bytes === String ? $util.base64.encode(message.loadedWritableAddresses[j], 0, message.loadedWritableAddresses[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.loadedWritableAddresses[j]) : message.loadedWritableAddresses[j];
                    }
                    if (message.loadedReadonlyAddresses && message.loadedReadonlyAddresses.length) {
                        object.loadedReadonlyAddresses = [];
                        for (var j = 0; j < message.loadedReadonlyAddresses.length; ++j)
                            object.loadedReadonlyAddresses[j] = options.bytes === String ? $util.base64.encode(message.loadedReadonlyAddresses[j], 0, message.loadedReadonlyAddresses[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.loadedReadonlyAddresses[j]) : message.loadedReadonlyAddresses[j];
                    }
                    if (message.returnData != null && message.hasOwnProperty("returnData"))
                        object.returnData = $root.solana.storage.ConfirmedBlock.ReturnData.toObject(message.returnData, options);
                    if (message.returnDataNone != null && message.hasOwnProperty("returnDataNone"))
                        object.returnDataNone = message.returnDataNone;
                    if (message.computeUnitsConsumed != null && message.hasOwnProperty("computeUnitsConsumed")) {
                        if (typeof message.computeUnitsConsumed === "number")
                            object.computeUnitsConsumed = options.longs === String ? String(message.computeUnitsConsumed) : message.computeUnitsConsumed;
                        else
                            object.computeUnitsConsumed = options.longs === String ? $util.Long.prototype.toString.call(message.computeUnitsConsumed) : options.longs === Number ? new $util.LongBits(message.computeUnitsConsumed.low >>> 0, message.computeUnitsConsumed.high >>> 0).toNumber(true) : message.computeUnitsConsumed;
                        if (options.oneofs)
                            object._computeUnitsConsumed = "computeUnitsConsumed";
                    }
                    if (message.costUnits != null && message.hasOwnProperty("costUnits")) {
                        if (typeof message.costUnits === "number")
                            object.costUnits = options.longs === String ? String(message.costUnits) : message.costUnits;
                        else
                            object.costUnits = options.longs === String ? $util.Long.prototype.toString.call(message.costUnits) : options.longs === Number ? new $util.LongBits(message.costUnits.low >>> 0, message.costUnits.high >>> 0).toNumber(true) : message.costUnits;
                        if (options.oneofs)
                            object._costUnits = "costUnits";
                    }
                    return object;
                };

                /**
                 * Converts this TransactionStatusMeta to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TransactionStatusMeta.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TransactionStatusMeta
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.TransactionStatusMeta
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TransactionStatusMeta.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.TransactionStatusMeta";
                };

                return TransactionStatusMeta;
            })();

            ConfirmedBlock.TransactionError = (function() {

                /**
                 * Properties of a TransactionError.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface ITransactionError
                 * @property {Uint8Array|null} [err] TransactionError err
                 */

                /**
                 * Constructs a new TransactionError.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a TransactionError.
                 * @implements ITransactionError
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.ITransactionError=} [properties] Properties to set
                 */
                function TransactionError(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TransactionError err.
                 * @member {Uint8Array} err
                 * @memberof solana.storage.ConfirmedBlock.TransactionError
                 * @instance
                 */
                TransactionError.prototype.err = $util.newBuffer([]);

                /**
                 * Creates a new TransactionError instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.TransactionError
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ITransactionError=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.TransactionError} TransactionError instance
                 */
                TransactionError.create = function create(properties) {
                    return new TransactionError(properties);
                };

                /**
                 * Encodes the specified TransactionError message. Does not implicitly {@link solana.storage.ConfirmedBlock.TransactionError.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.TransactionError
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ITransactionError} message TransactionError message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionError.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.err);
                    return writer;
                };

                /**
                 * Encodes the specified TransactionError message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.TransactionError.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.TransactionError
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ITransactionError} message TransactionError message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionError.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TransactionError message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.TransactionError
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.TransactionError} TransactionError
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionError.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.TransactionError();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.err = reader.bytes();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TransactionError message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.TransactionError
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.TransactionError} TransactionError
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionError.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TransactionError message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.TransactionError
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TransactionError.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.err != null && message.hasOwnProperty("err"))
                        if (!(message.err && typeof message.err.length === "number" || $util.isString(message.err)))
                            return "err: buffer expected";
                    return null;
                };

                /**
                 * Creates a TransactionError message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.TransactionError
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.TransactionError} TransactionError
                 */
                TransactionError.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.TransactionError)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.TransactionError();
                    if (object.err != null)
                        if (typeof object.err === "string")
                            $util.base64.decode(object.err, message.err = $util.newBuffer($util.base64.length(object.err)), 0);
                        else if (object.err.length >= 0)
                            message.err = object.err;
                    return message;
                };

                /**
                 * Creates a plain object from a TransactionError message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.TransactionError
                 * @static
                 * @param {solana.storage.ConfirmedBlock.TransactionError} message TransactionError
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TransactionError.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.err = "";
                        else {
                            object.err = [];
                            if (options.bytes !== Array)
                                object.err = $util.newBuffer(object.err);
                        }
                    if (message.err != null && message.hasOwnProperty("err"))
                        object.err = options.bytes === String ? $util.base64.encode(message.err, 0, message.err.length) : options.bytes === Array ? Array.prototype.slice.call(message.err) : message.err;
                    return object;
                };

                /**
                 * Converts this TransactionError to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.TransactionError
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TransactionError.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TransactionError
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.TransactionError
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TransactionError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.TransactionError";
                };

                return TransactionError;
            })();

            ConfirmedBlock.InnerInstructions = (function() {

                /**
                 * Properties of an InnerInstructions.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface IInnerInstructions
                 * @property {number|null} [index] InnerInstructions index
                 * @property {Array.<solana.storage.ConfirmedBlock.IInnerInstruction>|null} [instructions] InnerInstructions instructions
                 */

                /**
                 * Constructs a new InnerInstructions.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents an InnerInstructions.
                 * @implements IInnerInstructions
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.IInnerInstructions=} [properties] Properties to set
                 */
                function InnerInstructions(properties) {
                    this.instructions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * InnerInstructions index.
                 * @member {number} index
                 * @memberof solana.storage.ConfirmedBlock.InnerInstructions
                 * @instance
                 */
                InnerInstructions.prototype.index = 0;

                /**
                 * InnerInstructions instructions.
                 * @member {Array.<solana.storage.ConfirmedBlock.IInnerInstruction>} instructions
                 * @memberof solana.storage.ConfirmedBlock.InnerInstructions
                 * @instance
                 */
                InnerInstructions.prototype.instructions = $util.emptyArray;

                /**
                 * Creates a new InnerInstructions instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.InnerInstructions
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IInnerInstructions=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.InnerInstructions} InnerInstructions instance
                 */
                InnerInstructions.create = function create(properties) {
                    return new InnerInstructions(properties);
                };

                /**
                 * Encodes the specified InnerInstructions message. Does not implicitly {@link solana.storage.ConfirmedBlock.InnerInstructions.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.InnerInstructions
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IInnerInstructions} message InnerInstructions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InnerInstructions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                    if (message.instructions != null && message.instructions.length)
                        for (var i = 0; i < message.instructions.length; ++i)
                            $root.solana.storage.ConfirmedBlock.InnerInstruction.encode(message.instructions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified InnerInstructions message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.InnerInstructions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.InnerInstructions
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IInnerInstructions} message InnerInstructions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InnerInstructions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an InnerInstructions message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.InnerInstructions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.InnerInstructions} InnerInstructions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InnerInstructions.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.InnerInstructions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.index = reader.uint32();
                                break;
                            }
                        case 2: {
                                if (!(message.instructions && message.instructions.length))
                                    message.instructions = [];
                                message.instructions.push($root.solana.storage.ConfirmedBlock.InnerInstruction.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an InnerInstructions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.InnerInstructions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.InnerInstructions} InnerInstructions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InnerInstructions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an InnerInstructions message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.InnerInstructions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InnerInstructions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.index != null && message.hasOwnProperty("index"))
                        if (!$util.isInteger(message.index))
                            return "index: integer expected";
                    if (message.instructions != null && message.hasOwnProperty("instructions")) {
                        if (!Array.isArray(message.instructions))
                            return "instructions: array expected";
                        for (var i = 0; i < message.instructions.length; ++i) {
                            var error = $root.solana.storage.ConfirmedBlock.InnerInstruction.verify(message.instructions[i]);
                            if (error)
                                return "instructions." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an InnerInstructions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.InnerInstructions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.InnerInstructions} InnerInstructions
                 */
                InnerInstructions.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.InnerInstructions)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.InnerInstructions();
                    if (object.index != null)
                        message.index = object.index >>> 0;
                    if (object.instructions) {
                        if (!Array.isArray(object.instructions))
                            throw TypeError(".solana.storage.ConfirmedBlock.InnerInstructions.instructions: array expected");
                        message.instructions = [];
                        for (var i = 0; i < object.instructions.length; ++i) {
                            if (typeof object.instructions[i] !== "object")
                                throw TypeError(".solana.storage.ConfirmedBlock.InnerInstructions.instructions: object expected");
                            message.instructions[i] = $root.solana.storage.ConfirmedBlock.InnerInstruction.fromObject(object.instructions[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an InnerInstructions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.InnerInstructions
                 * @static
                 * @param {solana.storage.ConfirmedBlock.InnerInstructions} message InnerInstructions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InnerInstructions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.instructions = [];
                    if (options.defaults)
                        object.index = 0;
                    if (message.index != null && message.hasOwnProperty("index"))
                        object.index = message.index;
                    if (message.instructions && message.instructions.length) {
                        object.instructions = [];
                        for (var j = 0; j < message.instructions.length; ++j)
                            object.instructions[j] = $root.solana.storage.ConfirmedBlock.InnerInstruction.toObject(message.instructions[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this InnerInstructions to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.InnerInstructions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InnerInstructions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for InnerInstructions
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.InnerInstructions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                InnerInstructions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.InnerInstructions";
                };

                return InnerInstructions;
            })();

            ConfirmedBlock.InnerInstruction = (function() {

                /**
                 * Properties of an InnerInstruction.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface IInnerInstruction
                 * @property {number|null} [programIdIndex] InnerInstruction programIdIndex
                 * @property {Uint8Array|null} [accounts] InnerInstruction accounts
                 * @property {Uint8Array|null} [data] InnerInstruction data
                 * @property {number|null} [stackHeight] InnerInstruction stackHeight
                 */

                /**
                 * Constructs a new InnerInstruction.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents an InnerInstruction.
                 * @implements IInnerInstruction
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.IInnerInstruction=} [properties] Properties to set
                 */
                function InnerInstruction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * InnerInstruction programIdIndex.
                 * @member {number} programIdIndex
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @instance
                 */
                InnerInstruction.prototype.programIdIndex = 0;

                /**
                 * InnerInstruction accounts.
                 * @member {Uint8Array} accounts
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @instance
                 */
                InnerInstruction.prototype.accounts = $util.newBuffer([]);

                /**
                 * InnerInstruction data.
                 * @member {Uint8Array} data
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @instance
                 */
                InnerInstruction.prototype.data = $util.newBuffer([]);

                /**
                 * InnerInstruction stackHeight.
                 * @member {number|null|undefined} stackHeight
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @instance
                 */
                InnerInstruction.prototype.stackHeight = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * InnerInstruction _stackHeight.
                 * @member {"stackHeight"|undefined} _stackHeight
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @instance
                 */
                Object.defineProperty(InnerInstruction.prototype, "_stackHeight", {
                    get: $util.oneOfGetter($oneOfFields = ["stackHeight"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new InnerInstruction instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IInnerInstruction=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.InnerInstruction} InnerInstruction instance
                 */
                InnerInstruction.create = function create(properties) {
                    return new InnerInstruction(properties);
                };

                /**
                 * Encodes the specified InnerInstruction message. Does not implicitly {@link solana.storage.ConfirmedBlock.InnerInstruction.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IInnerInstruction} message InnerInstruction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InnerInstruction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.programIdIndex != null && Object.hasOwnProperty.call(message, "programIdIndex"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.programIdIndex);
                    if (message.accounts != null && Object.hasOwnProperty.call(message, "accounts"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.accounts);
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                    if (message.stackHeight != null && Object.hasOwnProperty.call(message, "stackHeight"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.stackHeight);
                    return writer;
                };

                /**
                 * Encodes the specified InnerInstruction message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.InnerInstruction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IInnerInstruction} message InnerInstruction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InnerInstruction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an InnerInstruction message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.InnerInstruction} InnerInstruction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InnerInstruction.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.InnerInstruction();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.programIdIndex = reader.uint32();
                                break;
                            }
                        case 2: {
                                message.accounts = reader.bytes();
                                break;
                            }
                        case 3: {
                                message.data = reader.bytes();
                                break;
                            }
                        case 4: {
                                message.stackHeight = reader.uint32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an InnerInstruction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.InnerInstruction} InnerInstruction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InnerInstruction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an InnerInstruction message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InnerInstruction.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.programIdIndex != null && message.hasOwnProperty("programIdIndex"))
                        if (!$util.isInteger(message.programIdIndex))
                            return "programIdIndex: integer expected";
                    if (message.accounts != null && message.hasOwnProperty("accounts"))
                        if (!(message.accounts && typeof message.accounts.length === "number" || $util.isString(message.accounts)))
                            return "accounts: buffer expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                            return "data: buffer expected";
                    if (message.stackHeight != null && message.hasOwnProperty("stackHeight")) {
                        properties._stackHeight = 1;
                        if (!$util.isInteger(message.stackHeight))
                            return "stackHeight: integer expected";
                    }
                    return null;
                };

                /**
                 * Creates an InnerInstruction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.InnerInstruction} InnerInstruction
                 */
                InnerInstruction.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.InnerInstruction)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.InnerInstruction();
                    if (object.programIdIndex != null)
                        message.programIdIndex = object.programIdIndex >>> 0;
                    if (object.accounts != null)
                        if (typeof object.accounts === "string")
                            $util.base64.decode(object.accounts, message.accounts = $util.newBuffer($util.base64.length(object.accounts)), 0);
                        else if (object.accounts.length >= 0)
                            message.accounts = object.accounts;
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length >= 0)
                            message.data = object.data;
                    if (object.stackHeight != null)
                        message.stackHeight = object.stackHeight >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from an InnerInstruction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.InnerInstruction} message InnerInstruction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InnerInstruction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.programIdIndex = 0;
                        if (options.bytes === String)
                            object.accounts = "";
                        else {
                            object.accounts = [];
                            if (options.bytes !== Array)
                                object.accounts = $util.newBuffer(object.accounts);
                        }
                        if (options.bytes === String)
                            object.data = "";
                        else {
                            object.data = [];
                            if (options.bytes !== Array)
                                object.data = $util.newBuffer(object.data);
                        }
                    }
                    if (message.programIdIndex != null && message.hasOwnProperty("programIdIndex"))
                        object.programIdIndex = message.programIdIndex;
                    if (message.accounts != null && message.hasOwnProperty("accounts"))
                        object.accounts = options.bytes === String ? $util.base64.encode(message.accounts, 0, message.accounts.length) : options.bytes === Array ? Array.prototype.slice.call(message.accounts) : message.accounts;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    if (message.stackHeight != null && message.hasOwnProperty("stackHeight")) {
                        object.stackHeight = message.stackHeight;
                        if (options.oneofs)
                            object._stackHeight = "stackHeight";
                    }
                    return object;
                };

                /**
                 * Converts this InnerInstruction to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InnerInstruction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for InnerInstruction
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.InnerInstruction
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                InnerInstruction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.InnerInstruction";
                };

                return InnerInstruction;
            })();

            ConfirmedBlock.CompiledInstruction = (function() {

                /**
                 * Properties of a CompiledInstruction.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface ICompiledInstruction
                 * @property {number|null} [programIdIndex] CompiledInstruction programIdIndex
                 * @property {Uint8Array|null} [accounts] CompiledInstruction accounts
                 * @property {Uint8Array|null} [data] CompiledInstruction data
                 */

                /**
                 * Constructs a new CompiledInstruction.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a CompiledInstruction.
                 * @implements ICompiledInstruction
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.ICompiledInstruction=} [properties] Properties to set
                 */
                function CompiledInstruction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CompiledInstruction programIdIndex.
                 * @member {number} programIdIndex
                 * @memberof solana.storage.ConfirmedBlock.CompiledInstruction
                 * @instance
                 */
                CompiledInstruction.prototype.programIdIndex = 0;

                /**
                 * CompiledInstruction accounts.
                 * @member {Uint8Array} accounts
                 * @memberof solana.storage.ConfirmedBlock.CompiledInstruction
                 * @instance
                 */
                CompiledInstruction.prototype.accounts = $util.newBuffer([]);

                /**
                 * CompiledInstruction data.
                 * @member {Uint8Array} data
                 * @memberof solana.storage.ConfirmedBlock.CompiledInstruction
                 * @instance
                 */
                CompiledInstruction.prototype.data = $util.newBuffer([]);

                /**
                 * Creates a new CompiledInstruction instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.CompiledInstruction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ICompiledInstruction=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.CompiledInstruction} CompiledInstruction instance
                 */
                CompiledInstruction.create = function create(properties) {
                    return new CompiledInstruction(properties);
                };

                /**
                 * Encodes the specified CompiledInstruction message. Does not implicitly {@link solana.storage.ConfirmedBlock.CompiledInstruction.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.CompiledInstruction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ICompiledInstruction} message CompiledInstruction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CompiledInstruction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.programIdIndex != null && Object.hasOwnProperty.call(message, "programIdIndex"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.programIdIndex);
                    if (message.accounts != null && Object.hasOwnProperty.call(message, "accounts"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.accounts);
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                    return writer;
                };

                /**
                 * Encodes the specified CompiledInstruction message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.CompiledInstruction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.CompiledInstruction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ICompiledInstruction} message CompiledInstruction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CompiledInstruction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CompiledInstruction message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.CompiledInstruction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.CompiledInstruction} CompiledInstruction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CompiledInstruction.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.CompiledInstruction();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.programIdIndex = reader.uint32();
                                break;
                            }
                        case 2: {
                                message.accounts = reader.bytes();
                                break;
                            }
                        case 3: {
                                message.data = reader.bytes();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CompiledInstruction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.CompiledInstruction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.CompiledInstruction} CompiledInstruction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CompiledInstruction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CompiledInstruction message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.CompiledInstruction
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CompiledInstruction.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.programIdIndex != null && message.hasOwnProperty("programIdIndex"))
                        if (!$util.isInteger(message.programIdIndex))
                            return "programIdIndex: integer expected";
                    if (message.accounts != null && message.hasOwnProperty("accounts"))
                        if (!(message.accounts && typeof message.accounts.length === "number" || $util.isString(message.accounts)))
                            return "accounts: buffer expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                            return "data: buffer expected";
                    return null;
                };

                /**
                 * Creates a CompiledInstruction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.CompiledInstruction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.CompiledInstruction} CompiledInstruction
                 */
                CompiledInstruction.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.CompiledInstruction)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.CompiledInstruction();
                    if (object.programIdIndex != null)
                        message.programIdIndex = object.programIdIndex >>> 0;
                    if (object.accounts != null)
                        if (typeof object.accounts === "string")
                            $util.base64.decode(object.accounts, message.accounts = $util.newBuffer($util.base64.length(object.accounts)), 0);
                        else if (object.accounts.length >= 0)
                            message.accounts = object.accounts;
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length >= 0)
                            message.data = object.data;
                    return message;
                };

                /**
                 * Creates a plain object from a CompiledInstruction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.CompiledInstruction
                 * @static
                 * @param {solana.storage.ConfirmedBlock.CompiledInstruction} message CompiledInstruction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CompiledInstruction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.programIdIndex = 0;
                        if (options.bytes === String)
                            object.accounts = "";
                        else {
                            object.accounts = [];
                            if (options.bytes !== Array)
                                object.accounts = $util.newBuffer(object.accounts);
                        }
                        if (options.bytes === String)
                            object.data = "";
                        else {
                            object.data = [];
                            if (options.bytes !== Array)
                                object.data = $util.newBuffer(object.data);
                        }
                    }
                    if (message.programIdIndex != null && message.hasOwnProperty("programIdIndex"))
                        object.programIdIndex = message.programIdIndex;
                    if (message.accounts != null && message.hasOwnProperty("accounts"))
                        object.accounts = options.bytes === String ? $util.base64.encode(message.accounts, 0, message.accounts.length) : options.bytes === Array ? Array.prototype.slice.call(message.accounts) : message.accounts;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    return object;
                };

                /**
                 * Converts this CompiledInstruction to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.CompiledInstruction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CompiledInstruction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for CompiledInstruction
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.CompiledInstruction
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                CompiledInstruction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.CompiledInstruction";
                };

                return CompiledInstruction;
            })();

            ConfirmedBlock.TokenBalance = (function() {

                /**
                 * Properties of a TokenBalance.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface ITokenBalance
                 * @property {number|null} [accountIndex] TokenBalance accountIndex
                 * @property {string|null} [mint] TokenBalance mint
                 * @property {solana.storage.ConfirmedBlock.IUiTokenAmount|null} [uiTokenAmount] TokenBalance uiTokenAmount
                 * @property {string|null} [owner] TokenBalance owner
                 * @property {string|null} [programId] TokenBalance programId
                 */

                /**
                 * Constructs a new TokenBalance.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a TokenBalance.
                 * @implements ITokenBalance
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.ITokenBalance=} [properties] Properties to set
                 */
                function TokenBalance(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TokenBalance accountIndex.
                 * @member {number} accountIndex
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @instance
                 */
                TokenBalance.prototype.accountIndex = 0;

                /**
                 * TokenBalance mint.
                 * @member {string} mint
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @instance
                 */
                TokenBalance.prototype.mint = "";

                /**
                 * TokenBalance uiTokenAmount.
                 * @member {solana.storage.ConfirmedBlock.IUiTokenAmount|null|undefined} uiTokenAmount
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @instance
                 */
                TokenBalance.prototype.uiTokenAmount = null;

                /**
                 * TokenBalance owner.
                 * @member {string} owner
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @instance
                 */
                TokenBalance.prototype.owner = "";

                /**
                 * TokenBalance programId.
                 * @member {string} programId
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @instance
                 */
                TokenBalance.prototype.programId = "";

                /**
                 * Creates a new TokenBalance instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ITokenBalance=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.TokenBalance} TokenBalance instance
                 */
                TokenBalance.create = function create(properties) {
                    return new TokenBalance(properties);
                };

                /**
                 * Encodes the specified TokenBalance message. Does not implicitly {@link solana.storage.ConfirmedBlock.TokenBalance.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ITokenBalance} message TokenBalance message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TokenBalance.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.accountIndex != null && Object.hasOwnProperty.call(message, "accountIndex"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.accountIndex);
                    if (message.mint != null && Object.hasOwnProperty.call(message, "mint"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.mint);
                    if (message.uiTokenAmount != null && Object.hasOwnProperty.call(message, "uiTokenAmount"))
                        $root.solana.storage.ConfirmedBlock.UiTokenAmount.encode(message.uiTokenAmount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.owner);
                    if (message.programId != null && Object.hasOwnProperty.call(message, "programId"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.programId);
                    return writer;
                };

                /**
                 * Encodes the specified TokenBalance message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.TokenBalance.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ITokenBalance} message TokenBalance message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TokenBalance.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TokenBalance message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.TokenBalance} TokenBalance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TokenBalance.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.TokenBalance();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.accountIndex = reader.uint32();
                                break;
                            }
                        case 2: {
                                message.mint = reader.string();
                                break;
                            }
                        case 3: {
                                message.uiTokenAmount = $root.solana.storage.ConfirmedBlock.UiTokenAmount.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.owner = reader.string();
                                break;
                            }
                        case 5: {
                                message.programId = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TokenBalance message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.TokenBalance} TokenBalance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TokenBalance.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TokenBalance message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TokenBalance.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.accountIndex != null && message.hasOwnProperty("accountIndex"))
                        if (!$util.isInteger(message.accountIndex))
                            return "accountIndex: integer expected";
                    if (message.mint != null && message.hasOwnProperty("mint"))
                        if (!$util.isString(message.mint))
                            return "mint: string expected";
                    if (message.uiTokenAmount != null && message.hasOwnProperty("uiTokenAmount")) {
                        var error = $root.solana.storage.ConfirmedBlock.UiTokenAmount.verify(message.uiTokenAmount);
                        if (error)
                            return "uiTokenAmount." + error;
                    }
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!$util.isString(message.owner))
                            return "owner: string expected";
                    if (message.programId != null && message.hasOwnProperty("programId"))
                        if (!$util.isString(message.programId))
                            return "programId: string expected";
                    return null;
                };

                /**
                 * Creates a TokenBalance message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.TokenBalance} TokenBalance
                 */
                TokenBalance.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.TokenBalance)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.TokenBalance();
                    if (object.accountIndex != null)
                        message.accountIndex = object.accountIndex >>> 0;
                    if (object.mint != null)
                        message.mint = String(object.mint);
                    if (object.uiTokenAmount != null) {
                        if (typeof object.uiTokenAmount !== "object")
                            throw TypeError(".solana.storage.ConfirmedBlock.TokenBalance.uiTokenAmount: object expected");
                        message.uiTokenAmount = $root.solana.storage.ConfirmedBlock.UiTokenAmount.fromObject(object.uiTokenAmount);
                    }
                    if (object.owner != null)
                        message.owner = String(object.owner);
                    if (object.programId != null)
                        message.programId = String(object.programId);
                    return message;
                };

                /**
                 * Creates a plain object from a TokenBalance message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @static
                 * @param {solana.storage.ConfirmedBlock.TokenBalance} message TokenBalance
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TokenBalance.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.accountIndex = 0;
                        object.mint = "";
                        object.uiTokenAmount = null;
                        object.owner = "";
                        object.programId = "";
                    }
                    if (message.accountIndex != null && message.hasOwnProperty("accountIndex"))
                        object.accountIndex = message.accountIndex;
                    if (message.mint != null && message.hasOwnProperty("mint"))
                        object.mint = message.mint;
                    if (message.uiTokenAmount != null && message.hasOwnProperty("uiTokenAmount"))
                        object.uiTokenAmount = $root.solana.storage.ConfirmedBlock.UiTokenAmount.toObject(message.uiTokenAmount, options);
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = message.owner;
                    if (message.programId != null && message.hasOwnProperty("programId"))
                        object.programId = message.programId;
                    return object;
                };

                /**
                 * Converts this TokenBalance to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TokenBalance.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TokenBalance
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.TokenBalance
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TokenBalance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.TokenBalance";
                };

                return TokenBalance;
            })();

            ConfirmedBlock.UiTokenAmount = (function() {

                /**
                 * Properties of an UiTokenAmount.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface IUiTokenAmount
                 * @property {number|null} [uiAmount] UiTokenAmount uiAmount
                 * @property {number|null} [decimals] UiTokenAmount decimals
                 * @property {string|null} [amount] UiTokenAmount amount
                 * @property {string|null} [uiAmountString] UiTokenAmount uiAmountString
                 */

                /**
                 * Constructs a new UiTokenAmount.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents an UiTokenAmount.
                 * @implements IUiTokenAmount
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.IUiTokenAmount=} [properties] Properties to set
                 */
                function UiTokenAmount(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UiTokenAmount uiAmount.
                 * @member {number} uiAmount
                 * @memberof solana.storage.ConfirmedBlock.UiTokenAmount
                 * @instance
                 */
                UiTokenAmount.prototype.uiAmount = 0;

                /**
                 * UiTokenAmount decimals.
                 * @member {number} decimals
                 * @memberof solana.storage.ConfirmedBlock.UiTokenAmount
                 * @instance
                 */
                UiTokenAmount.prototype.decimals = 0;

                /**
                 * UiTokenAmount amount.
                 * @member {string} amount
                 * @memberof solana.storage.ConfirmedBlock.UiTokenAmount
                 * @instance
                 */
                UiTokenAmount.prototype.amount = "";

                /**
                 * UiTokenAmount uiAmountString.
                 * @member {string} uiAmountString
                 * @memberof solana.storage.ConfirmedBlock.UiTokenAmount
                 * @instance
                 */
                UiTokenAmount.prototype.uiAmountString = "";

                /**
                 * Creates a new UiTokenAmount instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.UiTokenAmount
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IUiTokenAmount=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.UiTokenAmount} UiTokenAmount instance
                 */
                UiTokenAmount.create = function create(properties) {
                    return new UiTokenAmount(properties);
                };

                /**
                 * Encodes the specified UiTokenAmount message. Does not implicitly {@link solana.storage.ConfirmedBlock.UiTokenAmount.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.UiTokenAmount
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IUiTokenAmount} message UiTokenAmount message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UiTokenAmount.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uiAmount != null && Object.hasOwnProperty.call(message, "uiAmount"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.uiAmount);
                    if (message.decimals != null && Object.hasOwnProperty.call(message, "decimals"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.decimals);
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.amount);
                    if (message.uiAmountString != null && Object.hasOwnProperty.call(message, "uiAmountString"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.uiAmountString);
                    return writer;
                };

                /**
                 * Encodes the specified UiTokenAmount message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.UiTokenAmount.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.UiTokenAmount
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IUiTokenAmount} message UiTokenAmount message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UiTokenAmount.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UiTokenAmount message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.UiTokenAmount
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.UiTokenAmount} UiTokenAmount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UiTokenAmount.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.UiTokenAmount();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.uiAmount = reader.double();
                                break;
                            }
                        case 2: {
                                message.decimals = reader.uint32();
                                break;
                            }
                        case 3: {
                                message.amount = reader.string();
                                break;
                            }
                        case 4: {
                                message.uiAmountString = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UiTokenAmount message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.UiTokenAmount
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.UiTokenAmount} UiTokenAmount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UiTokenAmount.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UiTokenAmount message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.UiTokenAmount
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UiTokenAmount.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uiAmount != null && message.hasOwnProperty("uiAmount"))
                        if (typeof message.uiAmount !== "number")
                            return "uiAmount: number expected";
                    if (message.decimals != null && message.hasOwnProperty("decimals"))
                        if (!$util.isInteger(message.decimals))
                            return "decimals: integer expected";
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        if (!$util.isString(message.amount))
                            return "amount: string expected";
                    if (message.uiAmountString != null && message.hasOwnProperty("uiAmountString"))
                        if (!$util.isString(message.uiAmountString))
                            return "uiAmountString: string expected";
                    return null;
                };

                /**
                 * Creates an UiTokenAmount message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.UiTokenAmount
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.UiTokenAmount} UiTokenAmount
                 */
                UiTokenAmount.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.UiTokenAmount)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.UiTokenAmount();
                    if (object.uiAmount != null)
                        message.uiAmount = Number(object.uiAmount);
                    if (object.decimals != null)
                        message.decimals = object.decimals >>> 0;
                    if (object.amount != null)
                        message.amount = String(object.amount);
                    if (object.uiAmountString != null)
                        message.uiAmountString = String(object.uiAmountString);
                    return message;
                };

                /**
                 * Creates a plain object from an UiTokenAmount message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.UiTokenAmount
                 * @static
                 * @param {solana.storage.ConfirmedBlock.UiTokenAmount} message UiTokenAmount
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UiTokenAmount.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.uiAmount = 0;
                        object.decimals = 0;
                        object.amount = "";
                        object.uiAmountString = "";
                    }
                    if (message.uiAmount != null && message.hasOwnProperty("uiAmount"))
                        object.uiAmount = options.json && !isFinite(message.uiAmount) ? String(message.uiAmount) : message.uiAmount;
                    if (message.decimals != null && message.hasOwnProperty("decimals"))
                        object.decimals = message.decimals;
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = message.amount;
                    if (message.uiAmountString != null && message.hasOwnProperty("uiAmountString"))
                        object.uiAmountString = message.uiAmountString;
                    return object;
                };

                /**
                 * Converts this UiTokenAmount to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.UiTokenAmount
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UiTokenAmount.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for UiTokenAmount
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.UiTokenAmount
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                UiTokenAmount.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.UiTokenAmount";
                };

                return UiTokenAmount;
            })();

            ConfirmedBlock.ReturnData = (function() {

                /**
                 * Properties of a ReturnData.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface IReturnData
                 * @property {Uint8Array|null} [programId] ReturnData programId
                 * @property {Uint8Array|null} [data] ReturnData data
                 */

                /**
                 * Constructs a new ReturnData.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a ReturnData.
                 * @implements IReturnData
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.IReturnData=} [properties] Properties to set
                 */
                function ReturnData(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReturnData programId.
                 * @member {Uint8Array} programId
                 * @memberof solana.storage.ConfirmedBlock.ReturnData
                 * @instance
                 */
                ReturnData.prototype.programId = $util.newBuffer([]);

                /**
                 * ReturnData data.
                 * @member {Uint8Array} data
                 * @memberof solana.storage.ConfirmedBlock.ReturnData
                 * @instance
                 */
                ReturnData.prototype.data = $util.newBuffer([]);

                /**
                 * Creates a new ReturnData instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.ReturnData
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IReturnData=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.ReturnData} ReturnData instance
                 */
                ReturnData.create = function create(properties) {
                    return new ReturnData(properties);
                };

                /**
                 * Encodes the specified ReturnData message. Does not implicitly {@link solana.storage.ConfirmedBlock.ReturnData.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.ReturnData
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IReturnData} message ReturnData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReturnData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.programId != null && Object.hasOwnProperty.call(message, "programId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.programId);
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                    return writer;
                };

                /**
                 * Encodes the specified ReturnData message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.ReturnData.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.ReturnData
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IReturnData} message ReturnData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReturnData.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReturnData message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.ReturnData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.ReturnData} ReturnData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReturnData.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.ReturnData();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.programId = reader.bytes();
                                break;
                            }
                        case 2: {
                                message.data = reader.bytes();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReturnData message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.ReturnData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.ReturnData} ReturnData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReturnData.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReturnData message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.ReturnData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReturnData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.programId != null && message.hasOwnProperty("programId"))
                        if (!(message.programId && typeof message.programId.length === "number" || $util.isString(message.programId)))
                            return "programId: buffer expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                            return "data: buffer expected";
                    return null;
                };

                /**
                 * Creates a ReturnData message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.ReturnData
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.ReturnData} ReturnData
                 */
                ReturnData.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.ReturnData)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.ReturnData();
                    if (object.programId != null)
                        if (typeof object.programId === "string")
                            $util.base64.decode(object.programId, message.programId = $util.newBuffer($util.base64.length(object.programId)), 0);
                        else if (object.programId.length >= 0)
                            message.programId = object.programId;
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length >= 0)
                            message.data = object.data;
                    return message;
                };

                /**
                 * Creates a plain object from a ReturnData message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.ReturnData
                 * @static
                 * @param {solana.storage.ConfirmedBlock.ReturnData} message ReturnData
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReturnData.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.programId = "";
                        else {
                            object.programId = [];
                            if (options.bytes !== Array)
                                object.programId = $util.newBuffer(object.programId);
                        }
                        if (options.bytes === String)
                            object.data = "";
                        else {
                            object.data = [];
                            if (options.bytes !== Array)
                                object.data = $util.newBuffer(object.data);
                        }
                    }
                    if (message.programId != null && message.hasOwnProperty("programId"))
                        object.programId = options.bytes === String ? $util.base64.encode(message.programId, 0, message.programId.length) : options.bytes === Array ? Array.prototype.slice.call(message.programId) : message.programId;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    return object;
                };

                /**
                 * Converts this ReturnData to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.ReturnData
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReturnData.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ReturnData
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.ReturnData
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ReturnData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.ReturnData";
                };

                return ReturnData;
            })();

            /**
             * RewardType enum.
             * @name solana.storage.ConfirmedBlock.RewardType
             * @enum {number}
             * @property {number} Unspecified=0 Unspecified value
             * @property {number} Fee=1 Fee value
             * @property {number} Rent=2 Rent value
             * @property {number} Staking=3 Staking value
             * @property {number} Voting=4 Voting value
             */
            ConfirmedBlock.RewardType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Unspecified"] = 0;
                values[valuesById[1] = "Fee"] = 1;
                values[valuesById[2] = "Rent"] = 2;
                values[valuesById[3] = "Staking"] = 3;
                values[valuesById[4] = "Voting"] = 4;
                return values;
            })();

            ConfirmedBlock.Reward = (function() {

                /**
                 * Properties of a Reward.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface IReward
                 * @property {string|null} [pubkey] Reward pubkey
                 * @property {number|Long|null} [lamports] Reward lamports
                 * @property {number|Long|null} [postBalance] Reward postBalance
                 * @property {solana.storage.ConfirmedBlock.RewardType|null} [rewardType] Reward rewardType
                 * @property {string|null} [commission] Reward commission
                 */

                /**
                 * Constructs a new Reward.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a Reward.
                 * @implements IReward
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.IReward=} [properties] Properties to set
                 */
                function Reward(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Reward pubkey.
                 * @member {string} pubkey
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @instance
                 */
                Reward.prototype.pubkey = "";

                /**
                 * Reward lamports.
                 * @member {number|Long} lamports
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @instance
                 */
                Reward.prototype.lamports = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Reward postBalance.
                 * @member {number|Long} postBalance
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @instance
                 */
                Reward.prototype.postBalance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Reward rewardType.
                 * @member {solana.storage.ConfirmedBlock.RewardType} rewardType
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @instance
                 */
                Reward.prototype.rewardType = 0;

                /**
                 * Reward commission.
                 * @member {string} commission
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @instance
                 */
                Reward.prototype.commission = "";

                /**
                 * Creates a new Reward instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IReward=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.Reward} Reward instance
                 */
                Reward.create = function create(properties) {
                    return new Reward(properties);
                };

                /**
                 * Encodes the specified Reward message. Does not implicitly {@link solana.storage.ConfirmedBlock.Reward.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IReward} message Reward message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Reward.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pubkey != null && Object.hasOwnProperty.call(message, "pubkey"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubkey);
                    if (message.lamports != null && Object.hasOwnProperty.call(message, "lamports"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.lamports);
                    if (message.postBalance != null && Object.hasOwnProperty.call(message, "postBalance"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.postBalance);
                    if (message.rewardType != null && Object.hasOwnProperty.call(message, "rewardType"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.rewardType);
                    if (message.commission != null && Object.hasOwnProperty.call(message, "commission"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.commission);
                    return writer;
                };

                /**
                 * Encodes the specified Reward message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.Reward.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IReward} message Reward message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Reward.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Reward message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.Reward} Reward
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Reward.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.Reward();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.pubkey = reader.string();
                                break;
                            }
                        case 2: {
                                message.lamports = reader.int64();
                                break;
                            }
                        case 3: {
                                message.postBalance = reader.uint64();
                                break;
                            }
                        case 4: {
                                message.rewardType = reader.int32();
                                break;
                            }
                        case 5: {
                                message.commission = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Reward message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.Reward} Reward
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Reward.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Reward message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Reward.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                        if (!$util.isString(message.pubkey))
                            return "pubkey: string expected";
                    if (message.lamports != null && message.hasOwnProperty("lamports"))
                        if (!$util.isInteger(message.lamports) && !(message.lamports && $util.isInteger(message.lamports.low) && $util.isInteger(message.lamports.high)))
                            return "lamports: integer|Long expected";
                    if (message.postBalance != null && message.hasOwnProperty("postBalance"))
                        if (!$util.isInteger(message.postBalance) && !(message.postBalance && $util.isInteger(message.postBalance.low) && $util.isInteger(message.postBalance.high)))
                            return "postBalance: integer|Long expected";
                    if (message.rewardType != null && message.hasOwnProperty("rewardType"))
                        switch (message.rewardType) {
                        default:
                            return "rewardType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.commission != null && message.hasOwnProperty("commission"))
                        if (!$util.isString(message.commission))
                            return "commission: string expected";
                    return null;
                };

                /**
                 * Creates a Reward message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.Reward} Reward
                 */
                Reward.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.Reward)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.Reward();
                    if (object.pubkey != null)
                        message.pubkey = String(object.pubkey);
                    if (object.lamports != null)
                        if ($util.Long)
                            (message.lamports = $util.Long.fromValue(object.lamports)).unsigned = false;
                        else if (typeof object.lamports === "string")
                            message.lamports = parseInt(object.lamports, 10);
                        else if (typeof object.lamports === "number")
                            message.lamports = object.lamports;
                        else if (typeof object.lamports === "object")
                            message.lamports = new $util.LongBits(object.lamports.low >>> 0, object.lamports.high >>> 0).toNumber();
                    if (object.postBalance != null)
                        if ($util.Long)
                            (message.postBalance = $util.Long.fromValue(object.postBalance)).unsigned = true;
                        else if (typeof object.postBalance === "string")
                            message.postBalance = parseInt(object.postBalance, 10);
                        else if (typeof object.postBalance === "number")
                            message.postBalance = object.postBalance;
                        else if (typeof object.postBalance === "object")
                            message.postBalance = new $util.LongBits(object.postBalance.low >>> 0, object.postBalance.high >>> 0).toNumber(true);
                    switch (object.rewardType) {
                    default:
                        if (typeof object.rewardType === "number") {
                            message.rewardType = object.rewardType;
                            break;
                        }
                        break;
                    case "Unspecified":
                    case 0:
                        message.rewardType = 0;
                        break;
                    case "Fee":
                    case 1:
                        message.rewardType = 1;
                        break;
                    case "Rent":
                    case 2:
                        message.rewardType = 2;
                        break;
                    case "Staking":
                    case 3:
                        message.rewardType = 3;
                        break;
                    case "Voting":
                    case 4:
                        message.rewardType = 4;
                        break;
                    }
                    if (object.commission != null)
                        message.commission = String(object.commission);
                    return message;
                };

                /**
                 * Creates a plain object from a Reward message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @static
                 * @param {solana.storage.ConfirmedBlock.Reward} message Reward
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Reward.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.pubkey = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.lamports = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.lamports = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.postBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.postBalance = options.longs === String ? "0" : 0;
                        object.rewardType = options.enums === String ? "Unspecified" : 0;
                        object.commission = "";
                    }
                    if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                        object.pubkey = message.pubkey;
                    if (message.lamports != null && message.hasOwnProperty("lamports"))
                        if (typeof message.lamports === "number")
                            object.lamports = options.longs === String ? String(message.lamports) : message.lamports;
                        else
                            object.lamports = options.longs === String ? $util.Long.prototype.toString.call(message.lamports) : options.longs === Number ? new $util.LongBits(message.lamports.low >>> 0, message.lamports.high >>> 0).toNumber() : message.lamports;
                    if (message.postBalance != null && message.hasOwnProperty("postBalance"))
                        if (typeof message.postBalance === "number")
                            object.postBalance = options.longs === String ? String(message.postBalance) : message.postBalance;
                        else
                            object.postBalance = options.longs === String ? $util.Long.prototype.toString.call(message.postBalance) : options.longs === Number ? new $util.LongBits(message.postBalance.low >>> 0, message.postBalance.high >>> 0).toNumber(true) : message.postBalance;
                    if (message.rewardType != null && message.hasOwnProperty("rewardType"))
                        object.rewardType = options.enums === String ? $root.solana.storage.ConfirmedBlock.RewardType[message.rewardType] === undefined ? message.rewardType : $root.solana.storage.ConfirmedBlock.RewardType[message.rewardType] : message.rewardType;
                    if (message.commission != null && message.hasOwnProperty("commission"))
                        object.commission = message.commission;
                    return object;
                };

                /**
                 * Converts this Reward to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Reward.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Reward
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.Reward
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Reward.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.Reward";
                };

                return Reward;
            })();

            ConfirmedBlock.Rewards = (function() {

                /**
                 * Properties of a Rewards.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface IRewards
                 * @property {Array.<solana.storage.ConfirmedBlock.IReward>|null} [rewards] Rewards rewards
                 * @property {solana.storage.ConfirmedBlock.INumPartitions|null} [numPartitions] Rewards numPartitions
                 */

                /**
                 * Constructs a new Rewards.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a Rewards.
                 * @implements IRewards
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.IRewards=} [properties] Properties to set
                 */
                function Rewards(properties) {
                    this.rewards = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Rewards rewards.
                 * @member {Array.<solana.storage.ConfirmedBlock.IReward>} rewards
                 * @memberof solana.storage.ConfirmedBlock.Rewards
                 * @instance
                 */
                Rewards.prototype.rewards = $util.emptyArray;

                /**
                 * Rewards numPartitions.
                 * @member {solana.storage.ConfirmedBlock.INumPartitions|null|undefined} numPartitions
                 * @memberof solana.storage.ConfirmedBlock.Rewards
                 * @instance
                 */
                Rewards.prototype.numPartitions = null;

                /**
                 * Creates a new Rewards instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.Rewards
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IRewards=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.Rewards} Rewards instance
                 */
                Rewards.create = function create(properties) {
                    return new Rewards(properties);
                };

                /**
                 * Encodes the specified Rewards message. Does not implicitly {@link solana.storage.ConfirmedBlock.Rewards.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.Rewards
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IRewards} message Rewards message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Rewards.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.rewards != null && message.rewards.length)
                        for (var i = 0; i < message.rewards.length; ++i)
                            $root.solana.storage.ConfirmedBlock.Reward.encode(message.rewards[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.numPartitions != null && Object.hasOwnProperty.call(message, "numPartitions"))
                        $root.solana.storage.ConfirmedBlock.NumPartitions.encode(message.numPartitions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Rewards message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.Rewards.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.Rewards
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IRewards} message Rewards message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Rewards.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Rewards message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.Rewards
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.Rewards} Rewards
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Rewards.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.Rewards();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.rewards && message.rewards.length))
                                    message.rewards = [];
                                message.rewards.push($root.solana.storage.ConfirmedBlock.Reward.decode(reader, reader.uint32()));
                                break;
                            }
                        case 2: {
                                message.numPartitions = $root.solana.storage.ConfirmedBlock.NumPartitions.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Rewards message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.Rewards
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.Rewards} Rewards
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Rewards.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Rewards message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.Rewards
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Rewards.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.rewards != null && message.hasOwnProperty("rewards")) {
                        if (!Array.isArray(message.rewards))
                            return "rewards: array expected";
                        for (var i = 0; i < message.rewards.length; ++i) {
                            var error = $root.solana.storage.ConfirmedBlock.Reward.verify(message.rewards[i]);
                            if (error)
                                return "rewards." + error;
                        }
                    }
                    if (message.numPartitions != null && message.hasOwnProperty("numPartitions")) {
                        var error = $root.solana.storage.ConfirmedBlock.NumPartitions.verify(message.numPartitions);
                        if (error)
                            return "numPartitions." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Rewards message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.Rewards
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.Rewards} Rewards
                 */
                Rewards.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.Rewards)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.Rewards();
                    if (object.rewards) {
                        if (!Array.isArray(object.rewards))
                            throw TypeError(".solana.storage.ConfirmedBlock.Rewards.rewards: array expected");
                        message.rewards = [];
                        for (var i = 0; i < object.rewards.length; ++i) {
                            if (typeof object.rewards[i] !== "object")
                                throw TypeError(".solana.storage.ConfirmedBlock.Rewards.rewards: object expected");
                            message.rewards[i] = $root.solana.storage.ConfirmedBlock.Reward.fromObject(object.rewards[i]);
                        }
                    }
                    if (object.numPartitions != null) {
                        if (typeof object.numPartitions !== "object")
                            throw TypeError(".solana.storage.ConfirmedBlock.Rewards.numPartitions: object expected");
                        message.numPartitions = $root.solana.storage.ConfirmedBlock.NumPartitions.fromObject(object.numPartitions);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Rewards message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.Rewards
                 * @static
                 * @param {solana.storage.ConfirmedBlock.Rewards} message Rewards
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Rewards.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.rewards = [];
                    if (options.defaults)
                        object.numPartitions = null;
                    if (message.rewards && message.rewards.length) {
                        object.rewards = [];
                        for (var j = 0; j < message.rewards.length; ++j)
                            object.rewards[j] = $root.solana.storage.ConfirmedBlock.Reward.toObject(message.rewards[j], options);
                    }
                    if (message.numPartitions != null && message.hasOwnProperty("numPartitions"))
                        object.numPartitions = $root.solana.storage.ConfirmedBlock.NumPartitions.toObject(message.numPartitions, options);
                    return object;
                };

                /**
                 * Converts this Rewards to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.Rewards
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Rewards.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Rewards
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.Rewards
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Rewards.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.Rewards";
                };

                return Rewards;
            })();

            ConfirmedBlock.UnixTimestamp = (function() {

                /**
                 * Properties of an UnixTimestamp.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface IUnixTimestamp
                 * @property {number|Long|null} [timestamp] UnixTimestamp timestamp
                 */

                /**
                 * Constructs a new UnixTimestamp.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents an UnixTimestamp.
                 * @implements IUnixTimestamp
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.IUnixTimestamp=} [properties] Properties to set
                 */
                function UnixTimestamp(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UnixTimestamp timestamp.
                 * @member {number|Long} timestamp
                 * @memberof solana.storage.ConfirmedBlock.UnixTimestamp
                 * @instance
                 */
                UnixTimestamp.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new UnixTimestamp instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.UnixTimestamp
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IUnixTimestamp=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.UnixTimestamp} UnixTimestamp instance
                 */
                UnixTimestamp.create = function create(properties) {
                    return new UnixTimestamp(properties);
                };

                /**
                 * Encodes the specified UnixTimestamp message. Does not implicitly {@link solana.storage.ConfirmedBlock.UnixTimestamp.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.UnixTimestamp
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IUnixTimestamp} message UnixTimestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnixTimestamp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
                    return writer;
                };

                /**
                 * Encodes the specified UnixTimestamp message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.UnixTimestamp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.UnixTimestamp
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IUnixTimestamp} message UnixTimestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnixTimestamp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UnixTimestamp message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.UnixTimestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.UnixTimestamp} UnixTimestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnixTimestamp.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.UnixTimestamp();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.timestamp = reader.int64();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UnixTimestamp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.UnixTimestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.UnixTimestamp} UnixTimestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnixTimestamp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UnixTimestamp message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.UnixTimestamp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UnixTimestamp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                            return "timestamp: integer|Long expected";
                    return null;
                };

                /**
                 * Creates an UnixTimestamp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.UnixTimestamp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.UnixTimestamp} UnixTimestamp
                 */
                UnixTimestamp.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.UnixTimestamp)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.UnixTimestamp();
                    if (object.timestamp != null)
                        if ($util.Long)
                            (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                        else if (typeof object.timestamp === "string")
                            message.timestamp = parseInt(object.timestamp, 10);
                        else if (typeof object.timestamp === "number")
                            message.timestamp = object.timestamp;
                        else if (typeof object.timestamp === "object")
                            message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from an UnixTimestamp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.UnixTimestamp
                 * @static
                 * @param {solana.storage.ConfirmedBlock.UnixTimestamp} message UnixTimestamp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UnixTimestamp.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timestamp = options.longs === String ? "0" : 0;
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        if (typeof message.timestamp === "number")
                            object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                        else
                            object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                    return object;
                };

                /**
                 * Converts this UnixTimestamp to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.UnixTimestamp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UnixTimestamp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for UnixTimestamp
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.UnixTimestamp
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                UnixTimestamp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.UnixTimestamp";
                };

                return UnixTimestamp;
            })();

            ConfirmedBlock.BlockHeight = (function() {

                /**
                 * Properties of a BlockHeight.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface IBlockHeight
                 * @property {number|Long|null} [blockHeight] BlockHeight blockHeight
                 */

                /**
                 * Constructs a new BlockHeight.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a BlockHeight.
                 * @implements IBlockHeight
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.IBlockHeight=} [properties] Properties to set
                 */
                function BlockHeight(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BlockHeight blockHeight.
                 * @member {number|Long} blockHeight
                 * @memberof solana.storage.ConfirmedBlock.BlockHeight
                 * @instance
                 */
                BlockHeight.prototype.blockHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new BlockHeight instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.BlockHeight
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IBlockHeight=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.BlockHeight} BlockHeight instance
                 */
                BlockHeight.create = function create(properties) {
                    return new BlockHeight(properties);
                };

                /**
                 * Encodes the specified BlockHeight message. Does not implicitly {@link solana.storage.ConfirmedBlock.BlockHeight.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.BlockHeight
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IBlockHeight} message BlockHeight message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlockHeight.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.blockHeight);
                    return writer;
                };

                /**
                 * Encodes the specified BlockHeight message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.BlockHeight.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.BlockHeight
                 * @static
                 * @param {solana.storage.ConfirmedBlock.IBlockHeight} message BlockHeight message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlockHeight.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BlockHeight message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.BlockHeight
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.BlockHeight} BlockHeight
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlockHeight.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.BlockHeight();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.blockHeight = reader.uint64();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BlockHeight message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.BlockHeight
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.BlockHeight} BlockHeight
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlockHeight.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BlockHeight message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.BlockHeight
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BlockHeight.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                        if (!$util.isInteger(message.blockHeight) && !(message.blockHeight && $util.isInteger(message.blockHeight.low) && $util.isInteger(message.blockHeight.high)))
                            return "blockHeight: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a BlockHeight message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.BlockHeight
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.BlockHeight} BlockHeight
                 */
                BlockHeight.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.BlockHeight)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.BlockHeight();
                    if (object.blockHeight != null)
                        if ($util.Long)
                            (message.blockHeight = $util.Long.fromValue(object.blockHeight)).unsigned = true;
                        else if (typeof object.blockHeight === "string")
                            message.blockHeight = parseInt(object.blockHeight, 10);
                        else if (typeof object.blockHeight === "number")
                            message.blockHeight = object.blockHeight;
                        else if (typeof object.blockHeight === "object")
                            message.blockHeight = new $util.LongBits(object.blockHeight.low >>> 0, object.blockHeight.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a BlockHeight message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.BlockHeight
                 * @static
                 * @param {solana.storage.ConfirmedBlock.BlockHeight} message BlockHeight
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BlockHeight.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.blockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.blockHeight = options.longs === String ? "0" : 0;
                    if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                        if (typeof message.blockHeight === "number")
                            object.blockHeight = options.longs === String ? String(message.blockHeight) : message.blockHeight;
                        else
                            object.blockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.blockHeight) : options.longs === Number ? new $util.LongBits(message.blockHeight.low >>> 0, message.blockHeight.high >>> 0).toNumber(true) : message.blockHeight;
                    return object;
                };

                /**
                 * Converts this BlockHeight to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.BlockHeight
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BlockHeight.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BlockHeight
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.BlockHeight
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BlockHeight.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.BlockHeight";
                };

                return BlockHeight;
            })();

            ConfirmedBlock.NumPartitions = (function() {

                /**
                 * Properties of a NumPartitions.
                 * @memberof solana.storage.ConfirmedBlock
                 * @interface INumPartitions
                 * @property {number|Long|null} [numPartitions] NumPartitions numPartitions
                 */

                /**
                 * Constructs a new NumPartitions.
                 * @memberof solana.storage.ConfirmedBlock
                 * @classdesc Represents a NumPartitions.
                 * @implements INumPartitions
                 * @constructor
                 * @param {solana.storage.ConfirmedBlock.INumPartitions=} [properties] Properties to set
                 */
                function NumPartitions(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NumPartitions numPartitions.
                 * @member {number|Long} numPartitions
                 * @memberof solana.storage.ConfirmedBlock.NumPartitions
                 * @instance
                 */
                NumPartitions.prototype.numPartitions = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new NumPartitions instance using the specified properties.
                 * @function create
                 * @memberof solana.storage.ConfirmedBlock.NumPartitions
                 * @static
                 * @param {solana.storage.ConfirmedBlock.INumPartitions=} [properties] Properties to set
                 * @returns {solana.storage.ConfirmedBlock.NumPartitions} NumPartitions instance
                 */
                NumPartitions.create = function create(properties) {
                    return new NumPartitions(properties);
                };

                /**
                 * Encodes the specified NumPartitions message. Does not implicitly {@link solana.storage.ConfirmedBlock.NumPartitions.verify|verify} messages.
                 * @function encode
                 * @memberof solana.storage.ConfirmedBlock.NumPartitions
                 * @static
                 * @param {solana.storage.ConfirmedBlock.INumPartitions} message NumPartitions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NumPartitions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.numPartitions != null && Object.hasOwnProperty.call(message, "numPartitions"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.numPartitions);
                    return writer;
                };

                /**
                 * Encodes the specified NumPartitions message, length delimited. Does not implicitly {@link solana.storage.ConfirmedBlock.NumPartitions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.NumPartitions
                 * @static
                 * @param {solana.storage.ConfirmedBlock.INumPartitions} message NumPartitions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NumPartitions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NumPartitions message from the specified reader or buffer.
                 * @function decode
                 * @memberof solana.storage.ConfirmedBlock.NumPartitions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {solana.storage.ConfirmedBlock.NumPartitions} NumPartitions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NumPartitions.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.solana.storage.ConfirmedBlock.NumPartitions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.numPartitions = reader.uint64();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NumPartitions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof solana.storage.ConfirmedBlock.NumPartitions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {solana.storage.ConfirmedBlock.NumPartitions} NumPartitions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NumPartitions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NumPartitions message.
                 * @function verify
                 * @memberof solana.storage.ConfirmedBlock.NumPartitions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NumPartitions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.numPartitions != null && message.hasOwnProperty("numPartitions"))
                        if (!$util.isInteger(message.numPartitions) && !(message.numPartitions && $util.isInteger(message.numPartitions.low) && $util.isInteger(message.numPartitions.high)))
                            return "numPartitions: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a NumPartitions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof solana.storage.ConfirmedBlock.NumPartitions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {solana.storage.ConfirmedBlock.NumPartitions} NumPartitions
                 */
                NumPartitions.fromObject = function fromObject(object) {
                    if (object instanceof $root.solana.storage.ConfirmedBlock.NumPartitions)
                        return object;
                    var message = new $root.solana.storage.ConfirmedBlock.NumPartitions();
                    if (object.numPartitions != null)
                        if ($util.Long)
                            (message.numPartitions = $util.Long.fromValue(object.numPartitions)).unsigned = true;
                        else if (typeof object.numPartitions === "string")
                            message.numPartitions = parseInt(object.numPartitions, 10);
                        else if (typeof object.numPartitions === "number")
                            message.numPartitions = object.numPartitions;
                        else if (typeof object.numPartitions === "object")
                            message.numPartitions = new $util.LongBits(object.numPartitions.low >>> 0, object.numPartitions.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a NumPartitions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof solana.storage.ConfirmedBlock.NumPartitions
                 * @static
                 * @param {solana.storage.ConfirmedBlock.NumPartitions} message NumPartitions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NumPartitions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.numPartitions = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.numPartitions = options.longs === String ? "0" : 0;
                    if (message.numPartitions != null && message.hasOwnProperty("numPartitions"))
                        if (typeof message.numPartitions === "number")
                            object.numPartitions = options.longs === String ? String(message.numPartitions) : message.numPartitions;
                        else
                            object.numPartitions = options.longs === String ? $util.Long.prototype.toString.call(message.numPartitions) : options.longs === Number ? new $util.LongBits(message.numPartitions.low >>> 0, message.numPartitions.high >>> 0).toNumber(true) : message.numPartitions;
                    return object;
                };

                /**
                 * Converts this NumPartitions to JSON.
                 * @function toJSON
                 * @memberof solana.storage.ConfirmedBlock.NumPartitions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NumPartitions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for NumPartitions
                 * @function getTypeUrl
                 * @memberof solana.storage.ConfirmedBlock.NumPartitions
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                NumPartitions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/solana.storage.ConfirmedBlock.NumPartitions";
                };

                return NumPartitions;
            })();

            return ConfirmedBlock;
        })();

        return storage;
    })();

    return solana;
})();

module.exports = $root;
